#ifndef CPPFileIO_HH
#define CPPFileIO_HH
/////////////////////////
#include <stdio.h> //////
#include <time.h>   /////
#include <stdlib.h> /////
#include <string.h> /////
#include <sys/types.h> //
#include <sys/wait.h> ///
#include <sys/stat.h> ///
#include <sys/mman.h> ///
#include <fcntl.h> //////
#include <unistd.h> /////
#include <math.h> ///////
#include <string.h> /////
/////////////////////////
#include <iostream> /////
#include <vector> ///////
#include <algorithm> ////
#include <random> ///////
/////////////////////////

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
namespace CPPFileIO { //////////////////////////////////////////////////////////////////////////////////////////////////////////////

    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Pointer Management: /////////////////////////////////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    const char junk_address = 0 ; //////////////////////////////////////////////////////////////////////////////////////////////////
    const bool DEBUG = false; //////////////////////////////////////////////////////////////////////////////////////////////////////
    template <typename T> inline void set_junked  ( T * & inptr ) { inptr=(T*)(&junk_address);} ////////////////////////////////////
    template <typename T> inline bool is_junked   ( T * & inptr ) { return (inptr==(T*)(&junk_address));} //////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    template <typename T> inline bool safe_delete ( T * & inptr ) { ////////////////////////////////////////////////////////////////
        if (!is_junked(inptr)) { delete inptr; set_junked(inptr); return true; } else {return false;} //////////////////////////////
    } //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    template <typename T> inline bool safe_delete_array ( T * & inptr ) { //////////////////////////////////////////////////////////
        if (!is_junked(inptr)) { delete[] inptr; set_junked(inptr); return true; } else {return false;} ////////////////////////////
    } //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    inline size_t shifter  (size_t in) {return (1<<in);} ///////////////////////////////////////////////////////////////////////////
    inline bool   checkbit (size_t inbits, size_t checkbits) {return ((inbits&checkbits)==checkbits);} /////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    size_t NTHREADS = 4 ; //////////////////////////////////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Useful template functions : /////////////////////////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    template <typename T> inline T    mymod  ( T   a         ) { if (a<0) { return -a ; } else { return a ; } } ////////////////////
    template <typename T> inline T    mymax  ( T   a , T   b ) { if (a<b) { return  b ; } else { return a ; } } ////////////////////
    template <typename T> inline T    mymin  ( T   a , T   b ) { if (a<b) { return  a ; } else { return b ; } } ////////////////////
    template <typename T> inline T    mysign ( T   a         ) { if (a<0) { return -1 ; } else { return 1 ; } } ////////////////////
    template <typename T> inline void myswap ( T & a , T & b ) { T tmp = b ; b = a ; a = tmp ;                } ////////////////////
    template <typename T> inline long myint  ( T   x         ) { return (long) x ;                            } ////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Some simple and essential mathematics functions: ////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    template <typename T> inline T GCD (T a, T b) { ////////////////////////////////////////////////////////////////////////////////
        T ret ; ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        while( (a!=0) && (b!=0) ) { ////////////////////////////////////////////////////////////////////////////////////////////////
            if (a>b) { a = a % b ; ret = b ; } /////////////////////////////////////////////////////////////////////////////////////
            else     { b = b % a ; ret = a ; } /////////////////////////////////////////////////////////////////////////////////////
        } //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        return ret; ////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    } //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    template <typename T> inline T LCM (T a, T b) { ////////////////////////////////////////////////////////////////////////////////
        T ret ; ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        ret = GCD(a,b); ////////////////////////////////////////////////////////////////////////////////////////////////////////////
        if (ret>0) { ret = a * ( b / ret ) ; } /////////////////////////////////////////////////////////////////////////////////////
        return ret; ////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    } //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Some useful OS related functions : //////////////////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    void starter_self ( std::vector <std::string> & program ) { ////////////////////////////////////////////////////////////////////
        std::vector <char*> arrs ; /////////////////////////////////////////////////////////////////////////////////////////////////
        int j = program.size() ; ///////////////////////////////////////////////////////////////////////////////////////////////////
        arrs.resize(j+1); //////////////////////////////////////////////////////////////////////////////////////////////////////////
        for(int i=0;i<j;i++) { arrs[i] = & (program[i][0]) ; } /////////////////////////////////////////////////////////////////////
        arrs[j] = (char*) NULL ; ///////////////////////////////////////////////////////////////////////////////////////////////////
        execvp ( (const char *) arrs[0] , & (arrs[0]) ) ; //////////////////////////////////////////////////////////////////////////
    } //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    pid_t starter_fork ( std::vector <std::string> & program ) { ///////////////////////////////////////////////////////////////////
        pid_t tmp_pid = fork(); ////////////////////////////////////////////////////////////////////////////////////////////////////
        if (tmp_pid==0) { starter_self (program) ; } ///////////////////////////////////////////////////////////////////////////////
        else { return tmp_pid ; } //////////////////////////////////////////////////////////////////////////////////////////////////
        return tmp_pid ; ///////////////////////////////////////////////////////////////////////////////////////////////////////////
    } //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    void waitonall (std::vector <pid_t> childs) { //////////////////////////////////////////////////////////////////////////////////
        for(int i=0;i<childs.size();i++) { pid_t tmp = waitpid ( (pid_t) childs[i] , (int *) NULL , (int) 0 ) ; } //////////////////
    } //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    class GetArgs { ////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    private:
        ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    public:
        ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        std::vector <std::string> args ; ///////////////////////////////////////////////////////////////////////////////////////////
        ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        GetArgs  (int _argc, char ** _argv) {for(size_t i=0;i<_argc;i++){args.push_back(_argv[i]);}} ///////////////////////////////
        ~GetArgs ()                         {} /////////////////////////////////////////////////////////////////////////////////////
        ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        inline std::string & operator () (size_t i) { return args[i]      ; } //////////////////////////////////////////////////////
        inline size_t        operator () ()         { return args.size () ; } //////////////////////////////////////////////////////
        ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    }; /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Nice Class to handel forking: ///////////////////////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    class ForkMe { /////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        private: ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
            ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
            std::vector <pid_t> kids  ; ////////////////////////////////////////////////////////////////////////////////////////////
            bool                child ; ////////////////////////////////////////////////////////////////////////////////////////////
            size_t              kid_count ; ////////////////////////////////////////////////////////////////////////////////////////
            ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        public: ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
            ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
            inline bool WaitOnKids () { ////////////////////////////////////////////////////////////////////////////////////////////
                if      ( child           ) { exit (0)         ; return false ;               } ////////////////////////////////////
                else if ( kids.size() > 0 ) { waitonall (kids) ; kids.clear() ; return true ; } ////////////////////////////////////
                else                        { return false     ;                              } ////////////////////////////////////
                kid_count = 1 ; ////////////////////////////////////////////////////////////////////////////////////////////////////
            } //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
            ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
            ForkMe  () { kids.clear () ; child = false ; kid_count = 1 ; } /////////////////////////////////////////////////////////
            ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
            ~ForkMe () { if (child) { exit (0) ; } else { WaitOnKids () ; } } //////////////////////////////////////////////////////
            ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
            inline bool InKid () { /////////////////////////////////////////////////////////////////////////////////////////////////
                if (!child){ ///////////////////////////////////////////////////////////////////////////////////////////////////////
                    pid_t tmp_pid = fork () ; //////////////////////////////////////////////////////////////////////////////////////
                    if (tmp_pid==0) { child = true             ; return true  ; } //////////////////////////////////////////////////
                    else            { kids.push_back (tmp_pid) ; kid_count++ ; return false ; } ////////////////////////////////////
                } //////////////////////////////////////////////////////////////////////////////////////////////////////////////////
                else { exit (0) ; return false ; } /////////////////////////////////////////////////////////////////////////////////
            } //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
            ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
            inline void operator () (size_t _count=1) { ////////////////////////////////////////////////////////////////////////////
                if(kid_count>_count) { WaitOnKids () ; } ///////////////////////////////////////////////////////////////////////////
            } //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    }; /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    class starter { ////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    private:
        ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        // The main elements: //////////////////////////////////////////////////////////////////////////////////////////////////////
        ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        ForkMe forks ; /////////////////////////////////////////////////////////////////////////////////////////////////////////////
        ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    public:
        ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        // Constructor and Destructor: /////////////////////////////////////////////////////////////////////////////////////////////
        ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        starter  () {} /////////////////////////////////////////////////////////////////////////////////////////////////////////////
        ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        ~starter () {} /////////////////////////////////////////////////////////////////////////////////////////////////////////////
        ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

        ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        // The main functions: /////////////////////////////////////////////////////////////////////////////////////////////////////
        ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        void series (std::vector <std::string> & program) { ////////////////////////////////////////////////////////////////////////
            ForkMe tmp ; ///////////////////////////////////////////////////////////////////////////////////////////////////////////
            if(tmp.InKid()) {starter_self(program);} ///////////////////////////////////////////////////////////////////////////////
        } //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        void parallel (std::vector <std::string> & program) { //////////////////////////////////////////////////////////////////////
            if(forks.InKid()) {starter_self(program);} /////////////////////////////////////////////////////////////////////////////
        } //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        void wait () {forks.WaitOnKids();} /////////////////////////////////////////////////////////////////////////////////////////
        ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    }; /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Some functions to simplify handling vectors: ////////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    template <typename T> void clone_vector ( const std::vector <T> & src , std::vector <T> & dest ) { /////////////////////////////
        size_t n = src.size() ; ////////////////////////////////////////////////////////////////////////////////////////////////////
        dest.resize(n); ////////////////////////////////////////////////////////////////////////////////////////////////////////////
        (void *) memcpy ( (void *) &(dest[0]), (const void *) &(src[0]), (size_t) n*sizeof(T) ); ///////////////////////////////////
    } //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    template <typename T> void deduplicate (std::vector <T> & array) { /////////////////////////////////////////////////////////////
        std::vector <T> tmp_array ; ////////////////////////////////////////////////////////////////////////////////////////////////
        size_t SZ = array.size(); //////////////////////////////////////////////////////////////////////////////////////////////////
        if(SZ>1) { /////////////////////////////////////////////////////////////////////////////////////////////////////////////////
            std::sort(array.begin(),array.end()); tmp_array.push_back(array[0]); ///////////////////////////////////////////////////
            for(size_t i=1;i<SZ;i++) if(array[i]!=array[i-1]) {tmp_array.push_back(array[i]);} /////////////////////////////////////
            array.resize(tmp_array.size()) ; ///////////////////////////////////////////////////////////////////////////////////////
            memcpy ( (void *) &(array[0]) , (const void *) &(tmp_array[0]) , sizeof(T) * tmp_array.size() ) ; //////////////////////
        } //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    } //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Function to read a file line by line: ///////////////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    void getnames ( std::vector <std::string> & lines , std::string filename ) { ///////////////////////////////////////////////////
        lines.clear(); /////////////////////////////////////////////////////////////////////////////////////////////////////////////
        char *line=NULL; ///////////////////////////////////////////////////////////////////////////////////////////////////////////
        size_t len=0; //////////////////////////////////////////////////////////////////////////////////////////////////////////////
        ssize_t read; //////////////////////////////////////////////////////////////////////////////////////////////////////////////
        FILE *stream = fopen (&(filename[0]),"r") ; ////////////////////////////////////////////////////////////////////////////////
        while ((read = getline(&line, &len, stream)) != -1) { //////////////////////////////////////////////////////////////////////
            std::string linename(line); ////////////////////////////////////////////////////////////////////////////////////////////
            linename[linename.size()-1]=0; /////////////////////////////////////////////////////////////////////////////////////////
            lines.push_back(linename); /////////////////////////////////////////////////////////////////////////////////////////////
        } //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        if (len>0) {free(line);} ///////////////////////////////////////////////////////////////////////////////////////////////////
        fclose(stream); ////////////////////////////////////////////////////////////////////////////////////////////////////////////
    } //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    class FileLines { //////////////////////////////////////////////////////////////////////////////////////////////////////////////
    private:
        ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    public:
        ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        std::vector <std::string> lines    ; ///////////////////////////////////////////////////////////////////////////////////////
        std::string               filename ; ///////////////////////////////////////////////////////////////////////////////////////
        ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        FileLines  (std::string _filename) : filename(_filename) {getnames(lines,filename);} ///////////////////////////////////////
        ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        ~FileLines () {} ///////////////////////////////////////////////////////////////////////////////////////////////////////////
        ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        inline std::string & operator [] (size_t i) { return lines[i]      ; } /////////////////////////////////////////////////////
        inline size_t        size        ()         { return lines.size () ; } /////////////////////////////////////////////////////
        inline std::string & operator () (size_t i) { return lines[i]      ; } /////////////////////////////////////////////////////
        inline size_t        operator () ()         { return lines.size () ; } /////////////////////////////////////////////////////
        ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        inline void operator () (FILE *f) { for (size_t i=0;i<lines.size();i++) {fprintf(f,"%s\n",&(lines[i][0]));} } //////////////
        ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        void debug_show () { for (size_t i=0;i<lines.size();i++) {printf("%ld => [%s]\n",i,&(lines[i][0]));} } /////////////////////
        ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    }; /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    class StringSplit { ////////////////////////////////////////////////////////////////////////////////////////////////////////////
        ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    private:
        ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    public:
        ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

        ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        // The Main Data Elements: /////////////////////////////////////////////////////////////////////////////////////////////////
        ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        std::string               line    ; ////////////////////////////////////////////////////////////////////////////////////////
        std::vector <std::string> words   ; ////////////////////////////////////////////////////////////////////////////////////////
        char                      delimit ; ////////////////////////////////////////////////////////////////////////////////////////
        ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

        ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        // Important functions: ////////////////////////////////////////////////////////////////////////////////////////////////////
        ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        StringSplit  ( std::string _line = "" , char _delimit = ' ' ) : line(_line) , delimit(_delimit) { //////////////////////////
            std::vector <char> buf ; buf.reserve(line.size()) ; ////////////////////////////////////////////////////////////////////
            for (size_t i=0;i<line.size();i++) { ///////////////////////////////////////////////////////////////////////////////////
                if (line[i]==delimit) { ////////////////////////////////////////////////////////////////////////////////////////////
                    buf.push_back((char)0); ////////////////////////////////////////////////////////////////////////////////////////
                    words.push_back(std::string(&(buf[0]))); ///////////////////////////////////////////////////////////////////////
                    buf.resize(0) ; ////////////////////////////////////////////////////////////////////////////////////////////////
                    buf.push_back(line[i]); ////////////////////////////////////////////////////////////////////////////////////////
                    buf.push_back((char)0); ////////////////////////////////////////////////////////////////////////////////////////
                    words.push_back(std::string(&(buf[0]))); ///////////////////////////////////////////////////////////////////////
                    buf.resize(0) ; ////////////////////////////////////////////////////////////////////////////////////////////////
                } //////////////////////////////////////////////////////////////////////////////////////////////////////////////////
                else { buf.push_back(line[i]); } ///////////////////////////////////////////////////////////////////////////////////
            } //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
            if (buf.size()>0) { ////////////////////////////////////////////////////////////////////////////////////////////////////
                buf.push_back((char)0); ////////////////////////////////////////////////////////////////////////////////////////////
                words.push_back(std::string(&(buf[0]))); ///////////////////////////////////////////////////////////////////////////
                buf.resize(0) ; ////////////////////////////////////////////////////////////////////////////////////////////////////
            } //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
            ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        } //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        ~StringSplit () {} /////////////////////////////////////////////////////////////////////////////////////////////////////////
        ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

        ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        // Some convinent functions: ///////////////////////////////////////////////////////////////////////////////////////////////
        ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        inline std::string & operator [] (size_t i) {return words[i]     ; } ///////////////////////////////////////////////////////
        inline size_t        size        ()         {return words.size() ; } ///////////////////////////////////////////////////////
        inline std::string & operator () (size_t i) {return words[i]     ; } ///////////////////////////////////////////////////////
        inline size_t        operator () ()         {return words.size() ; } ///////////////////////////////////////////////////////
        ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

        ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        // Print the string: ///////////////////////////////////////////////////////////////////////////////////////////////////////
        ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        void show (std::string & in_line) { ////////////////////////////////////////////////////////////////////////////////////////
            std::vector <char> outline ; ///////////////////////////////////////////////////////////////////////////////////////////
            for(size_t i=0;i<words.size();i++) for(size_t j=0;j<words[i].size();j++) if(words[i][j]!=(char)0) {outline.push_back(words[i][j]);}
            outline.push_back((char)0); ////////////////////////////////////////////////////////////////////////////////////////////
            in_line = std::string( &(outline[0]) ); ////////////////////////////////////////////////////////////////////////////////
        } //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        inline void operator () (std::string & in_line) {show(in_line);} ///////////////////////////////////////////////////////////
        ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        void debug_show () { for (size_t i=0;i<words.size();i++) {printf("(%ld:%s)",i,&(words[i][0]));} } //////////////////////////
        ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

        ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    } ; ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // The Main and most important class for simplifying file handeling: ///////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    class FileFD { /////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    private:
        std::string  filename  ;
        int          fd        ;
        struct stat  abtme     ;
        int          filemode  ;
        void        *mapped    ;
        size_t       maplength ;
        int          mmapprot  ;

    public:
        void construct ( std::string Afile = std::string("outfile") ) {
            filename  = Afile      ;
            fd        = -1         ;
            filemode  = -1         ;
            mapped    = MAP_FAILED ;
            mmapprot  = PROT_NONE  ;
            maplength = 0          ;
        }
        int closefile () {
            unmapfile()          ;
            filemode = -1        ;
            mmapprot = PROT_NONE ;
            if (fd<0) {return 0;}
            else {
                int ret = (int) close ( (int) fd ) ;
                fd = -1 ;
                return ret ;
            }
        }
        inline void check_file_mode (int newfilemode = -1) {
            if (filemode!=newfilemode) {closefile();}
            if (fd<0) {
                fd = (int) open ( (const char *) &(filename[0]) , newfilemode , (mode_t) 0755 ) ;
                filemode = newfilemode ;
            }
        }
        inline void readfile   () { check_file_mode ( (int) O_RDONLY                     ) ; mmapprot = ( (int) PROT_READ               ) ; }
        inline void writefile  () { check_file_mode ( (int) O_WRONLY | O_CREAT | O_TRUNC ) ; mmapprot = ( (int) PROT_WRITE              ) ; }
        inline void appendfile () { check_file_mode ( (int) O_RDWR   | O_CREAT           ) ; mmapprot = ( (int) PROT_READ  | PROT_WRITE ) ; }
        inline void destroy    () { closefile       (                                    ) ;                                                }

        FileFD  ( const char *Afile ) { construct ( Afile ) ; }
        FileFD  (                   ) { construct (       ) ; }
        FileFD  ( std::string Afile ) { construct ( Afile ) ; }
        ~FileFD (                   ) { destroy   (       ) ; }

        void reconstruct (std::string Afile = std::string("outfile")) { destroy() ; construct (Afile) ; }
        void reconstruct (char *Afile) { reconstruct (std::string(Afile)) ; }
        inline FileFD & operator () ( std::string name ) { reconstruct(name) ; return (*this); }

        inline int truncatefile ( off_t length = 0 ) { return (int) ftruncate ( (int) fd , (off_t) length ) ; }
        inline off_t seekfile ( off_t offset = 0 , int whence = SEEK_CUR ) { return (off_t) lseek ( (int) fd , (off_t) offset , (int) whence ) ; }
        inline ssize_t read2file ( void *buf = NULL , size_t count = 0 ) { return (ssize_t) read ( (int) fd , ( void *) buf , (size_t) count ) ; }
        inline ssize_t write2file ( const void *buf = NULL , size_t count = 0 ) { return (ssize_t) write ( (int) fd , (const void *) buf , (size_t) count ) ; }
        inline int info () { return (int) fstat ( (int) fd , (struct stat *) &abtme ) ; }
        inline off_t sizefile () { info() ; return (off_t) abtme.st_size ; }
        inline std::string getfilename () { return filename; }
        inline off_t operator () ( off_t offset = 0 ) { return seekfile ( offset ) ; }
        inline FileFD & operator [] ( off_t pos ) { seekfile ( (off_t) pos , SEEK_SET ) ; return (*this) ; }
        inline int getfd () { return fd ; }

        void * mapfile ( size_t length, off_t offset = 0 ) {
            if( (maplength==0) && (mmapprot!=PROT_NONE) && (mapped==MAP_FAILED) ) {
                off_t total_len = length + offset ;
                if (sizefile()<total_len) {truncatefile(total_len);}
                mapped = (void *) mmap ( (void *) NULL , (size_t) length, (int) mmapprot , (int) MAP_SHARED , (int) fd , (off_t) offset );
                if (mapped!=MAP_FAILED) {maplength=length;}
                else {printf("MMAP FAILED 1 !!! %s\n",&(filename[0]));}
            }
            else {printf("MMAP FAILED 2 !!!\n");}
            return mapped;
        }

        int unmapfile () {
            int ret = 0 ;
            if ( (mapped!=MAP_FAILED) && (maplength>0) && (mmapprot!=PROT_NONE) ) {
                ret = (int) munmap ( (void *) mapped , (size_t) maplength ) ;
                maplength = 0 ;
                mapped = MAP_FAILED ;
            }
            return ret;
        }

        inline size_t getmaplength () { return maplength ; }

        template <typename T> inline ssize_t multiread2file  ( T &buf , size_t count = 1 ) { return read2file  ( (      void *) &buf , (size_t) sizeof(T) * count ) ; }
        template <typename T> inline ssize_t multiwrite2file ( const T &buf , size_t count = 1 ) { return write2file ( (const void *) &buf , (size_t) sizeof(T) * count ) ; }

        template <typename T> inline ssize_t WriteVector ( std::vector <T> &out ) {
            size_t count = out.size() ;
            ssize_t writtensize = multiwrite2file (count) ;
            writtensize = writtensize + multiwrite2file (out[0],count) ;
            return writtensize;
        }

        template <typename T> inline ssize_t ReadVector ( std::vector <T> &out ) {
            size_t count = 0 ;
            size_t oldsize = out.size() ;
            ssize_t writtensize = multiread2file (count) ;
            out.resize ( oldsize + count ) ;
            writtensize = multiread2file ( out[oldsize], count ) ;
            return writtensize;
        }

        inline ssize_t WriteString ( std::string &out ) {
            size_t count       = out.size() ;
            ssize_t writtensize = multiwrite2file ( count ) ;
            writtensize = writtensize + multiwrite2file(out[0],count) ;
            return writtensize;
        }

        inline ssize_t operator >> ( char      & out ) { return multiread2file  ( out ) ; }
        inline ssize_t operator << ( char        out ) { return multiwrite2file ( out ) ; }
        inline ssize_t operator >> ( int       & out ) { return multiread2file  ( out ) ; }
        inline ssize_t operator << ( int         out ) { return multiwrite2file ( out ) ; }
        inline ssize_t operator >> ( float     & out ) { return multiread2file  ( out ) ; }
        inline ssize_t operator << ( float       out ) { return multiwrite2file ( out ) ; }
        inline ssize_t operator >> ( double    & out ) { return multiread2file  ( out ) ; }
        inline ssize_t operator << ( double      out ) { return multiwrite2file ( out ) ; }
        inline ssize_t operator >> ( long      & out ) { return multiread2file  ( out ) ; }
        inline ssize_t operator << ( long        out ) { return multiwrite2file ( out ) ; }
        inline ssize_t operator >> ( size_t    & out ) { return multiread2file  ( out ) ; }
        inline ssize_t operator << ( size_t      out ) { return multiwrite2file ( out ) ; }
        inline ssize_t operator << ( std::string out ) { return WriteString     ( out ) ; }

        template <typename T> inline ssize_t operator << ( std::vector <T> &out ) { return WriteVector(out); }
        template <typename T> inline ssize_t operator >> ( std::vector <T> &out ) { return ReadVector (out); }
    }; /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Simple function for TRUE random number generation: //////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    double unique () { /////////////////////////////////////////////////////////////////////////////////////////////////////////////
        struct timespec timeout ; //////////////////////////////////////////////////////////////////////////////////////////////////
        clock_gettime(CLOCK_REALTIME,&timeout); ////////////////////////////////////////////////////////////////////////////////////
        double ret = (double) ( timeout.tv_sec + ( (double) timeout.tv_nsec / 1000000000 ) ) ; /////////////////////////////////////
        FileFD urandom((char *)"/dev/urandom"); ////////////////////////////////////////////////////////////////////////////////////
        urandom.readfile(); ////////////////////////////////////////////////////////////////////////////////////////////////////////
        double rnd ; ///////////////////////////////////////////////////////////////////////////////////////////////////////////////
        urandom >> rnd ; ///////////////////////////////////////////////////////////////////////////////////////////////////////////
        ret = ret * rnd ; //////////////////////////////////////////////////////////////////////////////////////////////////////////
        return ret;  ///////////////////////////////////////////////////////////////////////////////////////////////////////////////
    } //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    template <typename T> void GetUnique (T & Var) { double ptr = unique() ; Var=*((T*)&ptr); } ////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Class for simplifying memory mapping and array handeling: ///////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    template <typename T> class FileArray { ////////////////////////////////////////////////////////////////////////////////////////

    private:
        T *mainptr  ;
        size_t sizes[4] ;
        std::string filename ;
        FileFD filefd ;
        size_t offset ;
        size_t begin, end, length ;
        size_t act_begin, act_end, act_length ;

    public:
        inline void construct ( std::string Afilename = std::string ("outfile") , size_t Aoffset = 0 ) {
            filename = Afilename ;
            filefd(filename).readfile() ;
            sizes[0] = 4096 ;
            sizes[1] = sizeof (T) ;
            sizes[2] = LCM (sizes[0],sizes[1]) ;
            sizes[3] = sizes[2] / sizes[1] ;
            offset = Aoffset ;
            begin = 0 ; act_begin = 0 ;
            end = 0 ; act_end = 0 ;
            length = 0 ; act_length = 0 ;
        }

        inline void destroy () { filefd.destroy () ; }
        inline void reconstruct ( std::string Afilename = std::string ("outfile") , size_t Aoffset = 0 ) { destroy(); construct(Afilename,Aoffset); }
        inline FileArray & operator () ( std::string Afilename = std::string ("outfile") , size_t Aoffset = 0 ) {
            reconstruct (Afilename,Aoffset) ;
            return (*this) ;
        }

        FileArray ( std::string Afilename = std::string ("outfile") , size_t Aoffset = 0 ) { construct(Afilename,Aoffset); }
        ~FileArray () {destroy();}

        inline void writeable ( bool arg = true ) {
            if(arg) {filefd(filename).appendfile();}
            else {filefd(filename).readfile();}
        }

        void map (size_t t_begin=0, size_t t_length=1) {
            size_t t_end = t_begin + t_length ;
            if ((t_begin<begin)||(t_end>end)) {
                /* Match to sector sizes: */ {
                    begin = myint ((double)t_begin/sizes[3]) ; begin = begin * sizes[3] ;
                    length = myint ((double)t_length/sizes[3]) ; length++ ; length = length * sizes[3] ;
                    end = begin + length ;
                }
                /* Reinitiate map: */ {
                    filefd.unmapfile () ;
                    mainptr = (T*) filefd.mapfile ( (length*sizes[1]) , (begin*sizes[1]) + (offset*sizes[0]) ) ;
                }
            }
        }

        inline T & operator () ( size_t A_begin=0 , size_t A_length=1 ) {
            map (A_begin,A_length) ;
            return mainptr [A_begin-begin] ;
        }

        inline off_t filesize () { return filefd.sizefile () ; }
        inline off_t size () { return filefd.sizefile () / sizes[1] ; }
        inline off_t size ( long num ) { filefd.unmapfile(); filefd.truncatefile(num*sizes[1]); return size(); }
    }; /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    template <typename T> class FileVector { ///////////////////////////////////////////////////////////////////////////////////////
        ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    private:
        ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        FileArray <T> infile ; /////////////////////////////////////////////////////////////////////////////////////////////////////
        size_t count ; /////////////////////////////////////////////////////////////////////////////////////////////////////////////
        ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    public:
        ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        FileVector(std::string name): infile(name){ ////////////////////////////////////////////////////////////////////////////////
            infile.writeable(); ////////////////////////////////////////////////////////////////////////////////////////////////////
            count=0; ///////////////////////////////////////////////////////////////////////////////////////////////////////////////
            infile.size(count); ////////////////////////////////////////////////////////////////////////////////////////////////////
        } //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        ~FileVector(){infile.size(count);} /////////////////////////////////////////////////////////////////////////////////////////
        ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        inline size_t size() {return count ;} ////////////////////////////////////////////////////////////////////////////////
        inline void resize(size_t _size) {count=_size;} //////////////////////////////////////////////////////////////////////
        inline void push_back (T indata) { /////////////////////////////////////////////////////////////////////////////////////////
            infile(count) = indata ; ///////////////////////////////////////////////////////////////////////////////////////////////
            count++ ; //////////////////////////////////////////////////////////////////////////////////////////////////////////////
        } //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        inline T & operator [] (size_t i) {return infile(i);} //////////////////////////////////////////////////////////////////////
    }; /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    ///////////////////////////////////////////////////////////////////
    ///////////////////////////////////////////////////////////////////
    ///////////////////////////////////////////////////////////////////
    template < typename T > class latexshow { /////////////////////////
        ///////////////////////////////////////////////////////////////
    private:
        ///////////////////////////////////////////////////////////////
        long power; ///////////////////////////////////////////////////
        T num; ////////////////////////////////////////////////////////
        T input; //////////////////////////////////////////////////////
        ///////////////////////////////////////////////////////////////
        inline void reduce () { ///////////////////////////////////////
            ///////////////////////////////////////////////////////////
            while ((-1<num) && (num<1) && (num!=0)) { /////////////////
                num = num * 10.0; /////////////////////////////////////
                power--; //////////////////////////////////////////////
            } /////////////////////////////////////////////////////////
            while ((num > 10) || (-10 > num)) { ///////////////////////
                num = num / 10.0; /////////////////////////////////////
                power++; //////////////////////////////////////////////
            } /////////////////////////////////////////////////////////
        } /////////////////////////////////////////////////////////////
        ///////////////////////////////////////////////////////////////
        inline char * show (char * b) { ///////////////////////////////
            ///////////////////////////////////////////////////////////
            if ( mymod(power) > limit ) { /////////////////////////////
                sprintf (b, "{$%.3lf \\times 10^{%ld}$}", num, power);
            } else { //////////////////////////////////////////////////
                sprintf (b, "{$%.3lf$}", input); //////////////////////
            } /////////////////////////////////////////////////////////
            return b ; ////////////////////////////////////////////////
        } /////////////////////////////////////////////////////////////
        ///////////////////////////////////////////////////////////////
    public:
        ///////////////////////////////////////////////////////////////
        size_t limit; /////////////////////////////////////////////////
        ///////////////////////////////////////////////////////////////
        latexshow (T a) { /////////////////////////////////////////////
            ///////////////////////////////////////////////////////////
            input = a; ////////////////////////////////////////////////
            num = a; //////////////////////////////////////////////////
            power = 0; ////////////////////////////////////////////////
            limit = 2; ////////////////////////////////////////////////
            reduce (); ////////////////////////////////////////////////
        } /////////////////////////////////////////////////////////////
        ///////////////////////////////////////////////////////////////
        ~latexshow () { ///////////////////////////////////////////////
        } /////////////////////////////////////////////////////////////
        ///////////////////////////////////////////////////////////////
        inline char * operator  () (char * b) { ///////////////////////
            return show (b); //////////////////////////////////////////
        } /////////////////////////////////////////////////////////////
        ///////////////////////////////////////////////////////////////

    }; ////////////////////////////////////////////////////////////////
    ///////////////////////////////////////////////////////////////////

    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Class to Easily generate fancy looking tables: //////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    template <typename T> class flowtable { ////////////////////////////////////////////////////////////////////////////////////////
        ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    private:
        ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        size_t current ; ///////////////////////////////////////////////////////////////////////////////////////////////////////////
        ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        std::vector <T>           L     ; //////////////////////////////////////////////////////////////////////////////////////////
        std::vector <std::string> names ; //////////////////////////////////////////////////////////////////////////////////////////
        ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        void safefill ( size_t CLimit ) { //////////////////////////////////////////////////////////////////////////////////////////
            while ( L.size     () <= CLimit    ) { L.push_back     (0)                      ; } /////////////////////////////////////
            while ( names.size () <  L.size () ) { names.push_back (std::string("nothing")) ; } /////////////////////////////////////
        } //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        inline void safefill ()    { safefill (current) ; } ////////////////////////////////////////////////////////////////////////
        inline void namefill ()    { if (L.size()>0) { safefill (L.size()-1) ; } } /////////////////////////////////////////////////
        ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        inline void copyfrom ( const flowtable <T> & other ) { /////////////////////////////////////////////////////////////////////
            safefill (other.L.size()) ; ////////////////////////////////////////////////////////////////////////////////////////////
            memcpy ( (void*) &(L[0]) , (const void*) &(other.L[0]) , (size_t) sizeof(T) * L.size() ) ; /////////////////////////////
            current = other.current ; //////////////////////////////////////////////////////////////////////////////////////////////
        } //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        inline void startover () { current = 0 ; } /////////////////////////////////////////////////////////////////////////////////
        ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        inline void fill ( T val = 1 , std::string name = "noothing" ) { ///////////////////////////////////////////////////////////
            safefill () ; //////////////////////////////////////////////////////////////////////////////////////////////////////////
            L[current]     = L[current] + val ; ////////////////////////////////////////////////////////////////////////////////////
            names[current] = name             ; ////////////////////////////////////////////////////////////////////////////////////
            current++                         ; ////////////////////////////////////////////////////////////////////////////////////
        } //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        inline void fill ( bool val , std::string name = "nothing" ) { /////////////////////////////////////////////////////////////
            if (val) {fill(1,name);} ///////////////////////////////////////////////////////////////////////////////////////////////
            else     {fill(0,name);} ///////////////////////////////////////////////////////////////////////////////////////////////
        } //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        char * showhorizontal (std::string & linetitle) { //////////////////////////////////////////////////////////////////////////
            std::vector <std::string> parts ; /**/ { ///////////////////////////////////////////////////////////////////////////////
                std::string tmp = "\\hline " + linetitle + " &" ; //////////////////////////////////////////////////////////////////
                parts.push_back (tmp) ; ////////////////////////////////////////////////////////////////////////////////////////////
            } //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
            for(size_t i=0;i<L.size();i++){ ////////////////////////////////////////////////////////////////////////////////////////
                latexshow <T> tmplatex (L[i]) ; ////////////////////////////////////////////////////////////////////////////////////
                char tmpbuf [512] ; ////////////////////////////////////////////////////////////////////////////////////////////////
                tmplatex (tmpbuf) ; ////////////////////////////////////////////////////////////////////////////////////////////////
                if (i<L.size()-1) {parts.push_back(std::string(tmpbuf)+" &");} /////////////////////////////////////////////////////
                else {parts.push_back(std::string(tmpbuf)+" \\\\");} ///////////////////////////////////////////////////////////////
            } //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
            linetitle = parts[0] ; /////////////////////////////////////////////////////////////////////////////////////////////////
            for(size_t i=1;i<parts.size();i++){ ////////////////////////////////////////////////////////////////////////////////////
                linetitle = linetitle + parts[i] ; /////////////////////////////////////////////////////////////////////////////////
            } //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
            return &(linetitle[0]) ; ///////////////////////////////////////////////////////////////////////////////////////////////
        } //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        void showvals (std::vector <std::string> & outvals) { //////////////////////////////////////////////////////////////////////
            for(size_t i=0;i<L.size();i++) { ///////////////////////////////////////////////////////////////////////////////////////
                latexshow <double> tmpshow (L[i]) ; ////////////////////////////////////////////////////////////////////////////////
                char tmp[128] ; tmpshow(tmp) ; /////////////////////////////////////////////////////////////////////////////////////
                outvals.push_back(std::string(tmp)); ///////////////////////////////////////////////////////////////////////////////
            } //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        } //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    public:
        ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        inline void operator () () {startover();} //////////////////////////////////////////////////////////////////////////////////
        inline void operator () ( T    val , std::string name = "nothing" , bool inflag = true ) { /////////////////////////////////
            if   (inflag) { fill ( val  , name ) ; } ///////////////////////////////////////////////////////////////////////////////
            else          { fill ( (T)0 , name ) ; } ///////////////////////////////////////////////////////////////////////////////
        } //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        inline void operator () ( bool val , std::string name = "nothing" ) {fill(val,name);} //////////////////////////////////////
        inline char * operator () (std::string & linetitle) {return showhorizontal(linetitle);} ////////////////////////////////////
        inline size_t size() {return L.size();} ////////////////////////////////////////////////////////////////////////////////////
        inline T & operator [] (size_t i) {return L[i];} ///////////////////////////////////////////////////////////////////////////
        inline std::vector <std::string> & operator () (std::vector <std::string> & outvals) { /////////////////////////////////////
            showvals(outvals); /////////////////////////////////////////////////////////////////////////////////////////////////////
            return outvals; ////////////////////////////////////////////////////////////////////////////////////////////////////////
        } //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        inline size_t operator >> (CPPFileIO::FileFD & outfile) {outfile<<L;} //////////////////////////////////////////////////////
        inline size_t operator << (CPPFileIO::FileFD & outfile) {outfile>>L;} //////////////////////////////////////////////////////
        inline void operator = (const flowtable <T> & other) {copyfrom(other);} ////////////////////////////////////////////////////
        ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        void filewrite (std::string filename) { ////////////////////////////////////////////////////////////////////////////////////
            FILE *f = fopen (&(filename[0]),"w") ; /////////////////////////////////////////////////////////////////////////////////
            namefill(); ////////////////////////////////////////////////////////////////////////////////////////////////////////////
            size_t min_v = L.size(); ///////////////////////////////////////////////////////////////////////////////////////////////
            for (size_t i=0;i<min_v;i++) {fprintf(f," L [%ld] = %e \t : \t %s \n",i,(double)L[i],&(names[i][0]));} /////////////////
            fclose(f); /////////////////////////////////////////////////////////////////////////////////////////////////////////////
        } //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        flowtable() { //////////////////////////////////////////////////////////////////////////////////////////////////////////////
            L.clear(); /////////////////////////////////////////////////////////////////////////////////////////////////////////////
            current=0; /////////////////////////////////////////////////////////////////////////////////////////////////////////////
        } //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        flowtable (const flowtable & other) { //////////////////////////////////////////////////////////////////////////////////////
            copyfrom(other); ///////////////////////////////////////////////////////////////////////////////////////////////////////
            current=0; /////////////////////////////////////////////////////////////////////////////////////////////////////////////
        } //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        ~flowtable(){} /////////////////////////////////////////////////////////////////////////////////////////////////////////////
        ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    }; /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Printing the Tables: ////////////////////////////////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    class flowtables { /////////////////////////////////////////////////////////////////////////////////////////////////////////////
    private:
        FILE *f ;
    public:
        void operator () (std::string infile) {
            FileLines reader(infile);
            fprintf(f,"{|");
            for (size_t i=0;i<reader.size();i++) {fprintf(f,"c|");}
            fprintf(f,"}\n");
            for (size_t i=0;i<reader();i++) {
                if(i==0) {fprintf(f,"\\hline ");}
                else {fprintf(f,"& ");}
                fprintf(f,"%s",&(reader(i)[0]));
            }
            fprintf(f," \\\\ \n");
        }
        template <typename T> void operator () (flowtable <T> & intable, std::string eventtype) {
            fprintf(f,"%s\n",intable(eventtype));
        }
        flowtables  (FILE * _f) {f=_f;fprintf(f,"\\begin{tabular}");}
        ~flowtables ()          {fprintf(f,"\\hline \\end{tabular}\n");} ///////////////////////////////////////////////////////////
    }; /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    class LatexPrintMatrix {
    private:
        std::vector <std::string> elements ;
        size_t X, Y ;
        inline std::string & GetElement ( size_t x , size_t y ) {
            if(x>=X) {printf("BUG!!! out of bounds in x !!!\n");}
            if(y>=Y) {printf("BUG!!! out of bounds in y !!!\n");}
            return elements [x+(X*y)] ;
        }
        void Write2FILE ( FILE * f ) {
            fprintf(f,"\\begin{tabular}");
            for(size_t x=0;x<X;x++) {
                if(x==0){fprintf(f,"{|");}
                fprintf(f,"c|");
                if(x==(X-1)){fprintf(f,"}\n");}
            }
            for (size_t y=0;y<Y;y++) {
                for (size_t x=0;x<X;x++) {
                    if(x==0) {fprintf(f," \\hline %s ",&(GetElement(x,y)[0]));}
                    else     {fprintf(f," & %s ",&(GetElement(x,y)[0]));}
                }
                fprintf(f," \\\\ \n");
            }
            fprintf(f,"\\hline \\end{tabular}\n");
        }
        inline void Write2FILE ( std::string filename ) {
            FILE *f = fopen(&(filename[0]),"w");
            Write2FILE(f);
            fclose(f);
        }
    public:
        inline void operator () (std::vector <std::string> & x, size_t y) {
            size_t limit = mymin (x.size(),X) ;
            for(size_t i=0;i<limit;i++) {GetElement(i,y)=x[i];}
        }
        inline void operator () (size_t x, std::vector <std::string> & y) {
            size_t limit = mymin (y.size(),Y) ;
            for(size_t i=0;i<limit;i++) {GetElement(x,i)=y[i];}
        }
        inline void operator () (FileLines & x, size_t y) {
            size_t limit = mymin(x(),X);
            for(size_t i=0;i<limit;i++) {GetElement(i,y)=x(i);}
        }
        inline void operator () (size_t x, FileLines & y) {
            size_t limit = mymin(y(),Y);
            for(size_t i=0;i<limit;i++) {GetElement(x,i)=y(i);}
        }
        inline void operator () (FILE *f)              {Write2FILE(f);}
        inline void operator () (std::string filename) {Write2FILE(filename);}
        LatexPrintMatrix (size_t _X, size_t _Y) {
            X=_X;Y=_Y;
            elements.resize(X*Y);
        }
        ~LatexPrintMatrix(){}
    };


    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Convinent multi threadable class for uniform double random number generation: ///////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    template <typename T> class myrandgen { ////////////////////////////////////////////////////////////////////////////////////////
        ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    private:
        ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        std::vector <T*> engines ; /////////////////////////////////////////////////////////////////////////////////////////////////
        std::uniform_real_distribution <double> dist ; /////////////////////////////////////////////////////////////////////////////
        ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        inline void allocate () { //////////////////////////////////////////////////////////////////////////////////////////////////
            std::random_device random_seeds ; //////////////////////////////////////////////////////////////////////////////////////
            for(size_t i=0;i<engines.size();i++) {engines[i]=new T(random_seeds());} ///////////////////////////////////////////////
        } //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    public:
        ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        double low, high ; /////////////////////////////////////////////////////////////////////////////////////////////////////////
        ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        myrandgen(size_t threads, double _low=0, double _high=1) : low(_low) , high(_high) , dist(_low,_high) { ////////////////////
            engines.resize(threads) ; //////////////////////////////////////////////////////////////////////////////////////////////
            allocate() ; ///////////////////////////////////////////////////////////////////////////////////////////////////////////
        } //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        ~myrandgen(){ //////////////////////////////////////////////////////////////////////////////////////////////////////////////
            for(size_t i=0;i<engines.size();i++) {delete engines[i];} //////////////////////////////////////////////////////////////
        } //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        inline double operator [] (size_t th) { ////////////////////////////////////////////////////////////////////////////////////
            double ret = dist(engines[th][0]) ; ////////////////////////////////////////////////////////////////////////////////////
            return ret ; ///////////////////////////////////////////////////////////////////////////////////////////////////////////
        } //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    } ; ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    class ToDir {
    private:
        std::string originaldir ;
        inline void godir (std::string dirname) {
            mkdir((const char*)&(dirname[0]),(mode_t)0755);
            chdir((const char*)&(dirname[0]));
        }
        bool goback ;
    public:
        inline void operator () (std::string dirname) {godir(dirname);}
        inline void operator () (const char *dirname) {godir(std::string(dirname));}
        inline void operator () (long innum) {
            char tmp[128] ;
            sprintf(tmp,"%ld",innum);
            godir(std::string(tmp));
        }
        inline void operator () () {godir(originaldir);}
        inline void showdir() {
            char tmp[1024] ;
            getcwd((char*)tmp,(size_t)1024);
            printf("%s\n",tmp);
        }
        inline std::string getoriginal () {return originaldir;}
        ToDir(bool _goback=false){
            goback = _goback ;
            char tmp[1024] ;
            getcwd((char*)tmp,(size_t)1024);
            originaldir = std::string(tmp);
            std::cout << originaldir << "\n" ;
        }
        ~ToDir(){if(goback){godir(originaldir);}}
    };


} //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#define USENN

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
#ifdef USENN ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
#include "pcg.hh" //////////////////////////////////////////////////////////////////////////////////////////////////////////////////
namespace NeuralNetwork { //////////////////////////////////////////////////////////////////////////////////////////////////////////
    constexpr double eps = 0.000000001;
    typedef double FloatType ;
    namespace Arrays        {
        template < size_t arraysize = 0, typename T = FloatType >
        class Array1D {
        public:
            typedef Array1D <arraysize,T> selftype    ;
            typedef T                     selffloat   ;
        private:
            T       Store                 [arraysize] ;
            inline void Assign (const T a=0) { for (size_t i=0;i<arraysize;i++) {Store[i]=a;} }
        public:
            inline static constexpr size_t memsize () { return (sizeof(T)*arraysize) ; }
            inline static constexpr size_t Size () {return arraysize;}
            inline void ZeroAll () { Assign () ; }
            inline void CopyFrom (const T*src)
            { memcpy ((void*)Store,(const void*)src,(size_t)sizeof(T)*arraysize); }
            inline T L1Norm () const {
                T ret=0;
                for (size_t i=0;i<arraysize;i++) {ret=ret+CPPFileIO::mymod(Store[i]);}
                return ret ;
            }
            template <typename Act> inline void NNActivate (const Act&in)
            { for(size_t i=0;i<arraysize;i++){in(Store[i]);} }
            template <typename Act> inline void NNActivate (const Act&in, selftype&d1)
            { for(size_t i=0;i<arraysize;i++){in(Store[i],d1(i));} }
            template <typename Act> inline void NNActivate (const Act&in, selftype&d1, selftype&d2)
            { for(size_t i=0;i<arraysize;i++){in(Store[i],d1(i),d2(i));} }
            inline T       * operator [] (const size_t i)       { return & ( Store [i] ) ; }
            inline const T * operator [] (const size_t i) const { return & ( Store [i] ) ; }
            inline T       & operator () (const size_t i)       { return     Store [i]   ; }
            inline T         operator () (const size_t i) const { return     Store [i]   ; }
            inline size_t    operator () ()               const { return     Size   ()   ; }
            inline void      operator =  (const T a)            { Assign  (a)            ; }
            inline void      operator += (const T a)            { for (size_t i=0;i<arraysize;i++) {Store[i]+=a;} }
            inline void      operator -= (const T a)            { for (size_t i=0;i<arraysize;i++) {Store[i]-=a;} }
            inline void      operator *= (const T a)            { for (size_t i=0;i<arraysize;i++) {Store[i]*=a;} }
            inline void      operator /= (const T a)            { for (size_t i=0;i<arraysize;i++) {Store[i]/=a;} }
            inline void      CopyFrom    (const selftype & other)
            { for(size_t i=0;i<arraysize;i++) {Store[i]=other(i);} }
            inline void      operator =  (const selftype & other) {CopyFrom(other);}
            inline void      operator *= (const selftype & other)
            { for(size_t i=0;i<arraysize;i++){Store[i]*=other(i);} }
            inline void      operator += (const selftype & other)
            { for(size_t i=0;i<arraysize;i++){Store[i]+=other(i);} }
            inline void      operator -= (const selftype & other)
            { for(size_t i=0;i<arraysize;i++){Store[i]-=other(i);} }
            inline void      operator /= (const selftype & other)
            { for(size_t i=0;i<arraysize;i++){Store[i]/=other(i);} }
            inline void EqualMultiply (const selftype & other, const T a)
            { for(size_t i=0;i<arraysize;i++) {Store[i]=other(i)*a;} }
            inline void AddMultiply   (const selftype & other, const T a)
            { for(size_t i=0;i<arraysize;i++) {Store[i]+=other(i)*a;} }
            inline void SubMultiply   (const selftype & other, const T a)
            { for(size_t i=0;i<arraysize;i++) {Store[i]-=other(i)*a;} }
            inline void EqualDivide   (const selftype & other, const T a)
            { for(size_t i=0;i<arraysize;i++) {Store[i]=other(i)/a;} }
            inline void AddDivide     (const selftype & other, const T a)
            { for(size_t i=0;i<arraysize;i++) {Store[i]+=other(i)/a;} }
            inline void SubDivide     (const selftype & other, const T a)
            { for(size_t i=0;i<arraysize;i++) {Store[i]-=other(i)/a;} }
            inline ssize_t operator >> (CPPFileIO::FileFD & outfile) const
            { return outfile.multiwrite2file (Store[0],arraysize) ; }
            inline ssize_t operator << (CPPFileIO::FileFD & outfile)
            { return outfile.multiread2file (Store[0],arraysize) ; }
            Array1D(const selftype & other){(*this)=other;}
            Array1D  () {}
            ~Array1D () {}
        };

        template < size_t arraysizey = 0, size_t arraysizex = 0, typename T = FloatType >
        class Array2D {
        public:
            typedef Array1D <arraysizex*arraysizey,T> storetype ;
            typedef Array2D <arraysizey,arraysizex,T> selftype  ;
            typedef typename storetype::selffloat selffloat ;
            storetype Store ;
        private:
            inline T & Get (const size_t _Y, const size_t _X)       {return Store(GetMap(_Y,_X));}
            inline T   Get (const size_t _Y, const size_t _X) const {return Store(GetMap(_Y,_X));}
        public:
            inline ssize_t operator >> (CPPFileIO::FileFD & outfile) const
            { return (Store>>outfile) ; }
            inline ssize_t operator << (CPPFileIO::FileFD & outfile)
            { return (Store<<outfile) ; }
            inline T L1Norm () const { return Store.L1Norm () ; }
            inline void CopyFrom (const Array1D<arraysizey,T>&other)
            { for(size_t y=0;y<arraysizey;y++) for(size_t x=0;x<arraysizex;x++) {Get(y,x)=other(y);} }
            template <size_t arraysizez>
            inline void NNMultiply ( const Array2D <arraysizey,arraysizez,T> & Weight ,
                                     const Array2D <arraysizez,arraysizex,T> & Input  ,
                                     const Array1D <arraysizey,T>            & Bias   )
            {
                CopyFrom(Bias);
                for(size_t y=0;y<arraysizey;y++){
                    for(size_t z=0;z<arraysizez;z++) {
                        for(size_t x=0;x<arraysizex;x++)
                        {Get(y,x)+=Weight(y,z)*Input(z,x);}
                    }
                }
            }
            template <size_t arraysizez>
            inline void NNMultiply ( const Array2D <arraysizey,arraysizez,T> & Weight ,
                                     const Array2D <arraysizez,arraysizex,T> * Input  ,
                                     const Array1D <arraysizey,T>            & Bias   )
            { NNMultiply <arraysizez> (Weight,Input[0],Bias) ; }

            template <typename Act> inline void NNActivate (const Act&in)
            {Store.NNActivate(in);}
            template <typename Act> inline void NNActivate (const Act&in, selftype&d1)
            {Store.NNActivate(in,d1.Store);}
            template <typename Act> inline void NNActivate (const Act&in, selftype&d1, selftype&d2)
            {Store.NNActivate(in,d1.Store,d2.Store);}
            inline static constexpr size_t memsize () { return storetype::memsize() ; }
            inline static constexpr size_t GetMap (const size_t _Y, const size_t _X) { return _X+(_Y*arraysizex) ; }
            inline static constexpr size_t SizeX () {return arraysizex;}
            inline static constexpr size_t SizeY () {return arraysizey;}
            inline static constexpr size_t Size  () {return storetype::Size();}
            inline void     ZeroAll       ()                                             {Store.ZeroAll();}
            inline void     CopyFrom      (const selftype&other)                         {Store=other.Store;}
            inline T      & operator ()   (const size_t _Y,const size_t _X)              {return Get(_Y,_X);}
            inline T      & operator ()   (const size_t i)                               {return Store(i);}
            inline T        operator ()   (const size_t _Y,const size_t _X) const        {return Get(_Y,_X);}
            inline T        operator ()   (const size_t i)                  const        {return Store(i);}
            inline size_t   operator ()   ()                                const        {return Size();}
            inline void     operator =    (const T a)                                    {Store=a;}
            inline void     operator +=   (const T a)                                    {Store+=a;}
            inline void     operator -=   (const T a)                                    {Store-=a;}
            inline void     operator *=   (const T a)                                    {Store*=a;}
            inline void     operator /=   (const T a)                                    {Store/=a;}
            inline void     operator  =   (const selftype & other) {Store =other.Store;}
            inline void     operator +=   (const selftype & other) {Store+=other.Store;}
            inline void     operator -=   (const selftype & other) {Store-=other.Store;}
            inline void     operator *=   (const selftype & other) {Store*=other.Store;}
            inline void     operator /=   (const selftype & other) {Store/=other.Store;}
            inline void     EqualMultiply (const selftype & other, const T a)
            { Store.EqualMultiply(other.Store,a); }
            inline void     AddMultiply   (const selftype & other, const T a)
            { Store.AddMultiply(other.Store,a); }
            inline void     SubMultiply   (const selftype & other, const T a)
            { Store.SubMultiply(other.Store,a); }
            inline void     EqualDivide   (const selftype & other, const T a)
            { Store.EqualDivide(other.Store,a); }
            inline void     AddDivide     (const selftype & other, const T a)
            { Store.AddDivide(other.Store,a); }
            inline void     SubDivide     (const selftype & other, const T a)
            { Store.SubDivide(other.Store,a); }
            Array2D  () {}
            ~Array2D () {}
        };
    }
    namespace Parameters    {
        using namespace Arrays;

        class Nothing {
        private:
        public:
            inline void   operator () (CPPFileIO::myrandgen<pcg64_fast>&engine) {}
            inline void   ZeroAll   ()       {}
            inline void   Randomize () const {}
            inline void operator () () const {}
            inline static constexpr size_t SizeX () {return 0;}
            inline static constexpr size_t SizeY () {return 0;}
            inline void operator () (const size_t y)                       {}
            inline void operator () (const size_t y, const size_t x)       {}
            inline void operator () (const size_t y)                 const {}
            inline void operator () (const size_t y, const size_t x) const {}
            template <typename TF> inline void   Assign    (const TF a) {}
            template <typename TF> inline void operator =  (const TF a) {}
            template <typename TF> inline void operator += (const TF a) {}
            template <typename TF> inline void operator -= (const TF a) {}
            template <typename TF> inline void operator *= (const TF a) {}
            template <typename TF> inline void operator /= (const TF a) {}
            template <typename T1, typename T2> inline void operator () (const T1&a, const T2&b) const {}
            template <typename T1, typename T2, typename T3>
            inline void ApplyChanges (const T1&a,const T2&b,const T3&c,const size_t d) {}
            inline void Disturb (CPPFileIO::myrandgen<pcg64_fast>&engine) {}
            inline void MakeIdentity () const {}
            inline ssize_t operator >> (CPPFileIO::FileFD & outfile) const { }
            inline ssize_t operator << (CPPFileIO::FileFD & outfile) const { }
            Nothing  () {}
            ~Nothing () {}
        } ;

        template <size_t Y=0, typename PrevLayer=Nothing, typename TF = typename PrevLayer::SelfFloat, size_t X=PrevLayer::SizeY()>
        class MainParameter {
        public:
            typedef MainParameter < Y , Nothing   , TF , X > SelfPars   ;
            typedef MainParameter < Y , PrevLayer , TF , X > ParentPars ;
            typedef TF                                       SelfFloat  ;
            PrevLayer          Previous ;
            Array1D   <Y,TF>   Bias     ;
            Array2D   <Y,X,TF> Weight   ;
        private:
            pthread_mutex_t lock;
            inline void Randomize ( CPPFileIO::myrandgen <pcg64_fast> & engine ) {
                for(size_t y=0;y<Y;y++) {
                    for(size_t x=0;x<X;x++) {Weight(y,x)=engine[0];}
                    Bias(y)=engine[0];
                }
                Previous(engine);
            }
            inline void Randomize () {CPPFileIO::myrandgen<pcg64_fast>engine(1,-1.0,1.0);Randomize(engine);}
            inline void WriteToFile (FILE*f, std::string prefix) const {
                for(size_t y=0;y<Y;y++) for(size_t x=0;x<X;x++) {fprintf(f,"%s(%ld,%ld)=%.18e;\n",&(prefix[0]),y,x,Weight(y,x));}
                for(size_t y=0;y<Y;y++) {fprintf(f,"%s(%ld)=%.18e;\n",&(prefix[0]),y,Bias(y));}
                prefix=prefix+".Previous";
                Previous(f,prefix);
            }
            inline void WriteToFile (std::string filename, std::string prefix) const {
                FILE *f = fopen(&(filename[0]),"w");
                WriteToFile(f,prefix);
                fclose(f);
            }
        public:
            inline ssize_t operator >> (CPPFileIO::FileFD & outfile) const {
                ssize_t ret = 0 ;
                ret += ( Weight   >> outfile ) ;
                ret += ( Bias     >> outfile ) ;
                ret += ( Previous >> outfile ) ;
                return ret ;
            }
            inline ssize_t operator << (CPPFileIO::FileFD & outfile)       {
                ssize_t ret = 0 ;
                ret += ( Weight   << outfile ) ;
                ret += ( Bias     << outfile ) ;
                ret += ( Previous << outfile ) ;
                return ret ;
            }
            inline static constexpr size_t SizeX () {return X;}
            inline static constexpr size_t SizeY () {return Y;}
            inline void Release_Lock () {pthread_mutex_unlock(&lock);}
            inline void Acquire_Lock () {pthread_mutex_lock(&lock);}
            inline void Disturb (CPPFileIO::myrandgen<pcg64_fast>&engine) {
                for(size_t y=0;y<Y;y++) {
                    for(size_t x=0;x<X;x++) {Weight(y,x)+=engine[0];}
                    Bias(y)+=engine[0];
                }
                Previous.Disturb(engine);
            }
            inline void Disturb () {
                CPPFileIO::myrandgen<pcg64_fast>engine(1,-0.000001,0.000001);
                Disturb(engine);
            }
            inline void   operator ()   (FILE*f, std::string prefix)              const { WriteToFile (f,prefix)        ; }
            inline void   operator ()   (std::string filename,std::string prefix) const { WriteToFile (filename,prefix) ; }
            inline TF     operator ()   (const size_t y)                          const { return Bias   (y)             ; }
            inline TF     operator ()   (const size_t y, const size_t x)          const { return Weight (y,x)           ; }
            inline void   Assign        (const TF other) {Bias=other;Weight=other;Previous.Assign(other);}
            inline void   ZeroAll       ()                                        { Assign(0)                ; }
            inline void   operator ()   ()                                        { Randomize     ()         ; }
            inline void   operator ()   (CPPFileIO::myrandgen<pcg64_fast>&engine) { Randomize     (engine)   ; }
            inline TF &   operator ()   (const size_t y)                          { return Bias   (y)        ; }
            inline TF &   operator ()   (const size_t y, const size_t x)          { return Weight (y,x)      ; }
            inline void   operator =    (const TF a) { Assign(a); }
            inline void   operator +=   (const TF a) { Bias += a ; Weight += a ; Previous += a ; }
            inline void   operator -=   (const TF a) { Bias -= a ; Weight -= a ; Previous -= a ; }
            inline void   operator *=   (const TF a) { Bias *= a ; Weight *= a ; Previous *= a ; }
            inline void   operator /=   (const TF a) { Bias /= a ; Weight /= a ; Previous /= a ; }
            inline void MakeIdentity () {
                for(size_t y=0;y<Y;y++) {
                    for(size_t x=0;x<X;x++) {
                        if(x==y){Weight(y,x)=1;}
                        else{Weight(y,x)=0;}
                    }
                    Bias(y)=0;
                }
                Previous.MakeIdentity();
            }
            MainParameter  () {
                if(pthread_mutex_init(&lock,NULL)!=0){printf("Something went wrong...\n");}
            }
            ~MainParameter () {pthread_mutex_destroy(&lock);}
        };


        template <size_t Y=0, typename PrevLayer=Nothing, typename TF=FloatType, size_t X=PrevLayer::SizeY()>
        class AdamTrainer : public MainParameter <Y,PrevLayer,TF,X> {
        public:
            typedef MainParameter <Y,PrevLayer,TF,X> ParentPars ;
            typedef typename ParentPars::SelfPars SelfPars ;
        private:
            SelfPars    M      , V      ;
            const    TF Beta1  , Beta2  ;
            TF          Beta1T , Beta2T ;
        private:
            inline void clear () {M.ZeroAll();V.ZeroAll();Beta1T=Beta1;Beta2T=Beta2;}

//            inline TF Mhat ( size_t y           ) const { return M(y)   / (1.0-Beta1T) ; }
//            inline TF Mhat ( size_t y ,size_t x ) const { return M(y,x) / (1.0-Beta1T) ; }
//            inline TF Vhat ( size_t y           ) const { return V(y)   / (1.0-Beta2T) ; }
//            inline TF Vhat ( size_t y ,size_t x ) const { return V(y,x) / (1.0-Beta2T) ; }

            inline TF Mhat ( size_t y           ) const { return M(y)   ; }
            inline TF Mhat ( size_t y ,size_t x ) const { return M(y,x) ; }
            inline TF Vhat ( size_t y           ) const { return V(y)   ; }
            inline TF Vhat ( size_t y ,size_t x ) const { return V(y,x) ; }

        public:

            inline void ApplyChanges (
                const SelfPars & other , const SelfPars & otherM , const SelfPars & other2 ,
                const TF a=1.0         , const size_t count=0
            ) {
                this->Acquire_Lock(); /* The Locked Section: */ {

                    for(size_t y=0;y<Y;y++) for(size_t x=0;x<X;x++)
                    { M(y,x)=(M(y,x)*Beta1)+((1.0-Beta1)*other(y,x)); }

                    for(size_t y=0;y<Y;y++)
                    { M(y)=(M(y)*Beta1)+((1.0-Beta1)*other(y)); }

                    for(size_t y=0;y<Y;y++) for(size_t x=0;x<X;x++)
                    { V(y,x)=(V(y,x)*Beta2)+((1.0-Beta2)*other2(y,x));}

                    for(size_t y=0;y<Y;y++)
                    { V(y)=(V(y)*Beta2)+((1.0-Beta2)*other2(y));}

                    for(size_t y=0;y<Y;y++)for(size_t x=0;x<X;x++){
                        TF tmp = a * Mhat(y,x) / ( eps + sqrt(Vhat(y,x)) ) ;
                        this->Weight(y,x) -= ((TF)tmp/count) ;
                    }

                    for(size_t y=0;y<Y;y++){
                        TF tmp = a * Mhat(y) / ( eps + sqrt(Vhat(y)) ) ;
                        this->Bias(y) -= ((TF)tmp/count) ;
                    }

                    {Beta1T=Beta1T*Beta1;Beta2T=Beta2T*Beta2;}

                } this->Release_Lock();
            }

            inline static constexpr bool EvalD    () {return true;}
            inline static constexpr bool EvalD2   () {return true;}
            inline static constexpr bool EvalDM   () {return false;}

            AdamTrainer  (const TF _Beta1=0.9,const TF _Beta2=0.99) : Beta1(_Beta1), Beta2(_Beta2) {clear();}
            ~AdamTrainer () {}
        } ;

        template <size_t Y=0, typename PrevLayer=Nothing, typename TF=FloatType, size_t X=PrevLayer::SizeY()>
        class AdamTrainer2 : public MainParameter <Y,PrevLayer,TF,X> {
        public:
            typedef MainParameter <Y,PrevLayer,TF,X> ParentPars ;
            typedef typename ParentPars::SelfPars SelfPars ;
        private:
            SelfPars    M      , V      ;
            const    TF Beta1  , Beta2  ;
            TF          Beta1T , Beta2T ;
        private:
            inline void clear () {M.ZeroAll();V.ZeroAll();Beta1T=Beta1;Beta2T=Beta2;}
            inline TF Mhat ( size_t y           ) const { return M(y)   / (1.0-Beta1T) ; }
            inline TF Mhat ( size_t y ,size_t x ) const { return M(y,x) / (1.0-Beta1T) ; }
            inline TF Vhat ( size_t y           ) const { return V(y)   / (1.0-Beta2T) ; }
            inline TF Vhat ( size_t y ,size_t x ) const { return V(y,x) / (1.0-Beta2T) ; }
        public:
            inline void ApplyChanges (
                const SelfPars & other , const SelfPars & otherM , const SelfPars & other2 ,
                const TF a=1.0         , const size_t count=0
            ) {
                this->Acquire_Lock(); /* The Locked Section: */ {

                    for(size_t y=0;y<Y;y++) for(size_t x=0;x<X;x++)
                    { M(y,x)=(M(y,x)*Beta1)+((1.0-Beta1)*other(y,x)); }

                    for(size_t y=0;y<Y;y++)
                    { M(y)=(M(y)*Beta1)+((1.0-Beta1)*other(y)); }

                    for(size_t y=0;y<Y;y++) for(size_t x=0;x<X;x++)
                    { V(y,x)=(V(y,x)*Beta2)+((1.0-Beta2)*other2(y,x));}

                    for(size_t y=0;y<Y;y++)
                    { V(y)=(V(y)*Beta2)+((1.0-Beta2)*other2(y));}

                    for(size_t y=0;y<Y;y++)for(size_t x=0;x<X;x++){
                        TF tmp = a * Mhat(y,x)*CPPFileIO::mymod(Mhat(y,x)) / ( eps + Vhat(y,x) ) ;
                        this->Weight(y,x) -= ((TF)tmp/count) ;
                    }

                    for(size_t y=0;y<Y;y++){
                        TF tmp = a * Mhat(y)*CPPFileIO::mymod(Mhat(y)) / ( eps + Vhat(y) ) ;
                        this->Bias(y) -= ((TF)tmp/count) ;
                    }

                    {Beta1T=Beta1T*Beta1;Beta2T=Beta2T*Beta2;}

                } this->Release_Lock();
            }

            inline static constexpr bool EvalD    () {return true;}
            inline static constexpr bool EvalD2   () {return true;}
            inline static constexpr bool EvalDM   () {return false;}

            AdamTrainer2  (const TF _Beta1=0.9,const TF _Beta2=0.99) : Beta1(_Beta1), Beta2(_Beta2) {clear();}
            ~AdamTrainer2 () {}
        } ;

        template <size_t Y=0, typename PrevLayer=Nothing, typename TF=FloatType, size_t X=PrevLayer::SizeY()>
        class AdamTrainer2Reg : public MainParameter <Y,PrevLayer,TF,X> {
        public:
            typedef MainParameter <Y,PrevLayer,TF,X> ParentPars ;
            typedef typename ParentPars::SelfPars SelfPars ;
        private:
            SelfPars    M      , V      , L      ;
            const    TF Beta1  , Beta2  , BetaM  ;
            TF          Beta1T , Beta2T , BetaMT ;
        private:
            inline void clear () {M.ZeroAll();V.ZeroAll();L.ZeroAll();Beta1T=Beta1;Beta2T=Beta2;}
            inline TF Mhat ( size_t y           ) const { return M(y)   / (1.0-Beta1T) ; }
            inline TF Mhat ( size_t y ,size_t x ) const { return M(y,x) / (1.0-Beta1T) ; }
            inline TF Lhat ( size_t y           ) const { return L(y)   / (1.0-BetaMT) ; }
            inline TF Lhat ( size_t y ,size_t x ) const { return L(y,x) / (1.0-BetaMT) ; }
            inline TF Vhat ( size_t y           ) const { return V(y)   / (1.0-Beta2T) ; }
            inline TF Vhat ( size_t y ,size_t x ) const { return V(y,x) / (1.0-Beta2T) ; }
        public:
            inline void ApplyChanges (
                const SelfPars & other , const SelfPars & otherM , const SelfPars & other2 ,
                const TF a=1.0         , const size_t count=0
            ) {
                this->Acquire_Lock(); /* The Locked Section: */ {

                    for(size_t y=0;y<Y;y++) for(size_t x=0;x<X;x++)
                    { M(y,x)=(M(y,x)*Beta1)+((1.0-Beta1)*other(y,x)); }

                    for(size_t y=0;y<Y;y++)
                    { M(y)=(M(y)*Beta1)+((1.0-Beta1)*other(y)); }

                    for(size_t y=0;y<Y;y++) for(size_t x=0;x<X;x++)
                    { L(y,x)=(L(y,x)*BetaM)+((1.0-BetaM)*otherM(y,x)); }

                    for(size_t y=0;y<Y;y++)
                    { L(y)=(L(y)*BetaM)+((1.0-BetaM)*otherM(y)); }

                    for(size_t y=0;y<Y;y++) for(size_t x=0;x<X;x++)
                    { V(y,x)=(V(y,x)*Beta2)+((1.0-Beta2)*other2(y,x));}

                    for(size_t y=0;y<Y;y++)
                    { V(y)=(V(y)*Beta2)+((1.0-Beta2)*other2(y));}

                    for(size_t y=0;y<Y;y++)for(size_t x=0;x<X;x++){
                        TF tmp = a * Mhat(y,x)*Mhat(y,x)*Mhat(y,x) / ( eps + (Vhat(y,x)*Lhat(y,x)) ) ;
                        this->Weight(y,x) -= ((TF)tmp/count) ;
                    }

                    for(size_t y=0;y<Y;y++){
                        TF tmp = a * Mhat(y)*Mhat(y)*Mhat(y) / ( eps + (Vhat(y)*Lhat(y)) ) ;
                        this->Bias(y) -= ((TF)tmp/count) ;
                    }

                    {Beta1T=Beta1T*Beta1;Beta2T=Beta2T*Beta2;BetaMT=BetaMT*BetaM;}

                } this->Release_Lock();
            }

            inline static constexpr bool EvalD    () {return true;}
            inline static constexpr bool EvalD2   () {return true;}
            inline static constexpr bool EvalDM   () {return true;}

            AdamTrainer2Reg  ( const TF _Beta1=0.9, const TF _Beta2=0.99, const TF _BetaM=0.8 ) :
            Beta1(_Beta1), Beta2(_Beta2), BetaM(_BetaM) {clear();}
            ~AdamTrainer2Reg () {}
        } ;

        template <size_t Y=0, typename PrevLayer=Nothing, typename TF=FloatType, size_t X=PrevLayer::SizeY()>
        class AdamRegTrainer : public MainParameter <Y,PrevLayer,TF,X> {
        public:
            typedef MainParameter <Y,PrevLayer,TF,X> ParentPars ;
            typedef typename ParentPars::SelfPars SelfPars ;
        private:
            SelfPars    M      , V      , L ;
            const    TF Beta1  , Beta2  ;
            TF          Beta1T , Beta2T ;
        private:
            inline void clear () {M.ZeroAll();V.ZeroAll();L.ZeroAll();Beta1T=Beta1;Beta2T=Beta2;}
            inline TF Mhat ( size_t y           ) const { return M(y)   / (1.0-Beta1T) ; }
            inline TF Mhat ( size_t y ,size_t x ) const { return M(y,x) / (1.0-Beta1T) ; }
            inline TF Lhat ( size_t y           ) const { return L(y)   / (1.0-Beta1T) ; }
            inline TF Lhat ( size_t y ,size_t x ) const { return L(y,x) / (1.0-Beta1T) ; }
            inline TF Vhat ( size_t y           ) const { return V(y)   / (1.0-Beta2T) ; }
            inline TF Vhat ( size_t y ,size_t x ) const { return V(y,x) / (1.0-Beta2T) ; }
        public:
            inline void ApplyChanges (
                const SelfPars & other , const SelfPars & otherM , const SelfPars & other2 ,
                const TF a=1.0         , const size_t count=0
            ) {
                this->Acquire_Lock(); /* The Locked part: */ {

                    for(size_t y=0;y<Y;y++) for(size_t x=0;x<X;x++)
                    { M(y,x) = ( M(y,x) * Beta1 ) + ( (1.0-Beta1) * other(y,x) ) ; }

                    for(size_t y=0;y<Y;y++)
                    { M(y) = ( M(y) * Beta1 ) + ( (1.0-Beta1) * other(y) ) ; }

                    for(size_t y=0;y<Y;y++) for(size_t x=0;x<X;x++)
                    { L(y,x) = (L(y,x)*Beta1) + ( (1.0-Beta1) * CPPFileIO::mymod(other(y,x)/(otherM(y,x)+eps)) ) ; }

                    for(size_t y=0;y<Y;y++)
                    { L(y) = (L(y)*Beta1) + ( (1.0-Beta1) * CPPFileIO::mymod(other(y)/(otherM(y)+eps)) ) ; }

                    for(size_t y=0;y<Y;y++) for(size_t x=0;x<X;x++)
                    { V(y,x) = (V(y,x)*Beta2) + ( (1.0-Beta2) * other2(y,x) ) ; }

                    for(size_t y=0;y<Y;y++)
                    { V(y) = (V(y)*Beta2) + ( (1.0-Beta2) * other2(y) ) ; }

                    for(size_t y=0;y<Y;y++)for(size_t x=0;x<X;x++){
                        TF tmp = a * Lhat(y,x) * Mhat(y,x) / ( eps + sqrt(Vhat(y,x)) ) ;
                        this->Weight(y,x) -= ((TF)tmp/count) ;
                    }

                    for(size_t y=0;y<Y;y++){
                        TF tmp = a * Lhat(y) * Mhat(y) / ( eps + sqrt(Vhat(y)) ) ;
                        this->Bias(y) -= ((TF)tmp/count) ;
                    }

                    {Beta1T=Beta1T*Beta1;Beta2T=Beta2T*Beta2;}

                } this->Release_Lock();
            }
            inline static constexpr bool EvalD    () {return true;}
            inline static constexpr bool EvalD2   () {return true;}
            inline static constexpr bool EvalDM   () {return true;}

            AdamRegTrainer  (const TF _Beta1=0.9,const TF _Beta2=0.99) : Beta1(_Beta1), Beta2(_Beta2) {clear();}
            ~AdamRegTrainer () {}
        } ;

        template <size_t Y=0, typename PrevLayer=Nothing, typename TF=FloatType, size_t X=PrevLayer::SizeY()>
        class AdamRegTrainer2 : public MainParameter <Y,PrevLayer,TF,X> {
        public:
            typedef MainParameter <Y,PrevLayer,TF,X> ParentPars ;
            typedef typename ParentPars::SelfPars SelfPars ;
        private:
            SelfPars    M      , V      ;
            const    TF Beta1  , Beta2  ;
            TF          Beta1T , Beta2T ;
        private:
            inline void clear () {M.ZeroAll();V.ZeroAll();Beta1T=Beta1;Beta2T=Beta2;}
            inline TF Mhat ( size_t y           ) const { return M(y)   / (1.0-Beta1T) ; }
            inline TF Mhat ( size_t y ,size_t x ) const { return M(y,x) / (1.0-Beta1T) ; }
            inline TF Vhat ( size_t y           ) const { return V(y)   / (1.0-Beta2T) ; }
            inline TF Vhat ( size_t y ,size_t x ) const { return V(y,x) / (1.0-Beta2T) ; }
        public:
            inline void ApplyChanges (
                const SelfPars & other , const SelfPars & otherM , const SelfPars & other2 ,
                const TF a=1.0         , const size_t count=0
            ) {
                this->Acquire_Lock(); /* The Locked Section: */ {

                    for(size_t y=0;y<Y;y++) for(size_t x=0;x<X;x++)
                    { M(y,x)=(M(y,x)*Beta1)+((1.0-Beta1)*other(y,x)); }

                    for(size_t y=0;y<Y;y++)
                    { M(y)=(M(y)*Beta1)+((1.0-Beta1)*other(y)); }

                    for(size_t y=0;y<Y;y++) for(size_t x=0;x<X;x++)
                    { V(y,x)=(V(y,x)*Beta2)+((1.0-Beta2)*other2(y,x));}

                    for(size_t y=0;y<Y;y++)
                    { V(y)=(V(y)*Beta2)+((1.0-Beta2)*other2(y));}

                    for(size_t y=0;y<Y;y++)for(size_t x=0;x<X;x++){
                        TF tmp = a * (CPPFileIO::mymod(other(y,x))/otherM(y,x)) * Mhat(y,x) / ( eps + sqrt(Vhat(y,x)) ) ;
                        this->Weight(y,x) -= ((TF)tmp/count) ;
                    }

                    for(size_t y=0;y<Y;y++){
                        TF tmp = a * (CPPFileIO::mymod(other(y))/otherM(y)) * Mhat(y) / ( eps + sqrt(Vhat(y)) ) ;
                        this->Bias(y) -= ((TF)tmp/count) ;
                    }

                    {Beta1T=Beta1T*Beta1;Beta2T=Beta2T*Beta2;}

                } this->Release_Lock();
            }
            inline static constexpr bool EvalD    () {return true;}
            inline static constexpr bool EvalD2   () {return true;}
            inline static constexpr bool EvalDM   () {return true;}

            AdamRegTrainer2  (const TF _Beta1=0.9,const TF _Beta2=0.99) : Beta1(_Beta1), Beta2(_Beta2) {clear();}
            ~AdamRegTrainer2 () {}
        } ;

        template <size_t Y=0, typename PrevLayer=Nothing, typename TF=FloatType, size_t X=PrevLayer::SizeY()>
        class AdamRegTrainer3 : public MainParameter <Y,PrevLayer,TF,X> {
        public:
            typedef MainParameter <Y,PrevLayer,TF,X> ParentPars ;
            typedef typename ParentPars::SelfPars SelfPars ;
        private:
            SelfPars    M      , V      ;
            const    TF Beta1  , Beta2  ;
            TF          Beta1T , Beta2T ;
        private:
            inline void clear () {M.ZeroAll();V.ZeroAll();Beta1T=Beta1;Beta2T=Beta2;}
            inline TF Mhat ( size_t y           ) const { return M(y)   / (1.0-Beta1T) ; }
            inline TF Mhat ( size_t y ,size_t x ) const { return M(y,x) / (1.0-Beta1T) ; }
            inline TF Vhat ( size_t y           ) const { return V(y)   / (1.0-Beta2T) ; }
            inline TF Vhat ( size_t y ,size_t x ) const { return V(y,x) / (1.0-Beta2T) ; }
        public:
            inline void ApplyChanges (
                const SelfPars & other , const SelfPars & otherM , const SelfPars & other2 ,
                const TF a=1.0         , const size_t count=0
            ) {
                this->Acquire_Lock(); /* The Locked Section: */ {

                    for(size_t y=0;y<Y;y++) for(size_t x=0;x<X;x++)
                    { M(y,x)=(M(y,x)*Beta1)+((1.0-Beta1)*other(y,x)); }

                    for(size_t y=0;y<Y;y++)
                    { M(y)=(M(y)*Beta1)+((1.0-Beta1)*other(y)); }

                    for(size_t y=0;y<Y;y++) for(size_t x=0;x<X;x++)
                    { V(y,x)=(V(y,x)*Beta2)+((1.0-Beta2)*other2(y,x));}

                    for(size_t y=0;y<Y;y++)
                    { V(y)=(V(y)*Beta2)+((1.0-Beta2)*other2(y));}

                    for(size_t y=0;y<Y;y++)for(size_t x=0;x<X;x++){
                        TF tmp = a * (CPPFileIO::mymod(other(y,x))/otherM(y,x)) * Mhat(y,x)*CPPFileIO::mymod(Mhat(y,x)) / ( eps + Vhat(y,x) ) ;
                        this->Weight(y,x) -= ((TF)tmp/count) ;
                    }

                    for(size_t y=0;y<Y;y++){
                        TF tmp = a * (CPPFileIO::mymod(other(y))/otherM(y)) * Mhat(y)*CPPFileIO::mymod(Mhat(y)) / ( eps + Vhat(y) ) ;
                        this->Bias(y) -= ((TF)tmp/count) ;
                    }

                    {Beta1T=Beta1T*Beta1;Beta2T=Beta2T*Beta2;}

                } this->Release_Lock();
            }
            inline static constexpr bool EvalD    () {return true;}
            inline static constexpr bool EvalD2   () {return true;}
            inline static constexpr bool EvalDM   () {return true;}

            AdamRegTrainer3  (const TF _Beta1=0.9,const TF _Beta2=0.99) : Beta1(_Beta1), Beta2(_Beta2) {clear();}
            ~AdamRegTrainer3 () {}
        } ;

        template <size_t Y=0, typename PrevLayer=Nothing, typename TF=FloatType, size_t X=PrevLayer::SizeY()>
        class MomentumTrainer : public MainParameter <Y,PrevLayer,TF,X> {
        public:
            typedef MainParameter <Y,PrevLayer,TF,X> ParentPars ;
            typedef typename ParentPars::SelfPars    SelfPars   ;
        private:
            SelfPars    V ;
        private:
            inline void clear () {V.ZeroAll();}
        public:
            inline void ApplyChanges (
                const SelfPars & other , const SelfPars & otherM , const SelfPars & other2 ,
                const TF a=1.0         , const size_t count=0
            ) {
                for (size_t y=0;y<Y;y++) for (size_t x=0;x<X;x++) {
                    const TF factor = CPPFileIO::mymod(other(y,x))/(otherM(y,x)+eps) ;
                    V(y,x) = (V(y,x)*factor) + other(y,x) ;
                    this->Weight(y,x) -= V(y,x) * a * factor / (TF)count ;
                }
                for (size_t y=0;y<Y;y++) {
                    const TF factor = CPPFileIO::mymod(other(y))/(otherM(y)+eps) ;
                    V(y) = (V(y)*factor) + other(y) ;
                    this->Bias(y) -= V(y) * a * factor / (TF)count ;
                }
            }
            inline static constexpr bool EvalD    () {return true;}
            inline static constexpr bool EvalD2   () {return false;}
            inline static constexpr bool EvalDM   () {return true;}

            MomentumTrainer  () {clear();}
            ~MomentumTrainer () {}
        } ;

        template <size_t Y=0, typename PrevLayer=Nothing, typename TF=FloatType, size_t X=PrevLayer::SizeY()>
        class SimpleGradTrainer : public MainParameter <Y,PrevLayer,TF,X> {
        public:
            typedef MainParameter <Y,PrevLayer,TF,X> ParentPars ;
            typedef typename ParentPars::SelfPars SelfPars ;
            inline void ApplyChanges (
                const SelfPars & other , const SelfPars & otherM , const SelfPars & other2 ,
                const TF a=1.0         , const size_t count=0
            ) {
                for(size_t y=0;y<Y;y++)for(size_t x=0;x<X;x++){
                    TF tmp = ( (TF) (other(y,x)*a) / count ) ;
                    this->Weight(y,x) -= tmp ;
                }
                for(size_t y=0;y<Y;y++){
                    TF tmp = ( (TF) (other(y)*a) / count ) ;
                    this->Bias(y) -= tmp ;
                }
            }
            inline static constexpr bool EvalD    () {return true;}
            inline static constexpr bool EvalD2   () {return false;}
            inline static constexpr bool EvalDM   () {return false;}

            SimpleGradTrainer  () {}
            ~SimpleGradTrainer () {}
        } ;

    }
    namespace Activators    {
        class Activate_Identity {
        private:
        public:
            template <typename T> inline void operator () (T&dst,T&drv1,T&drv2) const {drv1=1.0;drv2=0.0;}
            template <typename T> inline void operator () (T&dst,T&drv1) const {drv1=1.0;}
            template <typename T> inline void operator () (T&dst) const {}
            Activate_Identity  (){}
            ~Activate_Identity (){}
        };

        class Activate_LRU      {
        private:
        public:
            template <typename T> inline void operator () (T&dst,T&drv1,T&drv2) const {
                if(dst<0.0){dst=0.0;drv1=0.0;drv2=0.0;}
                else{drv1=1.0;drv2=0.0;}
            }
            template <typename T> inline void operator () (T&dst,T&drv1) const {
                if(dst<0.0){dst=0.0;drv1=0.0;}
                else{drv1=1.0;}
            }
            template <typename T> inline void operator () (T&dst) const {
                if(dst<0.0){dst=0.0;}
            }
            Activate_LRU  (){}
            ~Activate_LRU (){}
        };

        class Activate_Sigmoid  {
        private:
        public:
            template <typename T> inline void operator () (T&dst,T&drv1,T&drv2) const {
                T tmp = dst ;
                if ( tmp >  5 ) { tmp =  5 ; }
                if ( tmp < -5 ) { tmp = -5 ; }
                tmp = 1.0 / ( 1.0 + exp(-tmp) ) ;
                dst = tmp ;
                tmp = tmp * (1.0-tmp) ;
                if (tmp<0.001) {tmp=0.001;}
                drv1 = tmp ;
                drv2 = tmp * (1.0-(2.0*dst)) ;
            }
            template <typename T> inline void operator () (T&dst,T&drv1) const {
                T tmp = dst ;
                if ( tmp >  5 ) { tmp =  5 ; }
                if ( tmp < -5 ) { tmp = -5 ; }
                tmp = 1.0 / ( 1.0 + exp(-tmp) ) ;
                dst = tmp ;
                tmp = tmp * (1.0-tmp) ;
                if (tmp<0.001) {tmp=0.001;}
                drv1 = tmp ;
            }
            template <typename T> inline void operator () (T&dst) const {
                if ( dst >  5 ) { dst =  5 ; }
                if ( dst < -5 ) { dst = -5 ; }
                dst = 1.0 / ( 1.0 + exp(-dst) ) ;
            }
            Activate_Sigmoid  (){}
            ~Activate_Sigmoid (){}
        };

        class Activate_SoftSign {
        private:
        public:
            template <typename T> inline void operator () (T&dst,T&drv1,T&drv2) const {
                T out = dst / ( 1.0 + CPPFileIO::mymod (dst) ) ;
                T xsq = dst * dst ;
                drv1  = out * out / xsq ;
                drv2  = 2.0 * out * ( drv1 - (out/dst) ) / xsq ;
                dst   = out ;
            }
            template <typename T> inline void operator () (T&dst,T&drv1) const {
                T tmp = 1.0 / ( 1.0 + CPPFileIO::mymod (dst) ) ;
                drv1  = tmp * tmp ;
                dst   = tmp * dst ;
            }
            template <typename T> inline void operator () (T&dst) const {
                dst = dst / ( 1.0 + CPPFileIO::mymod (dst) ) ;
            }
            Activate_SoftSign  (){}
            ~Activate_SoftSign (){}
        };

        class Activate_SoftLRU  {
        private:
        public:
            template <typename T> inline void operator () (T&dst,T&drv1,T&drv2) const {
                if(dst<0){
                    T out = dst / ( 1.0 - dst ) ;
                    T xsq = dst * dst ;
                    drv1  = out * out / xsq ;
                    drv2  = 2.0 * out * ( drv1 - (out/dst) ) / xsq ;
                    dst   = out ;
                } else {drv1=1.0;drv2=0.0;}
            }
            template <typename T> inline void operator () (T&dst,T&drv1) const {
                if(dst<0){
                    T tmp = 1.0 / ( 1.0 - dst ) ;
                    drv1  = tmp * tmp ;
                    dst   = tmp * dst ;
                } else {drv1=1.0;}
            }
            template <typename T> inline void operator () (T&dst) const {
                if(dst<0){dst=dst/(1.0-dst);}
            }
            Activate_SoftLRU  () {}
            ~Activate_SoftLRU () {}
        };
    }
    namespace NetworkLayers {
        constexpr double eps2 = 0.0001;
        using namespace Arrays     ;
        using namespace Parameters ;
        using namespace Activators ;

        template <typename ArrayType> class StartingLayer {
        public:
            typedef        ArrayType                           FirstInputType  ;
            typedef        FirstInputType                      OutputArrayType ;
            typedef        typename       ArrayType::selffloat TF              ;
            FirstInputType *                                   Output          ;
        public:
            inline static constexpr      size_t SizeX      ()              {return 0;}
            inline static constexpr      size_t SizeY      ()              {return ArrayType::SizeY();}
            inline static constexpr      size_t SizeZ      ()              {return ArrayType::SizeX();}
            inline static constexpr      size_t FirstSizeX ()              {return SizeX();}
            inline static constexpr      size_t FirstSizeY ()              {return SizeY();}
            inline static constexpr      size_t FirstSizeZ ()              {return SizeZ();}
            template <typename T> inline void   operator   () (T&in) const {}
            template <typename T> inline void   operator   () (T*in) const {}
            inline                       void   operator   () ()     const {}
            inline void                         ClearD     ()        const {}
            inline TF & operator () (const size_t y, const size_t z)       { return Output[0](y,z); }
            inline TF   operator () (const size_t y, const size_t z) const { return Output[0](y,z); }
            inline void SetFirstInput (FirstInputType * Input) { Output =   Input ; }
            inline void SetFirstInput (FirstInputType & Input) { Output = & Input ; }
            template <typename TF> inline void SetLambda (TF _Lambda) const {}
            StartingLayer  () {}
            ~StartingLayer () {}
        };

        template <typename TP, typename Tpars, typename ActType=Activate_SoftLRU> class TrainableNeuralLayer {
        public:
            inline static constexpr size_t SizeX      () { return Tpars::SizeX   () ; }
            inline static constexpr size_t SizeY      () { return Tpars::SizeY   () ; }
            inline static constexpr size_t SizeZ      () { return TP::SizeZ      () ; }
            inline static constexpr size_t FirstSizeX () { return TP::FirstSizeX () ; }
            inline static constexpr size_t FirstSizeY () { return TP::FirstSizeY () ; }
            inline static constexpr size_t FirstSizeZ () { return TP::FirstSizeZ () ; }
            typedef typename TP::FirstInputType   FirstInputType  ;
            typedef typename Tpars::SelfPars      SelfPars        ;
            typedef typename TP::TF               TF              ;
            typedef Array2D  <SizeY(),SizeZ(),TF> OutputArrayType ;
            typedef Array2D  <SizeX(),SizeZ(),TF> InputArrayType  ;
        public:
            TP              Previous   ;
            InputArrayType  ChainDelta ;
            OutputArrayType Output     , Diff[2] , Pi ;
            TF              Lambda     ;
        private:
            SelfPars   DPars     , DParsM , DPars2 ;
            Tpars    * Pars      ;
            size_t     count     ;
            ActType    activator ;
        private:
            inline void TrainOnDelta (const OutputArrayType & indelta) {
                count+=SizeZ() ; // Keeping count.
                /* Evaluate Pi for future needs: */ {
                    for(size_t y=0;y<Pi.SizeY();y++)for(size_t x=0;x<Pi.SizeX();x++)
                    {Pi(y,x)=indelta(y,x)*Diff[0](y,x);}
                }
                /* Apply changes to parameters: */ if(true) {

                    if ( Tpars::EvalD () )  for (size_t y=0;y<SizeY();y++) for (size_t z=0;z<SizeZ();z++)
                    { DPars(y) += Pi(y,z) ; }

                    if ( Tpars::EvalDM () ) for (size_t y=0;y<SizeY();y++) for (size_t z=0;z<SizeZ();z++)
                    { DParsM(y) += CPPFileIO::mymod(Pi(y,z)) ; }

                    if ( Tpars::EvalD2 () ) for (size_t y=0;y<SizeY();y++) for (size_t z=0;z<SizeZ();z++)
                    { DPars2(y) += Pi(y,z) * Pi(y,z) ; }

                    for (size_t y=0;y<SizeY();y++) for (size_t x=0;x<SizeX();x++) {
                        TF Sum=0 , SumM=0 , Sum2=0 ;
                        const TF Factor = Lambda * (Pars[0](y,x)) ;
                        for(size_t z=0;z<SizeZ();z++) {
                            const TF tmp = (Pi(y,z)*Previous(x,z)) + Factor ;
                            if ( Tpars::EvalD  () ) { Sum  += (tmp)                  ; }
                            if ( Tpars::EvalDM () ) { SumM += CPPFileIO::mymod (tmp) ; }
                            if ( Tpars::EvalD2 () ) { Sum2 += (tmp*tmp)              ; }
                        }
                        if ( Tpars::EvalD  () ) { DPars  (y,x) += Sum  + Factor                      ; }
                        if ( Tpars::EvalDM () ) { DParsM (y,x) += SumM + CPPFileIO::mymod ( Factor ) ; }
                        if ( Tpars::EvalD2 () ) { DPars2 (y,x) += Sum2 + ( Factor * Factor )         ; }
                    }
                }
                /* Prepare this layers propagation: */ {
                    ChainDelta.ZeroAll () ;
                    for(size_t y=0;y<Pi.SizeY();y++) {
                        for(size_t x=0;x<ChainDelta.SizeY();x++) {
                            for(size_t z=0;z<ChainDelta.SizeX();z++)
                            { ChainDelta(x,z) += Pi(y,z) * Pars[0](y,x) ; }
                        }
                    }
                    Previous (ChainDelta) ;
                }
            }
            inline void Activate () {
                Previous();
                Output.NNMultiply(Pars->Weight,Previous.Output,Pars->Bias);
                Output.NNActivate(activator,Diff[0],Diff[1]);
            }
            inline void ApplyChanges (const TF eta=1.0) {
                if (count>0) {Pars->ApplyChanges(DPars,DParsM,DPars2,eta,count);}
                Previous(eta); ClearD();
            }
            inline void ApplyChanges (const TF * eta) {
                if (count>0) {Pars->ApplyChanges(DPars,DParsM,DPars2,eta[0],count);}
                Previous(&(eta[1])); ClearD();
            }
        public:
            inline void SetLambda (TF _Lambda) { Lambda = _Lambda ; Previous.SetLambda(_Lambda) ; }
            inline void   ClearD  () {
                if ( Tpars::EvalD  () ) { DPars.ZeroAll  () ; }
                if ( Tpars::EvalDM () ) { DParsM.ZeroAll () ; }
                if ( Tpars::EvalD2 () ) { DPars2.ZeroAll () ; }
                count=0;
            }
            inline TF & operator () (const size_t y, const size_t z)       { return Output(y,z); }
            inline TF   operator () (const size_t y, const size_t z) const { return Output(y,z); }
            inline void operator () () {Activate();}
            inline void operator () ( const TF   eta ) { ApplyChanges (eta) ; }
            inline void operator () ( const TF * eta ) { ApplyChanges (eta) ; }
            inline void operator () ( const OutputArrayType & indelta ) { TrainOnDelta (indelta) ; }
            inline void SetFirstInput (FirstInputType * input ) { Previous.SetFirstInput (   input ) ; }
            inline void SetFirstInput (FirstInputType & input ) { Previous.SetFirstInput ( & input ) ; }
            inline void operator () ( Tpars & _Pars ) { Pars = & _Pars ; Previous ( _Pars.Previous  ) ; }
            inline void operator () ( Tpars * _Pars ) { Pars =   _Pars ; Previous ( _Pars->Previous ) ; }
            TrainableNeuralLayer  () {}
            ~TrainableNeuralLayer () {}
        };

        template <typename TP, typename Tpars> class Teacher {
        public:
            inline static constexpr size_t SizeX      () { return TP::SizeX      () ; }
            inline static constexpr size_t SizeY      () { return TP::SizeY      () ; }
            inline static constexpr size_t SizeZ      () { return TP::SizeZ      () ; }
            inline static constexpr size_t FirstSizeX () { return TP::FirstSizeX () ; }
            inline static constexpr size_t FirstSizeY () { return TP::FirstSizeY () ; }
            inline static constexpr size_t FirstSizeZ () { return TP::FirstSizeZ () ; }
            typedef typename TP::TF              TF              ;
            typedef typename TP::FirstInputType  FirstInputType  ;
            typedef typename TP::OutputArrayType OutputArrayType ;
            TP                Previous ;
            OutputArrayType * Answer   ;
            OutputArrayType   Delta    ;
        private:
            inline TF Train () {
                Previous();
                for(size_t y=0;y<OutputArrayType::SizeY();y++) {
                    for(size_t x=0;x<OutputArrayType::SizeX();x++)
                    { Delta(y,x) = Previous(y,x) - Answer[0](y,x) ; }
                }
                Previous(Delta);
                return Delta.L1Norm() / SizeZ() ;
            }
        public:
            inline TF & operator () (const size_t y, const size_t z)       { return Previous(y,z); }
            inline TF   operator () (const size_t y, const size_t z) const { return Previous(y,z); }
            inline TF   operator () () {return Train();}
            inline void operator () ( const TF   eta ) { Previous (eta) ; }
            inline void operator () ( const TF * eta ) { Previous (eta) ; }
            inline void operator () ( OutputArrayType & ans ) { Answer = & ans ; }
            inline void operator () ( OutputArrayType * ans ) { Answer =   ans ; }
            inline void SetFirstInput (FirstInputType * input ) { Previous.SetFirstInput (   input ) ; }
            inline void SetFirstInput (FirstInputType & input ) { Previous.SetFirstInput ( & input ) ; }
            inline void operator () ( Tpars & _Pars ) { Previous ( _Pars ) ; }
            inline void operator () ( Tpars * _Pars ) { Previous ( _Pars ) ; }
            inline void SetLambda (TF _Lambda) { Previous.SetLambda(_Lambda) ; }
            Teacher(){}
            ~Teacher(){}
        } ;

        template <typename TP, typename Tpars> class TeacherRel {
        public:
            inline static constexpr size_t SizeX      () { return TP::SizeX      () ; }
            inline static constexpr size_t SizeY      () { return TP::SizeY      () ; }
            inline static constexpr size_t SizeZ      () { return TP::SizeZ      () ; }
            inline static constexpr size_t FirstSizeX () { return TP::FirstSizeX () ; }
            inline static constexpr size_t FirstSizeY () { return TP::FirstSizeY () ; }
            inline static constexpr size_t FirstSizeZ () { return TP::FirstSizeZ () ; }
            typedef typename TP::TF              TF              ;
            typedef typename TP::FirstInputType  FirstInputType  ;
            typedef typename TP::OutputArrayType OutputArrayType ;
            TP                Previous ;
            OutputArrayType * Answer   ;
            OutputArrayType   Delta    ;
        private:
            inline TF Train () {
                Previous();
                for(size_t y=0;y<OutputArrayType::SizeY();y++) {
                    for(size_t x=0;x<OutputArrayType::SizeX();x++)
                    { Delta(y,x) = ( Previous(y,x) - Answer[0](y,x) ) / ((Answer[0](y,x)*Answer[0](y,x))+eps2) ; }
                }
                Previous(Delta);
                return Delta.L1Norm() / SizeZ() ;
            }
        public:
            inline TF & operator () (const size_t y, const size_t z)       { return Previous(y,z); }
            inline TF   operator () (const size_t y, const size_t z) const { return Previous(y,z); }
            inline TF   operator () () {return Train();}
            inline void operator () ( const TF   eta ) { Previous (eta) ; }
            inline void operator () ( const TF * eta ) { Previous (eta) ; }
            inline void operator () ( OutputArrayType & ans ) { Answer = & ans ; }
            inline void operator () ( OutputArrayType * ans ) { Answer =   ans ; }
            inline void SetFirstInput (FirstInputType * input ) { Previous.SetFirstInput (   input ) ; }
            inline void SetFirstInput (FirstInputType & input ) { Previous.SetFirstInput ( & input ) ; }
            inline void operator () ( Tpars & _Pars ) { Previous ( _Pars ) ; }
            inline void operator () ( Tpars * _Pars ) { Previous ( _Pars ) ; }
            inline void SetLambda (TF _Lambda) { Previous.SetLambda(_Lambda) ; }
            TeacherRel(){}
            ~TeacherRel(){}
        } ;

        template <typename TP, typename Tpars> class TeacherBoth {
        public:
            inline static constexpr size_t SizeX      () { return TP::SizeX      () ; }
            inline static constexpr size_t SizeY      () { return TP::SizeY      () ; }
            inline static constexpr size_t SizeZ      () { return TP::SizeZ      () ; }
            inline static constexpr size_t FirstSizeX () { return TP::FirstSizeX () ; }
            inline static constexpr size_t FirstSizeY () { return TP::FirstSizeY () ; }
            inline static constexpr size_t FirstSizeZ () { return TP::FirstSizeZ () ; }
            typedef typename TP::TF              TF              ;
            typedef typename TP::FirstInputType  FirstInputType  ;
            typedef typename TP::OutputArrayType OutputArrayType ;
            TP                Previous ;
            OutputArrayType * Answer   ;
            OutputArrayType   Delta    ;
        private:
            inline TF Train () {
                Previous();
                for(size_t y=0;y<OutputArrayType::SizeY();y++) {
                    for(size_t x=0;x<OutputArrayType::SizeX();x++) {
                        TF     tmp = Previous(y,x) - Answer[0](y,x) ;
                        Delta(y,x) = tmp * ( 1.0 + ( 1.0 / ((Answer[0](y,x)*Answer[0](y,x))+eps2) ) ) ;
                    }
                }
                Previous(Delta);
                return Delta.L1Norm() / SizeZ() ;
            }
        public:
            inline TF & operator () (const size_t y, const size_t z)       { return Previous(y,z); }
            inline TF   operator () (const size_t y, const size_t z) const { return Previous(y,z); }
            inline TF   operator () () {return Train();}
            inline void operator () ( const TF   eta ) { Previous (eta) ; }
            inline void operator () ( const TF * eta ) { Previous (eta) ; }
            inline void operator () ( OutputArrayType & ans ) { Answer = & ans ; }
            inline void operator () ( OutputArrayType * ans ) { Answer =   ans ; }
            inline void SetFirstInput (FirstInputType * input ) { Previous.SetFirstInput (   input ) ; }
            inline void SetFirstInput (FirstInputType & input ) { Previous.SetFirstInput ( & input ) ; }
            inline void operator () ( Tpars & _Pars ) { Previous ( _Pars ) ; }
            inline void operator () ( Tpars * _Pars ) { Previous ( _Pars ) ; }
            inline void SetLambda (TF _Lambda) { Previous.SetLambda(_Lambda) ; }
            TeacherBoth(){}
            ~TeacherBoth(){}
        } ;
    }
    namespace Sample        {

        template <typename T> inline void reader (T & in) {
            #include "testingpars"
        }
        inline void worker () {
            using namespace NetworkLayers ;

            constexpr size_t datasize = 99999                                ;
            constexpr double xmin     = -5                                   ;
            constexpr double xmax     = +5                                   ;
            constexpr double dx       = ( xmax - xmin ) / ((double)datasize) ;

            typedef Array2D <1,datasize,double> InputArrayType ;

            typedef Nothing                         P0 ;

//            typedef AdamTrainer2 <5,P0,double,1> P1 ;
//            typedef AdamTrainer2 <5,P1,double>   P2 ;
//            typedef AdamTrainer2 <1,P2,double>   P3 ;

            typedef AdamTrainer2Reg <5,P0,double,1> P1 ;
            typedef AdamTrainer2Reg <5,P1,double>   P2 ;
            typedef AdamTrainer2Reg <1,P2,double>   P3 ;

            typedef P3 MainPars ;

            typedef StartingLayer        <InputArrayType>          L0 ;
            typedef TrainableNeuralLayer <L0,P1,Activate_SoftLRU>  L1 ;
            typedef TrainableNeuralLayer <L1,P2,Activate_SoftLRU>  L2 ;
            typedef TrainableNeuralLayer <L2,P3,Activate_Identity> L3 ;
            typedef L3 MainNet ;

            typedef Teacher <MainNet, MainPars> Net ;
            printf("%ld\n",sizeof(Net)/1048576);

            InputArrayType * ptrs   = new InputArrayType [2] ;
            InputArrayType & array  = ptrs               [0] ;
            InputArrayType & answer = ptrs               [1] ;

            /* Prepare the data */ {
                for(size_t i=0;i<datasize;i++){
                    const double x = xmin+(i*dx) ;
                    array  (0,i) = x          ;
                    answer (0,i) = x*x - 10.0 ;
                }
            }

            MainPars pars; pars();
            reader(pars);

            Net * slave = new Net ; slave[0](pars);

            slave[0].SetFirstInput(&array);
            slave[0](answer);

            for(size_t epoch=0;epoch<5000000;epoch++){
                printf("Error = %e\n",slave[0]());

                slave[0]((double)5.5);

                pars("testingpars","in");
            }

            delete slave;
            delete [] ptrs ;
        }
    }
} //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#endif /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#endif
