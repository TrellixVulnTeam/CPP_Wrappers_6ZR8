#ifndef CPPFileIO_HH
#define CPPFileIO_HH
#define _GNU_SOURCE

/////////////////////////
#include <sched.h> //////
/////////////////////////
#include <stdio.h> //////
#include <time.h>   /////
#include <stdlib.h> /////
#include <string.h> /////
#include <sys/types.h> //
#include <sys/wait.h> ///
#include <sys/stat.h> ///
#include <sys/mman.h> ///
#include <fcntl.h> //////
#include <unistd.h> /////
#include <math.h> ///////
#include <string.h> /////
/////////////////////////
#include <iostream> /////
#include <vector> ///////
#include <algorithm> ////
#include <random> ///////
/////////////////////////

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
namespace CPPFileIO { //////////////////////////////////////////////////////////////////////////////////////////////////////////////

    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Pointer Management: /////////////////////////////////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    const char junk_address = 0 ; //////////////////////////////////////////////////////////////////////////////////////////////////
    const bool DEBUG = false; //////////////////////////////////////////////////////////////////////////////////////////////////////
    template <typename T> inline void set_junked  ( T * & inptr ) { inptr=(T*)(&junk_address);} ////////////////////////////////////
    template <typename T> inline bool is_junked   ( T * & inptr ) { return (inptr==(T*)(&junk_address));} //////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    template <typename T> inline bool safe_delete ( T * & inptr ) { ////////////////////////////////////////////////////////////////
        if (!is_junked(inptr)) { delete inptr; set_junked(inptr); return true; } else {return false;} //////////////////////////////
    } //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    template <typename T> inline bool safe_delete_array ( T * & inptr ) { //////////////////////////////////////////////////////////
        if (!is_junked(inptr)) { delete[] inptr; set_junked(inptr); return true; } else {return false;} ////////////////////////////
    } //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    inline size_t shifter  (size_t in) {return (1<<in);} ///////////////////////////////////////////////////////////////////////////
    inline bool   checkbit (size_t inbits, size_t checkbits) {return ((inbits&checkbits)==checkbits);} /////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    size_t NTHREADS = 4 ; //////////////////////////////////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Useful template functions : /////////////////////////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    template <typename T> inline T    mymod  ( T   a         ) { if (a<0) { return -a ; } else { return a ; } } ////////////////////
    template <typename T> inline T    mymax  ( T   a , T   b ) { if (a<b) { return  b ; } else { return a ; } } ////////////////////
    template <typename T> inline T    mymin  ( T   a , T   b ) { if (a<b) { return  a ; } else { return b ; } } ////////////////////
    template <typename T> inline T    mysign ( T   a         ) { if (a<0) { return -1 ; } else { return 1 ; } } ////////////////////
    template <typename T> inline void myswap ( T & a , T & b ) { T tmp = b ; b = a ; a = tmp ;                } ////////////////////
    template <typename T> inline long myint  ( T   x         ) { return (long) x ;                            } ////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Some simple and essential mathematics functions: ////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    template <typename T> inline T GCD (T a, T b) { ////////////////////////////////////////////////////////////////////////////////
        T ret ; ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        while( (a!=0) && (b!=0) ) { ////////////////////////////////////////////////////////////////////////////////////////////////
            if (a>b) { a = a % b ; ret = b ; } /////////////////////////////////////////////////////////////////////////////////////
            else     { b = b % a ; ret = a ; } /////////////////////////////////////////////////////////////////////////////////////
        } //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        return ret; ////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    } //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    template <typename T> inline T LCM (T a, T b) { ////////////////////////////////////////////////////////////////////////////////
        T ret ; ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        ret = GCD(a,b); ////////////////////////////////////////////////////////////////////////////////////////////////////////////
        if (ret>0) { ret = a * ( b / ret ) ; } /////////////////////////////////////////////////////////////////////////////////////
        return ret; ////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    } //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Some useful OS related functions : //////////////////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    void starter_self ( std::vector <std::string> & program ) { ////////////////////////////////////////////////////////////////////
        std::vector <char*> arrs ; /////////////////////////////////////////////////////////////////////////////////////////////////
        int j = program.size() ; ///////////////////////////////////////////////////////////////////////////////////////////////////
        arrs.resize(j+1); //////////////////////////////////////////////////////////////////////////////////////////////////////////
        for(int i=0;i<j;i++) { arrs[i] = & (program[i][0]) ; } /////////////////////////////////////////////////////////////////////
        arrs[j] = (char*) NULL ; ///////////////////////////////////////////////////////////////////////////////////////////////////
        execvp ( (const char *) arrs[0] , & (arrs[0]) ) ; //////////////////////////////////////////////////////////////////////////
    } //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    pid_t starter_fork ( std::vector <std::string> & program ) { ///////////////////////////////////////////////////////////////////
        pid_t tmp_pid = fork(); ////////////////////////////////////////////////////////////////////////////////////////////////////
        if (tmp_pid==0) { starter_self (program) ; } ///////////////////////////////////////////////////////////////////////////////
        else { return tmp_pid ; } //////////////////////////////////////////////////////////////////////////////////////////////////
        return tmp_pid ; ///////////////////////////////////////////////////////////////////////////////////////////////////////////
    } //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    void waitonall (std::vector <pid_t> childs) { //////////////////////////////////////////////////////////////////////////////////
        for(int i=0;i<childs.size();i++) { pid_t tmp = waitpid ( (pid_t) childs[i] , (int *) NULL , (int) 0 ) ; } //////////////////
    } //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    class GetArgs { ////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    private:
        ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    public:
        ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        std::vector <std::string> args ; ///////////////////////////////////////////////////////////////////////////////////////////
        ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        GetArgs  (int _argc, char ** _argv) {for(size_t i=0;i<_argc;i++){args.push_back(_argv[i]);}} ///////////////////////////////
        ~GetArgs ()                         {} /////////////////////////////////////////////////////////////////////////////////////
        ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        inline std::string & operator () (size_t i) { return args[i]      ; } //////////////////////////////////////////////////////
        inline size_t        operator () ()         { return args.size () ; } //////////////////////////////////////////////////////
        ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    }; /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Nice Class to handel forking: ///////////////////////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    class ForkMe { /////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        private: ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
            ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
            std::vector <pid_t> kids  ; ////////////////////////////////////////////////////////////////////////////////////////////
            bool                child ; ////////////////////////////////////////////////////////////////////////////////////////////
            size_t              kid_count ; ////////////////////////////////////////////////////////////////////////////////////////
            ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        public: ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
            ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
            inline bool WaitOnKids () { ////////////////////////////////////////////////////////////////////////////////////////////
                if      ( child           ) { exit (0)         ; return false ;               } ////////////////////////////////////
                else if ( kids.size() > 0 ) { waitonall (kids) ; kids.clear() ; return true ; } ////////////////////////////////////
                else                        { return false     ;                              } ////////////////////////////////////
                kid_count = 1 ; ////////////////////////////////////////////////////////////////////////////////////////////////////
            } //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
            ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
            ForkMe  () { kids.clear () ; child = false ; kid_count = 1 ; } /////////////////////////////////////////////////////////
            ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
            ~ForkMe () { if (child) { exit (0) ; } else { WaitOnKids () ; } } //////////////////////////////////////////////////////
            ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
            inline bool InKid () { /////////////////////////////////////////////////////////////////////////////////////////////////
                if (!child){ ///////////////////////////////////////////////////////////////////////////////////////////////////////
                    pid_t tmp_pid = fork () ; //////////////////////////////////////////////////////////////////////////////////////
                    if (tmp_pid==0) { child = true             ; return true  ; } //////////////////////////////////////////////////
                    else            { kids.push_back (tmp_pid) ; kid_count++ ; return false ; } ////////////////////////////////////
                } //////////////////////////////////////////////////////////////////////////////////////////////////////////////////
                else { exit (0) ; return false ; } /////////////////////////////////////////////////////////////////////////////////
            } //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
            ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
            inline void operator () (size_t _count=1) { ////////////////////////////////////////////////////////////////////////////
                if(kid_count>_count) { WaitOnKids () ; } ///////////////////////////////////////////////////////////////////////////
            } //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    }; /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    class starter { ////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    private:
        ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        // The main elements: //////////////////////////////////////////////////////////////////////////////////////////////////////
        ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        ForkMe forks ; /////////////////////////////////////////////////////////////////////////////////////////////////////////////
        ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    public:
        ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        // Constructor and Destructor: /////////////////////////////////////////////////////////////////////////////////////////////
        ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        starter  () {} /////////////////////////////////////////////////////////////////////////////////////////////////////////////
        ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        ~starter () {} /////////////////////////////////////////////////////////////////////////////////////////////////////////////
        ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

        ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        // The main functions: /////////////////////////////////////////////////////////////////////////////////////////////////////
        ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        void series (std::vector <std::string> & program) { ////////////////////////////////////////////////////////////////////////
            ForkMe tmp ; ///////////////////////////////////////////////////////////////////////////////////////////////////////////
            if(tmp.InKid()) {starter_self(program);} ///////////////////////////////////////////////////////////////////////////////
        } //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        void parallel (std::vector <std::string> & program) { //////////////////////////////////////////////////////////////////////
            if(forks.InKid()) {starter_self(program);} /////////////////////////////////////////////////////////////////////////////
        } //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        void wait () {forks.WaitOnKids();} /////////////////////////////////////////////////////////////////////////////////////////
        ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    }; /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // CPU AFFINITY RELATED: ///////////////////////////////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    inline void SetCPUAffinity (int cpunum) { //////////////////////////////////////////////////////////////////////////////////////
        cpu_set_t set; CPU_ZERO(&set); CPU_SET(cpunum, &set); //////////////////////////////////////////////////////////////////////
        if (sched_setaffinity(getpid(), sizeof(set), &set) == -1) {printf(" Error setting affinity...\n ");} ///////////////////////
    } //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Some functions to simplify handling vectors: ////////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    template <typename T> void clone_vector ( const std::vector <T> & src , std::vector <T> & dest ) { /////////////////////////////
        size_t n = src.size() ; ////////////////////////////////////////////////////////////////////////////////////////////////////
        dest.resize(n); ////////////////////////////////////////////////////////////////////////////////////////////////////////////
        (void *) memcpy ( (void *) &(dest[0]), (const void *) &(src[0]), (size_t) n*sizeof(T) ); ///////////////////////////////////
    } //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    template <typename T> void deduplicate (std::vector <T> & array) { /////////////////////////////////////////////////////////////
        std::vector <T> tmp_array ; ////////////////////////////////////////////////////////////////////////////////////////////////
        size_t SZ = array.size(); //////////////////////////////////////////////////////////////////////////////////////////////////
        if(SZ>1) { /////////////////////////////////////////////////////////////////////////////////////////////////////////////////
            std::sort(array.begin(),array.end()); tmp_array.push_back(array[0]); ///////////////////////////////////////////////////
            for(size_t i=1;i<SZ;i++) if(array[i]!=array[i-1]) {tmp_array.push_back(array[i]);} /////////////////////////////////////
            array.resize(tmp_array.size()) ; ///////////////////////////////////////////////////////////////////////////////////////
            memcpy ( (void *) &(array[0]) , (const void *) &(tmp_array[0]) , sizeof(T) * tmp_array.size() ) ; //////////////////////
        } //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    } //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Function to read a file line by line: ///////////////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    void getnames ( std::vector <std::string> & lines , std::string filename ) { ///////////////////////////////////////////////////
        lines.clear(); /////////////////////////////////////////////////////////////////////////////////////////////////////////////
        char *line=NULL; ///////////////////////////////////////////////////////////////////////////////////////////////////////////
        size_t len=0; //////////////////////////////////////////////////////////////////////////////////////////////////////////////
        ssize_t read; //////////////////////////////////////////////////////////////////////////////////////////////////////////////
        FILE *stream = fopen (&(filename[0]),"r") ; ////////////////////////////////////////////////////////////////////////////////
        while ((read = getline(&line, &len, stream)) != -1) { //////////////////////////////////////////////////////////////////////
            std::string linename(line); ////////////////////////////////////////////////////////////////////////////////////////////
            linename[linename.size()-1]=0; /////////////////////////////////////////////////////////////////////////////////////////
            lines.push_back(linename); /////////////////////////////////////////////////////////////////////////////////////////////
        } //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        if (len>0) {free(line);} ///////////////////////////////////////////////////////////////////////////////////////////////////
        fclose(stream); ////////////////////////////////////////////////////////////////////////////////////////////////////////////
    } //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    class FileLines { //////////////////////////////////////////////////////////////////////////////////////////////////////////////
    private:
        ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    public:
        ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        std::vector <std::string> lines    ; ///////////////////////////////////////////////////////////////////////////////////////
        std::string               filename ; ///////////////////////////////////////////////////////////////////////////////////////
        ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        FileLines  (std::string _filename) : filename(_filename) {getnames(lines,filename);} ///////////////////////////////////////
        ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        ~FileLines () {} ///////////////////////////////////////////////////////////////////////////////////////////////////////////
        ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        inline std::string & operator [] (size_t i) { return lines[i]      ; } /////////////////////////////////////////////////////
        inline size_t        size        ()         { return lines.size () ; } /////////////////////////////////////////////////////
        inline std::string & operator () (size_t i) { return lines[i]      ; } /////////////////////////////////////////////////////
        inline size_t        operator () ()         { return lines.size () ; } /////////////////////////////////////////////////////
        ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        inline void operator () (FILE *f) { for (size_t i=0;i<lines.size();i++) {fprintf(f,"%s\n",&(lines[i][0]));} } //////////////
        ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        void debug_show () { for (size_t i=0;i<lines.size();i++) {printf("%ld => [%s]\n",i,&(lines[i][0]));} } /////////////////////
        ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    }; /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    class StringSplit { ////////////////////////////////////////////////////////////////////////////////////////////////////////////
        ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    private:
        ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    public:
        ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

        ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        // The Main Data Elements: /////////////////////////////////////////////////////////////////////////////////////////////////
        ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        std::string               line    ; ////////////////////////////////////////////////////////////////////////////////////////
        std::vector <std::string> words   ; ////////////////////////////////////////////////////////////////////////////////////////
        char                      delimit ; ////////////////////////////////////////////////////////////////////////////////////////
        ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

        ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        // Important functions: ////////////////////////////////////////////////////////////////////////////////////////////////////
        ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        StringSplit  ( std::string _line = "" , char _delimit = ' ' ) : line(_line) , delimit(_delimit) { //////////////////////////
            std::vector <char> buf ; buf.reserve(line.size()) ; ////////////////////////////////////////////////////////////////////
            for (size_t i=0;i<line.size();i++) { ///////////////////////////////////////////////////////////////////////////////////
                if (line[i]==delimit) { ////////////////////////////////////////////////////////////////////////////////////////////
                    buf.push_back((char)0); ////////////////////////////////////////////////////////////////////////////////////////
                    words.push_back(std::string(&(buf[0]))); ///////////////////////////////////////////////////////////////////////
                    buf.resize(0) ; ////////////////////////////////////////////////////////////////////////////////////////////////
                    buf.push_back(line[i]); ////////////////////////////////////////////////////////////////////////////////////////
                    buf.push_back((char)0); ////////////////////////////////////////////////////////////////////////////////////////
                    words.push_back(std::string(&(buf[0]))); ///////////////////////////////////////////////////////////////////////
                    buf.resize(0) ; ////////////////////////////////////////////////////////////////////////////////////////////////
                } //////////////////////////////////////////////////////////////////////////////////////////////////////////////////
                else { buf.push_back(line[i]); } ///////////////////////////////////////////////////////////////////////////////////
            } //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
            if (buf.size()>0) { ////////////////////////////////////////////////////////////////////////////////////////////////////
                buf.push_back((char)0); ////////////////////////////////////////////////////////////////////////////////////////////
                words.push_back(std::string(&(buf[0]))); ///////////////////////////////////////////////////////////////////////////
                buf.resize(0) ; ////////////////////////////////////////////////////////////////////////////////////////////////////
            } //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
            ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        } //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        ~StringSplit () {} /////////////////////////////////////////////////////////////////////////////////////////////////////////
        ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

        ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        // Some convinent functions: ///////////////////////////////////////////////////////////////////////////////////////////////
        ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        inline std::string & operator [] (size_t i) {return words[i]     ; } ///////////////////////////////////////////////////////
        inline size_t        size        ()         {return words.size() ; } ///////////////////////////////////////////////////////
        inline std::string & operator () (size_t i) {return words[i]     ; } ///////////////////////////////////////////////////////
        inline size_t        operator () ()         {return words.size() ; } ///////////////////////////////////////////////////////
        ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

        ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        // Print the string: ///////////////////////////////////////////////////////////////////////////////////////////////////////
        ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        void show (std::string & in_line) { ////////////////////////////////////////////////////////////////////////////////////////
            std::vector <char> outline ; ///////////////////////////////////////////////////////////////////////////////////////////
            for(size_t i=0;i<words.size();i++) for(size_t j=0;j<words[i].size();j++) if(words[i][j]!=(char)0) {outline.push_back(words[i][j]);}
            outline.push_back((char)0); ////////////////////////////////////////////////////////////////////////////////////////////
            in_line = std::string( &(outline[0]) ); ////////////////////////////////////////////////////////////////////////////////
        } //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        inline void operator () (std::string & in_line) {show(in_line);} ///////////////////////////////////////////////////////////
        ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        void debug_show () { for (size_t i=0;i<words.size();i++) {printf("(%ld:%s)",i,&(words[i][0]));} } //////////////////////////
        ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

        ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    } ; ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // The Main and most important class for simplifying file handeling: ///////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    class FileFD { /////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    private:
        std::string  filename  ;
        int          fd        ;
        struct stat  abtme     ;
        int          filemode  ;
        void        *mapped    ;
        size_t       maplength ;
        int          mmapprot  ;

    public:
        void construct ( std::string Afile = std::string("outfile") ) {
            filename  = Afile      ;
            fd        = -1         ;
            filemode  = -1         ;
            mapped    = MAP_FAILED ;
            mmapprot  = PROT_NONE  ;
            maplength = 0          ;
        }
        int closefile () {
            unmapfile()          ;
            filemode = -1        ;
            mmapprot = PROT_NONE ;
            if (fd<0) {return 0;}
            else {
                int ret = (int) close ( (int) fd ) ;
                fd = -1 ;
                return ret ;
            }
        }
        inline void check_file_mode (int newfilemode = -1) {
            if (filemode!=newfilemode) {closefile();}
            if (fd<0) {
                fd = (int) open ( (const char *) &(filename[0]) , newfilemode , (mode_t) 0755 ) ;
                filemode = newfilemode ;
            }
        }
        inline void readfile   () { check_file_mode ( (int) O_RDONLY                     ) ; mmapprot = ( (int) PROT_READ               ) ; }
        inline void writefile  () { check_file_mode ( (int) O_WRONLY | O_CREAT | O_TRUNC ) ; mmapprot = ( (int) PROT_WRITE              ) ; }
        inline void appendfile () { check_file_mode ( (int) O_RDWR   | O_CREAT           ) ; mmapprot = ( (int) PROT_READ  | PROT_WRITE ) ; }
        inline void destroy    () { closefile       (                                    ) ;                                                }

        FileFD  ( const char *Afile ) { construct ( Afile ) ; }
        FileFD  (                   ) { construct (       ) ; }
        FileFD  ( std::string Afile ) { construct ( Afile ) ; }
        ~FileFD (                   ) { destroy   (       ) ; }

        void reconstruct (std::string Afile = std::string("outfile")) { destroy() ; construct (Afile) ; }
        void reconstruct (char *Afile) { reconstruct (std::string(Afile)) ; }
        inline FileFD & operator () ( std::string name ) { reconstruct(name) ; return (*this); }

        inline int truncatefile ( off_t length = 0 ) { return (int) ftruncate ( (int) fd , (off_t) length ) ; }
        inline off_t seekfile ( off_t offset = 0 , int whence = SEEK_CUR ) { return (off_t) lseek ( (int) fd , (off_t) offset , (int) whence ) ; }
        inline ssize_t read2file ( void *buf = NULL , size_t count = 0 ) { return (ssize_t) read ( (int) fd , ( void *) buf , (size_t) count ) ; }
        inline ssize_t write2file ( const void *buf = NULL , size_t count = 0 ) { return (ssize_t) write ( (int) fd , (const void *) buf , (size_t) count ) ; }
        inline int info () { return (int) fstat ( (int) fd , (struct stat *) &abtme ) ; }
        inline off_t sizefile () { info() ; return (off_t) abtme.st_size ; }
        inline std::string getfilename () { return filename; }
        inline off_t operator () ( off_t offset = 0 ) { return seekfile ( offset ) ; }
        inline FileFD & operator [] ( off_t pos ) { seekfile ( (off_t) pos , SEEK_SET ) ; return (*this) ; }
        inline int getfd () { return fd ; }

        void * mapfile ( size_t length, off_t offset = 0 ) {
            if( (maplength==0) && (mmapprot!=PROT_NONE) && (mapped==MAP_FAILED) ) {
                off_t total_len = length + offset ;
                if (sizefile()<total_len) {truncatefile(total_len);}
                mapped = (void *) mmap ( (void *) NULL , (size_t) length, (int) mmapprot , (int) MAP_SHARED , (int) fd , (off_t) offset );
                if (mapped!=MAP_FAILED) {maplength=length;}
                else {printf("MMAP FAILED 1 !!! %s\n",&(filename[0]));}
            }
            else {printf("MMAP FAILED 2 !!!\n");}
            return mapped;
        }

        int unmapfile () {
            int ret = 0 ;
            if ( (mapped!=MAP_FAILED) && (maplength>0) && (mmapprot!=PROT_NONE) ) {
                ret = (int) munmap ( (void *) mapped , (size_t) maplength ) ;
                maplength = 0 ;
                mapped = MAP_FAILED ;
            }
            return ret;
        }

        inline size_t getmaplength () { return maplength ; }

        template <typename T> inline ssize_t multiread2file  ( T &buf , size_t count = 1 ) { return read2file  ( (      void *) &buf , (size_t) sizeof(T) * count ) ; }
        template <typename T> inline ssize_t multiwrite2file ( const T &buf , size_t count = 1 ) { return write2file ( (const void *) &buf , (size_t) sizeof(T) * count ) ; }

        template <typename T> inline ssize_t WriteVector ( std::vector <T> &out ) {
            size_t count = out.size() ;
            ssize_t writtensize = multiwrite2file (count) ;
            writtensize = writtensize + multiwrite2file (out[0],count) ;
            return writtensize;
        }

        template <typename T> inline ssize_t ReadVector ( std::vector <T> &out ) {
            size_t count = 0 ;
            size_t oldsize = out.size() ;
            ssize_t writtensize = multiread2file (count) ;
            out.resize ( oldsize + count ) ;
            writtensize = multiread2file ( out[oldsize], count ) ;
            return writtensize;
        }

        inline ssize_t WriteString ( std::string &out ) {
            size_t count       = out.size() ;
            ssize_t writtensize = multiwrite2file ( count ) ;
            writtensize = writtensize + multiwrite2file(out[0],count) ;
            return writtensize;
        }

        inline ssize_t operator >> ( char      & out ) { return multiread2file  ( out ) ; }
        inline ssize_t operator << ( char        out ) { return multiwrite2file ( out ) ; }
        inline ssize_t operator >> ( int       & out ) { return multiread2file  ( out ) ; }
        inline ssize_t operator << ( int         out ) { return multiwrite2file ( out ) ; }
        inline ssize_t operator >> ( float     & out ) { return multiread2file  ( out ) ; }
        inline ssize_t operator << ( float       out ) { return multiwrite2file ( out ) ; }
        inline ssize_t operator >> ( double    & out ) { return multiread2file  ( out ) ; }
        inline ssize_t operator << ( double      out ) { return multiwrite2file ( out ) ; }
        inline ssize_t operator >> ( long      & out ) { return multiread2file  ( out ) ; }
        inline ssize_t operator << ( long        out ) { return multiwrite2file ( out ) ; }
        inline ssize_t operator >> ( size_t    & out ) { return multiread2file  ( out ) ; }
        inline ssize_t operator << ( size_t      out ) { return multiwrite2file ( out ) ; }
        inline ssize_t operator << ( std::string out ) { return WriteString     ( out ) ; }

        template <typename T> inline ssize_t operator << ( std::vector <T> &out ) { return WriteVector(out); }
        template <typename T> inline ssize_t operator >> ( std::vector <T> &out ) { return ReadVector (out); }
    }; /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Simple function for TRUE random number generation: //////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    double unique () { /////////////////////////////////////////////////////////////////////////////////////////////////////////////
        struct timespec timeout ; //////////////////////////////////////////////////////////////////////////////////////////////////
        clock_gettime(CLOCK_REALTIME,&timeout); ////////////////////////////////////////////////////////////////////////////////////
        double ret = (double) ( timeout.tv_sec + ( (double) timeout.tv_nsec / 1000000000 ) ) ; /////////////////////////////////////
        FileFD urandom((char *)"/dev/urandom"); ////////////////////////////////////////////////////////////////////////////////////
        urandom.readfile(); ////////////////////////////////////////////////////////////////////////////////////////////////////////
        double rnd ; ///////////////////////////////////////////////////////////////////////////////////////////////////////////////
        urandom >> rnd ; ///////////////////////////////////////////////////////////////////////////////////////////////////////////
        ret = ret * rnd ; //////////////////////////////////////////////////////////////////////////////////////////////////////////
        return ret;  ///////////////////////////////////////////////////////////////////////////////////////////////////////////////
    } //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    template <typename T> void GetUnique (T & Var) { double ptr = unique() ; Var=*((T*)&ptr); } ////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Class for simplifying memory mapping and array handeling: ///////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    template <typename T> class FileArray { ////////////////////////////////////////////////////////////////////////////////////////
    private:
        T *mainptr  ;
        size_t sizes[4] ;
        std::string filename ;
        FileFD filefd ;
        size_t offset ;
        size_t begin, end, length ;
        size_t act_begin, act_end, act_length ;
    public:
        inline void construct ( std::string Afilename = std::string ("outfile") , size_t Aoffset = 0 ) {
            filename = Afilename ;
            filefd(filename).readfile() ;
            sizes[0] = 4096 ;
            sizes[1] = sizeof (T) ;
            sizes[2] = LCM (sizes[0],sizes[1]) ;
            sizes[3] = sizes[2] / sizes[1] ;
            offset = Aoffset ;
            begin = 0 ; act_begin = 0 ;
            end = 0 ; act_end = 0 ;
            length = 0 ; act_length = 0 ;
        }

        inline void destroy () { filefd.destroy () ; }
        inline void reconstruct ( std::string Afilename = std::string ("outfile") , size_t Aoffset = 0 ) { destroy(); construct(Afilename,Aoffset); }
        inline FileArray & operator () ( std::string Afilename = std::string ("outfile") , size_t Aoffset = 0 ) {
            reconstruct (Afilename,Aoffset) ;
            return (*this) ;
        }

        FileArray ( std::string Afilename = std::string ("outfile") , size_t Aoffset = 0 ) { construct(Afilename,Aoffset); }
        ~FileArray () {destroy();}

        inline void writeable ( bool arg = true ) {
            if(arg) {filefd(filename).appendfile();}
            else {filefd(filename).readfile();}
        }

        void map (size_t t_begin=0, size_t t_length=1) {
            size_t t_end = t_begin + t_length ;
            if ((t_begin<begin)||(t_end>end)) {
                /* Match to sector sizes: */ {
                    begin = myint ((double)t_begin/sizes[3]) ; begin = begin * sizes[3] ;
                    length = myint ((double)t_length/sizes[3]) ; length++ ; length = length * sizes[3] ;
                    end = begin + length ;
                }
                /* Reinitiate map: */ {
                    filefd.unmapfile () ;
                    mainptr = (T*) filefd.mapfile ( (length*sizes[1]) , (begin*sizes[1]) + (offset*sizes[0]) ) ;
                }
            }
        }

        inline T & operator () ( size_t A_begin=0 , size_t A_length=1 ) {
            map (A_begin,A_length) ;
            return mainptr [A_begin-begin] ;
        }

        inline off_t filesize () { return filefd.sizefile () ; }
        inline off_t size () { return filefd.sizefile () / sizes[1] ; }
        inline off_t size ( long num ) { filefd.unmapfile(); filefd.truncatefile(num*sizes[1]); return size(); }
    }; /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    template <typename T> class FullFileReader {
    private:
        FileArray <T> MainReader ;
        size_t limit ;
        T * ptr ;
    public:
        inline T const & operator () (size_t i) const { return ptr[i] ; }
        inline T       & operator () (size_t i)       { return ptr[i] ; }
        inline size_t    operator () ()         const { return limit  ; }
        FullFileReader (std::string filename) : MainReader(filename)
        { limit = MainReader.size() ; ptr = & (MainReader(0,limit)) ; }
    } ;
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    template <typename T> class FileVector { ///////////////////////////////////////////////////////////////////////////////////////
        ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    private:
        ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        FileArray <T> infile ; /////////////////////////////////////////////////////////////////////////////////////////////////////
        size_t count ; /////////////////////////////////////////////////////////////////////////////////////////////////////////////
        ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    public:
        ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        FileVector(std::string name): infile(name){ ////////////////////////////////////////////////////////////////////////////////
            infile.writeable(); ////////////////////////////////////////////////////////////////////////////////////////////////////
            count=0; ///////////////////////////////////////////////////////////////////////////////////////////////////////////////
            infile.size(count); ////////////////////////////////////////////////////////////////////////////////////////////////////
        } //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        ~FileVector(){infile.size(count);} /////////////////////////////////////////////////////////////////////////////////////////
        ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        inline size_t size() {return count ;} ////////////////////////////////////////////////////////////////////////////////
        inline void resize(size_t _size) {count=_size;} //////////////////////////////////////////////////////////////////////
        inline void push_back (T indata) { /////////////////////////////////////////////////////////////////////////////////////////
            infile(count) = indata ; ///////////////////////////////////////////////////////////////////////////////////////////////
            count++ ; //////////////////////////////////////////////////////////////////////////////////////////////////////////////
        } //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        inline T & operator [] (size_t i) {return infile(i);} //////////////////////////////////////////////////////////////////////
    }; /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    ///////////////////////////////////////////////////////////////////
    ///////////////////////////////////////////////////////////////////
    ///////////////////////////////////////////////////////////////////
    template < typename T > class latexshow { /////////////////////////
        ///////////////////////////////////////////////////////////////
    private:
        ///////////////////////////////////////////////////////////////
        long power; ///////////////////////////////////////////////////
        T num; ////////////////////////////////////////////////////////
        T input; //////////////////////////////////////////////////////
        ///////////////////////////////////////////////////////////////
        inline void reduce () { ///////////////////////////////////////
            ///////////////////////////////////////////////////////////
            while ((-1<num) && (num<1) && (num!=0)) { /////////////////
                num = num * 10.0; /////////////////////////////////////
                power--; //////////////////////////////////////////////
            } /////////////////////////////////////////////////////////
            while ((num > 10) || (-10 > num)) { ///////////////////////
                num = num / 10.0; /////////////////////////////////////
                power++; //////////////////////////////////////////////
            } /////////////////////////////////////////////////////////
        } /////////////////////////////////////////////////////////////
        ///////////////////////////////////////////////////////////////
        inline char * show (char * b) { ///////////////////////////////
            ///////////////////////////////////////////////////////////
            if ( mymod(power) > limit ) { /////////////////////////////
                sprintf (b, "{$%.3lf \\times 10^{%ld}$}", num, power);
            } else { //////////////////////////////////////////////////
                sprintf (b, "{$%.3lf$}", input); //////////////////////
            } /////////////////////////////////////////////////////////
            return b ; ////////////////////////////////////////////////
        } /////////////////////////////////////////////////////////////
        ///////////////////////////////////////////////////////////////
    public:
        ///////////////////////////////////////////////////////////////
        size_t limit; /////////////////////////////////////////////////
        ///////////////////////////////////////////////////////////////
        latexshow (T a) { /////////////////////////////////////////////
            ///////////////////////////////////////////////////////////
            input = a; ////////////////////////////////////////////////
            num = a; //////////////////////////////////////////////////
            power = 0; ////////////////////////////////////////////////
            limit = 2; ////////////////////////////////////////////////
            reduce (); ////////////////////////////////////////////////
        } /////////////////////////////////////////////////////////////
        ///////////////////////////////////////////////////////////////
        ~latexshow () { ///////////////////////////////////////////////
        } /////////////////////////////////////////////////////////////
        ///////////////////////////////////////////////////////////////
        inline char * operator  () (char * b) { ///////////////////////
            return show (b); //////////////////////////////////////////
        } /////////////////////////////////////////////////////////////
        ///////////////////////////////////////////////////////////////

    }; ////////////////////////////////////////////////////////////////
    ///////////////////////////////////////////////////////////////////

    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Class to Easily generate fancy looking tables: //////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    template <typename T> class flowtable { ////////////////////////////////////////////////////////////////////////////////////////
        ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    private:
        ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        size_t current ; ///////////////////////////////////////////////////////////////////////////////////////////////////////////
        ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        std::vector <T>           L     ; //////////////////////////////////////////////////////////////////////////////////////////
        std::vector <std::string> names ; //////////////////////////////////////////////////////////////////////////////////////////
        ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        void safefill ( size_t CLimit ) { //////////////////////////////////////////////////////////////////////////////////////////
            while ( L.size     () <= CLimit    ) { L.push_back     (0)                      ; } /////////////////////////////////////
            while ( names.size () <  L.size () ) { names.push_back (std::string("nothing")) ; } /////////////////////////////////////
        } //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        inline void safefill ()    { safefill (current) ; } ////////////////////////////////////////////////////////////////////////
        inline void namefill ()    { if (L.size()>0) { safefill (L.size()-1) ; } } /////////////////////////////////////////////////
        ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        inline void copyfrom ( const flowtable <T> & other ) { /////////////////////////////////////////////////////////////////////
            safefill (other.L.size()) ; ////////////////////////////////////////////////////////////////////////////////////////////
            memcpy ( (void*) &(L[0]) , (const void*) &(other.L[0]) , (size_t) sizeof(T) * L.size() ) ; /////////////////////////////
            current = other.current ; //////////////////////////////////////////////////////////////////////////////////////////////
        } //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        inline void startover () { current = 0 ; } /////////////////////////////////////////////////////////////////////////////////
        ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        inline void fill ( T val = 1 , std::string name = "noothing" ) { ///////////////////////////////////////////////////////////
            safefill () ; //////////////////////////////////////////////////////////////////////////////////////////////////////////
            L[current]     = L[current] + val ; ////////////////////////////////////////////////////////////////////////////////////
            names[current] = name             ; ////////////////////////////////////////////////////////////////////////////////////
            current++                         ; ////////////////////////////////////////////////////////////////////////////////////
        } //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        inline void fill ( bool val , std::string name = "nothing" ) { /////////////////////////////////////////////////////////////
            if (val) {fill(1,name);} ///////////////////////////////////////////////////////////////////////////////////////////////
            else     {fill(0,name);} ///////////////////////////////////////////////////////////////////////////////////////////////
        } //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        char * showhorizontal (std::string & linetitle) { //////////////////////////////////////////////////////////////////////////
            std::vector <std::string> parts ; /**/ { ///////////////////////////////////////////////////////////////////////////////
                std::string tmp = "\\hline " + linetitle + " &" ; //////////////////////////////////////////////////////////////////
                parts.push_back (tmp) ; ////////////////////////////////////////////////////////////////////////////////////////////
            } //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
            for(size_t i=0;i<L.size();i++){ ////////////////////////////////////////////////////////////////////////////////////////
                latexshow <T> tmplatex (L[i]) ; ////////////////////////////////////////////////////////////////////////////////////
                char tmpbuf [512] ; ////////////////////////////////////////////////////////////////////////////////////////////////
                tmplatex (tmpbuf) ; ////////////////////////////////////////////////////////////////////////////////////////////////
                if (i<L.size()-1) {parts.push_back(std::string(tmpbuf)+" &");} /////////////////////////////////////////////////////
                else {parts.push_back(std::string(tmpbuf)+" \\\\");} ///////////////////////////////////////////////////////////////
            } //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
            linetitle = parts[0] ; /////////////////////////////////////////////////////////////////////////////////////////////////
            for(size_t i=1;i<parts.size();i++){ ////////////////////////////////////////////////////////////////////////////////////
                linetitle = linetitle + parts[i] ; /////////////////////////////////////////////////////////////////////////////////
            } //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
            return &(linetitle[0]) ; ///////////////////////////////////////////////////////////////////////////////////////////////
        } //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        void showvals (std::vector <std::string> & outvals) { //////////////////////////////////////////////////////////////////////
            for(size_t i=0;i<L.size();i++) { ///////////////////////////////////////////////////////////////////////////////////////
                latexshow <double> tmpshow (L[i]) ; ////////////////////////////////////////////////////////////////////////////////
                char tmp[128] ; tmpshow(tmp) ; /////////////////////////////////////////////////////////////////////////////////////
                outvals.push_back(std::string(tmp)); ///////////////////////////////////////////////////////////////////////////////
            } //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        } //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    public:
        ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        inline void operator () () {startover();} //////////////////////////////////////////////////////////////////////////////////
        inline void operator () ( T    val , std::string name = "nothing" , bool inflag = true ) { /////////////////////////////////
            if   (inflag) { fill ( val  , name ) ; } ///////////////////////////////////////////////////////////////////////////////
            else          { fill ( (T)0 , name ) ; } ///////////////////////////////////////////////////////////////////////////////
        } //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        inline void operator () ( bool val , std::string name = "nothing" ) {fill(val,name);} //////////////////////////////////////
        inline char * operator () (std::string & linetitle) {return showhorizontal(linetitle);} ////////////////////////////////////
        inline size_t size() {return L.size();} ////////////////////////////////////////////////////////////////////////////////////
        inline T & operator [] (size_t i) {return L[i];} ///////////////////////////////////////////////////////////////////////////
        inline std::vector <std::string> & operator () (std::vector <std::string> & outvals) { /////////////////////////////////////
            showvals(outvals); /////////////////////////////////////////////////////////////////////////////////////////////////////
            return outvals; ////////////////////////////////////////////////////////////////////////////////////////////////////////
        } //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        inline size_t operator >> (CPPFileIO::FileFD & outfile) {outfile<<L;} //////////////////////////////////////////////////////
        inline size_t operator << (CPPFileIO::FileFD & outfile) {outfile>>L;} //////////////////////////////////////////////////////
        inline void operator = (const flowtable <T> & other) {copyfrom(other);} ////////////////////////////////////////////////////
        ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        void filewrite (std::string filename) { ////////////////////////////////////////////////////////////////////////////////////
            FILE *f = fopen (&(filename[0]),"w") ; /////////////////////////////////////////////////////////////////////////////////
            namefill(); ////////////////////////////////////////////////////////////////////////////////////////////////////////////
            size_t min_v = L.size(); ///////////////////////////////////////////////////////////////////////////////////////////////
            for (size_t i=0;i<min_v;i++) {fprintf(f," L [%ld] = %e \t : \t %s \n",i,(double)L[i],&(names[i][0]));} /////////////////
            fclose(f); /////////////////////////////////////////////////////////////////////////////////////////////////////////////
        } //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        flowtable() { //////////////////////////////////////////////////////////////////////////////////////////////////////////////
            L.clear(); /////////////////////////////////////////////////////////////////////////////////////////////////////////////
            current=0; /////////////////////////////////////////////////////////////////////////////////////////////////////////////
        } //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        flowtable (const flowtable & other) { //////////////////////////////////////////////////////////////////////////////////////
            copyfrom(other); ///////////////////////////////////////////////////////////////////////////////////////////////////////
            current=0; /////////////////////////////////////////////////////////////////////////////////////////////////////////////
        } //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        ~flowtable(){} /////////////////////////////////////////////////////////////////////////////////////////////////////////////
        ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    }; /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Printing the Tables: ////////////////////////////////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    class flowtables { /////////////////////////////////////////////////////////////////////////////////////////////////////////////
    private:
        FILE *f ;
    public:
        void operator () (std::string infile) {
            FileLines reader(infile);
            fprintf(f,"{|");
            for (size_t i=0;i<reader.size();i++) {fprintf(f,"c|");}
            fprintf(f,"}\n");
            for (size_t i=0;i<reader();i++) {
                if(i==0) {fprintf(f,"\\hline ");}
                else {fprintf(f,"& ");}
                fprintf(f,"%s",&(reader(i)[0]));
            }
            fprintf(f," \\\\ \n");
        }
        template <typename T> void operator () (flowtable <T> & intable, std::string eventtype) {
            fprintf(f,"%s\n",intable(eventtype));
        }
        flowtables  (FILE * _f) {f=_f;fprintf(f,"\\begin{tabular}");}
        ~flowtables ()          {fprintf(f,"\\hline \\end{tabular}\n");} ///////////////////////////////////////////////////////////
    }; /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    class LatexPrintMatrix {
    private:
        std::vector <std::string> elements ;
        size_t X, Y ;
        inline std::string & GetElement ( size_t x , size_t y ) {
            if(x>=X) {printf("BUG!!! out of bounds in x !!!\n");}
            if(y>=Y) {printf("BUG!!! out of bounds in y !!!\n");}
            return elements [x+(X*y)] ;
        }
        void Write2FILE ( FILE * f ) {
            fprintf(f,"\\begin{tabular}");
            for(size_t x=0;x<X;x++) {
                if(x==0){fprintf(f,"{|");}
                fprintf(f,"c|");
                if(x==(X-1)){fprintf(f,"}\n");}
            }
            for (size_t y=0;y<Y;y++) {
                for (size_t x=0;x<X;x++) {
                    if(x==0) {fprintf(f," \\hline %s ",&(GetElement(x,y)[0]));}
                    else     {fprintf(f," & %s ",&(GetElement(x,y)[0]));}
                }
                fprintf(f," \\\\ \n");
            }
            fprintf(f,"\\hline \\end{tabular}\n");
        }
        inline void Write2FILE ( std::string filename ) {
            FILE *f = fopen(&(filename[0]),"w");
            Write2FILE(f);
            fclose(f);
        }
    public:
        inline void operator () (std::vector <std::string> & x, size_t y) {
            size_t limit = mymin (x.size(),X) ;
            for(size_t i=0;i<limit;i++) {GetElement(i,y)=x[i];}
        }
        inline void operator () (size_t x, std::vector <std::string> & y) {
            size_t limit = mymin (y.size(),Y) ;
            for(size_t i=0;i<limit;i++) {GetElement(x,i)=y[i];}
        }
        inline void operator () (FileLines & x, size_t y) {
            size_t limit = mymin(x(),X);
            for(size_t i=0;i<limit;i++) {GetElement(i,y)=x(i);}
        }
        inline void operator () (size_t x, FileLines & y) {
            size_t limit = mymin(y(),Y);
            for(size_t i=0;i<limit;i++) {GetElement(x,i)=y(i);}
        }
        inline void operator () (FILE *f)              {Write2FILE(f);}
        inline void operator () (std::string filename) {Write2FILE(filename);}
        LatexPrintMatrix (size_t _X, size_t _Y) {
            X=_X;Y=_Y;
            elements.resize(X*Y);
        }
        ~LatexPrintMatrix(){}
    };


    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Convinent multi threadable class for uniform double random number generation: ///////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    template <typename T> class myrandgen { ////////////////////////////////////////////////////////////////////////////////////////
        ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    private:
        ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        std::vector <T*> engines ; /////////////////////////////////////////////////////////////////////////////////////////////////
        std::uniform_real_distribution <double> dist ; /////////////////////////////////////////////////////////////////////////////
        ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        inline void allocate () { //////////////////////////////////////////////////////////////////////////////////////////////////
            std::random_device random_seeds ; //////////////////////////////////////////////////////////////////////////////////////
            for(size_t i=0;i<engines.size();i++) {engines[i]=new T(random_seeds());} ///////////////////////////////////////////////
        } //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    public:
        ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        double low, high ; /////////////////////////////////////////////////////////////////////////////////////////////////////////
        ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        myrandgen(size_t threads, double _low=0, double _high=1) : low(_low) , high(_high) , dist(_low,_high) { ////////////////////
            engines.resize(threads) ; //////////////////////////////////////////////////////////////////////////////////////////////
            allocate() ; ///////////////////////////////////////////////////////////////////////////////////////////////////////////
        } //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        ~myrandgen(){ //////////////////////////////////////////////////////////////////////////////////////////////////////////////
            for(size_t i=0;i<engines.size();i++) {delete engines[i];} //////////////////////////////////////////////////////////////
        } //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        inline double operator [] (size_t th) { ////////////////////////////////////////////////////////////////////////////////////
            double ret = dist(engines[th][0]) ; ////////////////////////////////////////////////////////////////////////////////////
            return ret ; ///////////////////////////////////////////////////////////////////////////////////////////////////////////
        } //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    } ; ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    class ToDir {
    private:
        std::string originaldir ;
        inline void godir (std::string dirname) {
            mkdir((const char*)&(dirname[0]),(mode_t)0755);
            chdir((const char*)&(dirname[0]));
        }
        bool goback ;
    public:
        inline void operator () (std::string dirname) {godir(dirname);}
        inline void operator () (const char *dirname) {godir(std::string(dirname));}
        inline void operator () (long innum) {
            char tmp[128] ;
            sprintf(tmp,"%ld",innum);
            godir(std::string(tmp));
        }
        inline void operator () () {godir(originaldir);}
        inline void showdir() {
            char tmp[1024] ;
            getcwd((char*)tmp,(size_t)1024);
            printf("%s\n",tmp);
        }
        inline std::string getoriginal () {return originaldir;}
        ToDir(bool _goback=false){
            goback = _goback ;
            char tmp[1024] ;
            getcwd((char*)tmp,(size_t)1024);
            originaldir = std::string(tmp);
            std::cout << originaldir << "\n" ;
        }
        ~ToDir(){if(goback){godir(originaldir);}}
    };

    template <typename T> class MemContainer {
    public:
        T * const PTR ;
        T &       REF ;
        MemContainer ( T * const _PTR ) : PTR(_PTR) , REF(PTR[0]) {}
        ~MemContainer () { delete PTR ; }
        inline T & operator () (size_t i) { return PTR [i] ; }
    } ;
    template <typename T> inline MemContainer <T> GET_MemContainer ( T * a ) {
        MemContainer <T> ret (a) ;
        return ret ;
    }


} //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#ifdef USENN

#ifdef USECBLAS
#include "cblas.h"
#endif

#ifdef USEPCG
#include "pcg.hh"
#endif

namespace Tensors {

    class Nothing {
    public:
        Nothing(){}
        ~Nothing(){}
    } ;

    namespace Arrays {
        template <size_t X, typename T=double> class NDArray {
        public:
            typedef T TYPE_Data ;
            inline static constexpr size_t Size() {return X;}
            typedef NDArray <Size(),TYPE_Data> TYPE_Self ;
            NDArray(){}
            ~NDArray(){}
        private:
            T DATA[X] ;
        private:
            inline void      Add ( const TYPE_Self & other ) { for (size_t x=0;x<X;x++) { DATA[x] += other[x] ; } }
            inline void      Sub ( const TYPE_Self & other ) { for (size_t x=0;x<X;x++) { DATA[x] -= other[x] ; } }
            inline void      Mul ( const TYPE_Self & other ) { for (size_t x=0;x<X;x++) { DATA[x] *= other[x] ; } }
            inline void      Div ( const TYPE_Self & other ) { for (size_t x=0;x<X;x++) { DATA[x] /= other[x] ; } }
            inline void      Eqt ( const TYPE_Self & other ) { for (size_t x=0;x<X;x++) { DATA[x]  = other[x] ; } }
            inline void      Add ( const TYPE_Data & other ) { for (size_t x=0;x<X;x++) { DATA[x] += other    ; } }
            inline void      Sub ( const TYPE_Data & other ) { for (size_t x=0;x<X;x++) { DATA[x] -= other    ; } }
            inline void      Mul ( const TYPE_Data & other ) { for (size_t x=0;x<X;x++) { DATA[x] *= other    ; } }
            inline void      Div ( const TYPE_Data & other ) { for (size_t x=0;x<X;x++) { DATA[x] /= other    ; } }
            inline void      Eqt ( const TYPE_Data & other ) { for (size_t x=0;x<X;x++) { DATA[x]  = other    ; } }
            inline TYPE_Data Dot ( const TYPE_Self & other ) const
            { double ret = 0 ; for (size_t i=0;i<X;i++) {ret+=DATA[i]*other[i];} return ret ; }

            inline void * CopyFrom (const void * other)
            { return (void *) memcpy ( (void*)/*dest=*/DATA , (const void*)/*src=*/other , (size_t)/*n=*/sizeof(TYPE_Self) ) ; }
            inline void * CopyFrom ( const TYPE_Data * other ) { return CopyFrom ( (const void*)/*other=*/other ) ; }
            inline void * CopyFrom ( const TYPE_Self   other ) { return CopyFrom ( (const TYPE_Data*)/*other=*/other.DATA ) ; }
        public:
            inline void      operator += ( const TYPE_Self & other ) { Add (other) ; }
            inline void      operator -= ( const TYPE_Self & other ) { Sub (other) ; }
            inline void      operator *= ( const TYPE_Self & other ) { Mul (other) ; }
            inline void      operator /= ( const TYPE_Self & other ) { Div (other) ; }
            inline void      operator  = ( const TYPE_Self & other ) { Eqt (other) ; }
            inline void      operator += ( const TYPE_Data & other ) { Add (other) ; }
            inline void      operator -= ( const TYPE_Data & other ) { Sub (other) ; }
            inline void      operator *= ( const TYPE_Data & other ) { Mul (other) ; }
            inline void      operator /= ( const TYPE_Data & other ) { Div (other) ; }
            inline void      operator  = ( const TYPE_Data & other ) { Eqt (other) ; }
            inline TYPE_Data operator  * ( const TYPE_Self & other ) const { return Dot (other) ; }
            inline TYPE_Data &       operator [] (size_t x)       { return DATA[x] ; }
            inline TYPE_Data const   operator [] (size_t x) const { return DATA[x] ; }
            inline TYPE_Data       * operator () ()               { return DATA    ; }
            inline TYPE_Data const * operator () ()         const { return DATA    ; }
            inline void * GET_DATA ()       { return (void*) DATA ; }
            inline void * GET_DATA () const { return (void*) DATA ; }
            inline void GET_SQUARED (TYPE_Data const * SRC) {
                TYPE_Data * DST = (TYPE_Data *) this->GET_DATA () ;
                for(size_t i=0;i<Size();i++){DST[i]=SRC[i]*SRC[i];}
            }
            inline TYPE_Data L1Norm ()
            { TYPE_Data Ret = 0 ; for(size_t i=0;i<Size();i++){Ret+=CPPFileIO::mymod(DATA[i]);} return Ret ; }
            inline TYPE_Data L2Norm ()
            { TYPE_Data Ret = 0 ; for(size_t i=0;i<Size();i++){Ret+=(DATA[i]*DATA[i]);} return Ret ; }
            inline void GET_SQUARED (TYPE_Self const & SRC) {GET_SQUARED((TYPE_Data*)SRC.GET_DATA());}
        } ;
        template <size_t Y, size_t X, typename T> class N2DArray : public NDArray <Y,NDArray<X,T>> {
        public:
            N2DArray(){}
            ~N2DArray(){}
            typedef T TYPE_Data   ;
            inline static constexpr size_t SizeX () {return X;}
            inline static constexpr size_t SizeY () {return Y;}
            inline static constexpr size_t Size  () {return SizeX()*SizeY();}
            typedef N2DArray <SizeY(),SizeX(),TYPE_Data> TYPE_Self ;
            typedef NDArray <SizeY(),NDArray<SizeX(),T>> TYPE_Parent ;
            inline void GET_SQUARED (TYPE_Data const * SRC) {
                TYPE_Data * DST = (TYPE_Data *) this->GET_DATA () ;
                for(size_t i=0;i<Size();i++){DST[i]=SRC[i]*SRC[i];}
            }
            inline void GET_SQUARED (TYPE_Self const & SRC) {GET_SQUARED((TYPE_Data*)SRC.GET_DATA());}
            inline void operator = (TYPE_Data const & a) {
                constexpr size_t limit = Size() ;
                TYPE_Data * ptr = (TYPE_Data*) this->GET_DATA();
                for(size_t i=0;i<limit;i++){ptr[i]=a;}
            }
            inline TYPE_Data L1Norm () {
                TYPE_Data Ret = 0 ;
                for (size_t y=0;y<SizeY();y++)
                { for (size_t x=0;x<SizeX();x++) { Ret += CPPFileIO::mymod(this[0][y][x]) ; } }
                return Ret ;
            }
            inline TYPE_Data L2Norm () {
                TYPE_Data Ret = 0 ;
                for (size_t y=0;y<SizeY();y++)
                { for (size_t x=0;x<SizeX();x++) { Ret += (this[0][y][x]*this[0][y][x]) ; } }
                return Ret ;
            }
        } ;
        // Function to nicely print the matrix:
        template <size_t Y, size_t X, typename T>
        inline void ShowMatrix (
            N2DArray <Y,X,T> const & in
        ) {
            for (size_t y=0;y<Y;y++) {
                for (size_t x=0;x<X;x++) {
                    printf("%e ",in[y][x]);
                }
                printf("\n");
            }
        }
        template <typename T> class Batcher {
        public:
            typedef T TYPE_OutArray ;
            inline static constexpr size_t BatchSize() {return TYPE_OutArray::SizeX();}
            typedef typename TYPE_OutArray::TYPE_Data TYPE_Data ;
            typedef NDArray <TYPE_OutArray::SizeY(),TYPE_Data> TYPE_InArray ;
        private:
            size_t count ;
            TYPE_OutArray buffer ; CPPFileIO::FileVector <TYPE_OutArray> Writer ;
            inline void Check () { if (count==BatchSize()) {Writer.push_back(buffer);count=0;} }
            inline void push_back ( TYPE_InArray const & indata ) {
                Check () ;
                for (size_t i=0;i<TYPE_InArray::Size();i++) {buffer[i][count]=indata[i];}
                count++ ;
            }
            inline void push_back (std::string filename) {
                CPPFileIO::FullFileReader <TYPE_InArray> Reader (filename) ;
                for (size_t i=0;i<Reader();i++) { push_back ( Reader (i) ) ; }
            }
            inline void push_back ( std::vector <std::string> & names )
            { for(size_t i=0;i<names.size();i++){push_back(names[i]);} }
        public:
            inline void operator () (TYPE_InArray & indata) {push_back(indata);}
            inline void operator () (std::string filename) {push_back(filename);}
            inline void operator () (std::vector <std::string> & names) {push_back(names);}
            inline void operator = (TYPE_InArray & indata) {push_back(indata);}
            inline void operator = (std::string filename) {push_back(filename);}
            inline void operator = (std::vector <std::string> & names) {push_back(names);}
        public:
            Batcher ( std::string outfilename ) : Writer (outfilename) {count=0;}
            ~Batcher () {}
        } ;
    }

    namespace NeuralNetwork {

        namespace ParameterRelated {
            using namespace Arrays ;

            template <size_t Y, size_t X, typename T> class Parameter {
            public:
                typedef T TYPE_Data   ;
                inline static constexpr size_t SizeX () {return X;}
                inline static constexpr size_t SizeY () {return Y;}
                inline static constexpr size_t Size  () {return SizeX()*SizeY();}
                typedef Parameter <SizeY(),SizeX(),TYPE_Data> TYPE_Self ;
                typedef N2DArray <SizeY(),SizeX(),TYPE_Data> TYPE_Weight ;
                typedef NDArray <SizeY(),TYPE_Data> TYPE_Bias ;
                inline TYPE_Data &     operator () (size_t y, size_t x)        {return WEIGHT[y][x];}
                inline TYPE_Data const operator () (size_t y, size_t x) const  {return WEIGHT[y][x];}
                inline TYPE_Data &     operator () (size_t y)        {return BIAS[y];}
                inline TYPE_Data const operator () (size_t y) const  {return BIAS[y];}
                inline void RANDOMIZE () {
                    #ifdef PCG_RAND_HPP_INCLUDED
                    CPPFileIO::myrandgen <pcg64_fast> myrandgen(1,-0.5,0.5);
                    #else
                    CPPFileIO::myrandgen <std::mt19937> myrandgen(1,-0.5,0.5);
                    #endif

                    for(size_t y=0;y<Y;y++){for(size_t x=0;x<X;x++){WEIGHT[y][x]=myrandgen[0];}}
                    for(size_t y=0;y<Y;y++){WEIGHT[y]=myrandgen[0];}
                }
                inline void RELEASE_LOCK () {pthread_mutex_unlock(&lock);}
                inline void ACQUIRE_LOCK () {pthread_mutex_lock(&lock);}
                inline void operator = (TYPE_Data const & a) { WEIGHT = a ; BIAS = a ; }
            private:
                inline ssize_t WriteToFile (CPPFileIO::FileFD & file) const {
                    ssize_t ret = 0 ;
                    ret+=file.multiwrite2file(WEIGHT);
                    ret+=file.multiwrite2file(BIAS);
                    return ret;
                }
                inline ssize_t WriteToFile (std::string filename) const {
                    CPPFileIO::FileFD Writer (filename) ;
                    Writer.writefile();
                    return WriteToFile(Writer);
                }
                inline ssize_t ReadFromFile (CPPFileIO::FileFD & file) {
                    ssize_t ret = 0 ;
                    ret+=file.multiread2file(WEIGHT);
                    ret+=file.multiread2file(BIAS);
                    return ret;
                }
                inline ssize_t ReadFromFile (std::string filename) {
                    CPPFileIO::FileFD Reader (filename) ;
                    Reader.readfile();
                    return ReadFromFile(Reader);
                }
            public:
                inline ssize_t operator >> ( CPPFileIO::FileFD & file ) const { return WriteToFile  (file) ; }
                inline ssize_t operator << ( CPPFileIO::FileFD & file ) { return ReadFromFile (file) ; }
                inline ssize_t operator >> ( std::string filename ) const { return WriteToFile (filename) ; }
                inline ssize_t operator << ( std::string filename ) { return ReadFromFile (filename) ; }
                TYPE_Weight     WEIGHT ;
                TYPE_Bias       BIAS   ;
                pthread_mutex_t lock   ;
            } ;

            template <typename T> class ParameterAdam : public T {
            public:
                ParameterAdam  () {Beta[0]=GET_BETA1();Beta[1]=GET_BETA2();M=0;V=0;}
                ~ParameterAdam () {}
                typedef T TYPE_Parent ;
                typedef ParameterAdam <T> TYPE_Self ;
                typedef typename TYPE_Parent::TYPE_Data TYPE_Data ;
                inline static constexpr TYPE_Data GET_BETA1 () {return 0.90   ; }
                inline static constexpr TYPE_Data GET_BETA2 () {return 0.99   ; }
                inline static constexpr TYPE_Data Eps       () {return 0.0001 ; }
            private:
                template <typename InType> inline void AddParameter (
                    InType & DST, InType const & SRC, TYPE_Data const beta
                ) {
                    TYPE_Data * dst = (TYPE_Data *) DST.GET_DATA();
                    TYPE_Data * src = (TYPE_Data *) SRC.GET_DATA();
                    constexpr size_t limit = InType::Size();
                    for(size_t i=0;i<limit;i++){dst[i]=(beta*dst[i])+((1.0-beta)*src[i]);}
                }
                inline void AddBoth (TYPE_Parent & DST, TYPE_Parent const & SRC, TYPE_Data const beta) {
                    AddParameter ( DST.WEIGHT , SRC.WEIGHT , beta ) ;
                    AddParameter ( DST.BIAS   , SRC.BIAS   , beta ) ;
                }
                template <typename InType>
                inline void Apply (
                    InType & DST, InType const & SRCM, InType const & SRCV , TYPE_Data const Eta
                ) {
                    TYPE_Data * dst  = (TYPE_Data *) DST.GET_DATA  () ;
                    TYPE_Data * srcm = (TYPE_Data *) SRCM.GET_DATA () ;
                    TYPE_Data * srcv = (TYPE_Data *) SRCV.GET_DATA () ;
                    constexpr size_t limit = InType::Size();
                    for (size_t i=0;i<limit;i++)
                    { dst[i] = dst[i] - ( Eta * srcm[i] / ( Eps() + sqrt(srcv[i]) ) ) ; }
                }
                inline void ApplyBoth (
                    TYPE_Parent & DST, TYPE_Parent const & SRCM, TYPE_Parent const & SRCV, TYPE_Data const Eta
                ) {
                    Apply ( DST.WEIGHT , SRCM.WEIGHT , SRCV.WEIGHT , Eta ) ;
                    Apply ( DST.BIAS   , SRCM.BIAS   , SRCV.BIAS   , Eta ) ;
                }
            public:
                inline void UPDATE (TYPE_Parent const&_M,TYPE_Parent const&_V, TYPE_Data const Eta) {
                    this->ACQUIRE_LOCK();
                    AddBoth(M,_M,Beta[0]);
                    AddBoth(V,_V,Beta[1]);
                    ApplyBoth(this[0],M,V,Eta);
                    this->RELEASE_LOCK();
                }
            private:
                TYPE_Data Beta[2];
                TYPE_Parent M, V;
            };
        }

        namespace NeuralLayers {

            namespace InputRelated {
                using namespace Arrays;
                template <typename T> class FirstLayer {
                public:
                    typedef T TYPE_FirstInput ;
                    typedef typename TYPE_FirstInput::TYPE_Data TYPE_Data ;
                    typedef TYPE_FirstInput TYPE_Input ;
                    typedef TYPE_Input TYPE_Output ;
                    typedef Nothing TYPE_Parameter ;
                    typedef FirstLayer <TYPE_FirstInput> TYPE_Self ;
                    inline static constexpr size_t SizeX () {return TYPE_FirstInput::SizeX ();}
                    inline static constexpr size_t SizeY () {return TYPE_FirstInput::SizeY ();}
                    inline static constexpr size_t Size  () {return TYPE_FirstInput::Size  ();}
                    inline static constexpr size_t Index () {return 0;}
                    template <typename RefType> inline void GET_LAYER_REFERENCE (RefType*&ref) {ref=(RefType*)this;}
                    inline void SET_FIRST_INPUT (TYPE_FirstInput * _INPUT) {INPUT=_INPUT;}
                    inline TYPE_Output *       GET_OUTPUT ()       {return INPUT;}
                    inline TYPE_Output const * GET_OUTPUT () const {return INPUT;}
                    inline void ACTIVATE () const {}
                    inline void ATTACH (TYPE_Parameter const * _PARS) const {}
                    inline void ATTACH (TYPE_Parameter const & _PARS) const {}
                    template <typename Tin> inline void BACKPROP (Tin const & in) const {}
                    inline void UPDATE (TYPE_Data const Eta=0.01) const {}
                    TYPE_FirstInput * INPUT ;
                } ;
            }

            namespace Activators /* Declaring used namespaces:    */ {
                using namespace Arrays ;
            }
            namespace Activators /* Defining Soft LRU Activation: */ {
                template <typename T_Input> class ActivatorSoftLRU : public N2DArray <T_Input::SizeY(),T_Input::SizeX(),typename T_Input::TYPE_Data> {
                public:
                    typedef T_Input TYPE_Input ;
                    typedef typename TYPE_Input::TYPE_FirstInput TYPE_FirstInput ;
                    typedef typename TYPE_Input::TYPE_Data TYPE_Data ;
                    typedef ActivatorSoftLRU <TYPE_Input> TYPE_Self ;
                    typedef Nothing TYPE_Parameter ;
                    typedef N2DArray <TYPE_Input::SizeY(),TYPE_Input::SizeX(),TYPE_Data> TYPE_Parent ;
                    typedef TYPE_Parent TYPE_Output ;
                    inline static constexpr size_t SizeX () { return TYPE_Parent::SizeX() ; }
                    inline static constexpr size_t SizeY () { return TYPE_Parent::SizeY() ; }
                    inline static constexpr size_t Size  () { return SizeX() * SizeY()       ; }
                    inline static constexpr size_t Index () { return TYPE_Input::Index() + 1 ; }
                    template <typename RefType> inline void GET_LAYER_REFERENCE (RefType*&ref) {
                        if(RefType::Index()==Index()){ref=(RefType*)this;}
                        else {INPUT.GET_LAYER_REFERENCE(ref);}
                    }
                    inline void SET_FIRST_INPUT (TYPE_FirstInput *_INPUT) {INPUT.SET_FIRST_INPUT(_INPUT);}
                    inline TYPE_Parent       * GET_OUTPUT () {return this;}
                    inline TYPE_Parent const * GET_OUTPUT () const {return this;}
                private:
                    inline TYPE_Data Activator (TYPE_Data const x) const
                    { if (x<0) {return x/(1.0-x);} else {return x;} }
                public:
                    inline void ACTIVATE () {
                        INPUT.ACTIVATE();
                        O = (TYPE_Data*) this->GET_DATA () ;
                        I = (TYPE_Data*) INPUT.GET_DATA () ;
                        for(size_t i=0;i<Size();i++) {O[i]=Activator(I[i]);}
                    }
                    inline void ATTACH (TYPE_Parameter*_PARS) const {}
                    inline void ATTACH (TYPE_Parameter&_PARS) const {}
                    TYPE_Input       INPUT  ;
                private:
                    TYPE_Data * O ;
                    TYPE_Data * I ;
                } ;
                template <typename T_Input> class ActivatorSoftLRUD2 : public ActivatorSoftLRU <T_Input> {
                public:
                    typedef ActivatorSoftLRU <T_Input>        TYPE_Parent       ;
                    typedef typename TYPE_Parent::TYPE_Output TYPE_Delta_Input  ;
                    typedef TYPE_Delta_Input                  TYPE_Delta_Output ;
                private:
                    typedef typename TYPE_Parent::TYPE_Data TMP_TYPE_Data ;
                    inline TMP_TYPE_Data Derivative (TMP_TYPE_Data const x) {
                        if (x<0) {
                            const TMP_TYPE_Data tmp = (1.0-x) ;
                            return 1.0/(tmp*tmp);
                        }
                        else {return 1.0;}
                    }
                    inline void SET_POINTERS (TYPE_Delta_Input const & in) {
                        O  = (TMP_TYPE_Data *) Delta.GET_DATA       () ;
                        I1 = (TMP_TYPE_Data *) in.GET_DATA          () ;
                        I2 = (TMP_TYPE_Data *) this->INPUT.GET_DATA () ;
                    }
                public:
                    //template <typename Ref>
                    inline void BACKPROP (TYPE_Delta_Input const & in) {
                        SET_POINTERS(in);
                        for (size_t i=0;i<this->Size();i++) { O[i] = I1[i] * Derivative(I2[i]) ; }
                        this->INPUT.BACKPROP(Delta);
                    }
                    inline void UPDATE (TMP_TYPE_Data const Eta=0.01) {this->INPUT.UPDATE(Eta);}
                private:
                    TMP_TYPE_Data     * O     ;
                    TMP_TYPE_Data     * I1    ;
                    TMP_TYPE_Data     * I2    ;
                    TYPE_Delta_Output   Delta ;
                } ;
            }
            namespace Activators /* Defining LRU Activation:      */ {
                template <typename T_Input> class ActivatorLRU : public N2DArray <T_Input::SizeY(),T_Input::SizeX(),typename T_Input::TYPE_Data> {
                public:
                    typedef T_Input TYPE_Input ;
                    typedef typename TYPE_Input::TYPE_FirstInput TYPE_FirstInput ;
                    typedef typename TYPE_Input::TYPE_Data TYPE_Data ;
                    typedef ActivatorLRU <TYPE_Input> TYPE_Self ;
                    typedef Nothing TYPE_Parameter ;
                    typedef N2DArray <TYPE_Input::SizeY(),TYPE_Input::SizeX(),TYPE_Data> TYPE_Parent ;
                    typedef TYPE_Parent TYPE_Output ;
                    inline static constexpr size_t SizeX () { return TYPE_Parent::SizeX() ; }
                    inline static constexpr size_t SizeY () { return TYPE_Parent::SizeY() ; }
                    inline static constexpr size_t Size  () { return SizeX() * SizeY()       ; }
                    inline static constexpr size_t Index () { return TYPE_Input::Index() + 1 ; }
                    template <typename RefType> inline void GET_LAYER_REFERENCE (RefType*&ref) {
                        if(RefType::Index()==Index()){ref=(RefType*)this;}
                        else {INPUT.GET_LAYER_REFERENCE(ref);}
                    }
                    inline void SET_FIRST_INPUT (TYPE_FirstInput * _INPUT) {INPUT.SET_FIRST_INPUT(_INPUT);}
                    inline TYPE_Parent       * GET_OUTPUT () {return this;}
                    inline TYPE_Parent const * GET_OUTPUT () const {return this;}
                private:
                    inline TYPE_Data Activator (TYPE_Data const x) const
                    { if (x<0) {return 0;} else {return x;} }
                public:
                    inline void ACTIVATE () {
                        INPUT.ACTIVATE();
                        O = (TYPE_Data*) this->GET_DATA () ;
                        I = (TYPE_Data*) INPUT.GET_DATA () ;
                        for(size_t i=0;i<Size();i++) {O[i]=Activator(I[i]);}
                    }
                    inline void ATTACH (TYPE_Parameter*_PARS) const {}
                    inline void ATTACH (TYPE_Parameter&_PARS) const {}
                    TYPE_Input       INPUT  ;
                private:
                    TYPE_Data * O ;
                    TYPE_Data * I ;
                } ;
                template <typename T_Input> class ActivatorLRUD2 : public ActivatorLRU <T_Input> {
                public:
                    typedef ActivatorLRU <T_Input>            TYPE_Parent       ;
                    typedef typename TYPE_Parent::TYPE_Output TYPE_Delta_Input  ;
                    typedef TYPE_Delta_Input                  TYPE_Delta_Output ;
                private:
                    typedef typename TYPE_Parent::TYPE_Data TMP_TYPE_Data ;
                    inline TMP_TYPE_Data Derivative (TMP_TYPE_Data const x) {
                        if (x<0) {return 0.0;} else {return 1.0;}
                    }
                    inline void SET_POINTERS (TYPE_Delta_Input const & in) {
                        O  = (TMP_TYPE_Data *) Delta.GET_DATA       () ;
                        I1 = (TMP_TYPE_Data *) in.GET_DATA          () ;
                        I2 = (TMP_TYPE_Data *) this->INPUT.GET_DATA () ;
                    }
                public:
                    //template <typename Ref>
                    inline void BACKPROP (TYPE_Delta_Input const & in) {
                        SET_POINTERS(in);
                        for (size_t i=0;i<this->Size();i++) { O[i] = I1[i] * Derivative(I2[i]) ; }
                        this->INPUT.BACKPROP(Delta);
                    }
                    inline void UPDATE (TMP_TYPE_Data const Eta=0.01) {this->INPUT.UPDATE(Eta);}
                private:
                    TMP_TYPE_Data     * O     ;
                    TMP_TYPE_Data     * I1    ;
                    TMP_TYPE_Data     * I2    ;
                    TYPE_Delta_Output   Delta ;
                } ;
            }
            namespace Activators /* Defining Sigmoid activation:  */ {
                template <typename T_Input> class ActivatorSigmoid : public N2DArray <T_Input::SizeY(),T_Input::SizeX(),typename T_Input::TYPE_Data> {
                public:
                    ActivatorSigmoid(){}
                    ~ActivatorSigmoid(){}
                    typedef T_Input TYPE_Input ;
                    typedef typename TYPE_Input::TYPE_FirstInput TYPE_FirstInput ;
                    typedef typename TYPE_Input::TYPE_Data TYPE_Data ;
                    typedef ActivatorSigmoid <TYPE_Input> TYPE_Self ;
                    typedef Nothing TYPE_Parameter ;
                    typedef N2DArray <TYPE_Input::SizeY(),TYPE_Input::SizeX(),TYPE_Data> TYPE_Parent ;
                    typedef TYPE_Parent TYPE_Output ;
                    inline static constexpr size_t SizeX () { return TYPE_Parent::SizeX() ; }
                    inline static constexpr size_t SizeY () { return TYPE_Parent::SizeY() ; }
                    inline static constexpr size_t Size  () { return SizeX() * SizeY()       ; }
                    inline static constexpr size_t Index () { return TYPE_Input::Index() + 1 ; }
                    template <typename RefType> inline void GET_LAYER_REFERENCE (RefType*&ref) {
                        if(RefType::Index()==Index()){ref=(RefType*)this;}
                        else {INPUT.GET_LAYER_REFERENCE(ref);}
                    }
                    inline void SET_FIRST_INPUT (TYPE_FirstInput *_INPUT) {INPUT.SET_FIRST_INPUT(_INPUT);}
                    inline TYPE_Parent       * GET_OUTPUT ()       {return this;}
                    inline TYPE_Parent const * GET_OUTPUT () const {return this;}
                    inline void ACTIVATE () {
                        INPUT.ACTIVATE();
                        TYPE_Data * O = (TYPE_Data*) this->GET_DATA () ;
                        TYPE_Data * I = (TYPE_Data*) INPUT.GET_DATA () ;
                        for (size_t i=0;i<Size();i++) { O[i] = 1.0 / ( 1.0 + exp(-I[i]) ) ; }
                    }
                    inline void ATTACH (TYPE_Parameter*_PARS) const {}
                    inline void ATTACH (TYPE_Parameter&_PARS) const {}
                    TYPE_Input INPUT ;
                } ;
                template <typename T_Input> class ActivatorSigmoidD2 : public ActivatorSigmoid <T_Input> {
                public:
                    typedef ActivatorSigmoid <T_Input>        TYPE_Parent       ;
                    typedef typename TYPE_Parent::TYPE_Output TYPE_Delta_Input  ;
                    typedef TYPE_Delta_Input                  TYPE_Delta_Output ;
                private:
                    typedef typename TYPE_Parent::TYPE_Data TMP_TYPE_Data ;
                    inline void SET_POINTERS (TYPE_Delta_Input const & in) {
                        O  = (TMP_TYPE_Data *) Delta.GET_DATA () ;
                        I1 = (TMP_TYPE_Data *) in.GET_DATA    () ;
                        I2 = (TMP_TYPE_Data *) this->GET_DATA () ;
                    }
                public:
                    inline void BACKPROP (TYPE_Delta_Input const & in) {
                        SET_POINTERS(in);
                        for (size_t i=0;i<this->Size();i++) { O[i] = I1[i] * I2[i] * (1.0-I2[i]) ; }
                        this->INPUT.BACKPROP(Delta);
                    }
                    inline void UPDATE (TMP_TYPE_Data const Eta=0.01) {this->INPUT.UPDATE(Eta);}
                private:
                    TMP_TYPE_Data     * O     ;
                    TMP_TYPE_Data     * I1    ;
                    TMP_TYPE_Data     * I2    ;
                    TYPE_Delta_Output   Delta ;
                } ;
            }

            namespace Activators /* Defining SoftSign activation:  */ {
                template <typename T_Input> class ActivatorSoftSign : public N2DArray <T_Input::SizeY(),T_Input::SizeX(),typename T_Input::TYPE_Data> {
                public:
                    typedef T_Input TYPE_Input ;
                    typedef typename TYPE_Input::TYPE_FirstInput TYPE_FirstInput ;
                    typedef typename TYPE_Input::TYPE_Data TYPE_Data ;
                    typedef ActivatorSigmoid <TYPE_Input> TYPE_Self ;
                    typedef Nothing TYPE_Parameter ;
                    typedef N2DArray <TYPE_Input::SizeY(),TYPE_Input::SizeX(),TYPE_Data> TYPE_Parent ;
                    typedef TYPE_Parent TYPE_Output ;
                    inline static constexpr size_t SizeX () { return TYPE_Parent::SizeX() ; }
                    inline static constexpr size_t SizeY () { return TYPE_Parent::SizeY() ; }
                    inline static constexpr size_t Size  () { return SizeX() * SizeY()       ; }
                    inline static constexpr size_t Index () { return TYPE_Input::Index() + 1 ; }
                    template <typename RefType> inline void GET_LAYER_REFERENCE (RefType*&ref) {
                        if(RefType::Index()==Index()){ref=(RefType*)this;}
                        else {INPUT.GET_LAYER_REFERENCE(ref);}
                    }
                    inline void SET_FIRST_INPUT (TYPE_FirstInput *_INPUT) {INPUT.SET_FIRST_INPUT(_INPUT);}
                    inline TYPE_Parent       * GET_OUTPUT ()       {return this;}
                    inline TYPE_Parent const * GET_OUTPUT () const {return this;}
                    inline void ACTIVATE () {
                        INPUT.ACTIVATE();
                        TYPE_Data * O = (TYPE_Data*) this->GET_DATA () ;
                        TYPE_Data * I = (TYPE_Data*) INPUT.GET_DATA () ;
                        for (size_t i=0;i<Size();i++) { O[i] = I[i] / ( 1.0 + CPPFileIO::mymod(I[i]) ) ; }
                    }
                    inline void ATTACH (TYPE_Parameter*_PARS) const {}
                    inline void ATTACH (TYPE_Parameter&_PARS) const {}
                    TYPE_Input INPUT ;
                } ;
                template <typename T_Input> class ActivatorSoftSignD2 : public ActivatorSoftSign <T_Input> {
                public:
                    typedef ActivatorSigmoid <T_Input>        TYPE_Parent       ;
                    typedef typename TYPE_Parent::TYPE_Output TYPE_Delta_Input  ;
                    typedef TYPE_Delta_Input                  TYPE_Delta_Output ;
                private:
                    typedef typename TYPE_Parent::TYPE_Data TMP_TYPE_Data ;
                    inline void SET_POINTERS (TYPE_Delta_Input const & in) {
                        O  = (TMP_TYPE_Data *) Delta.GET_DATA () ;
                        I1 = (TMP_TYPE_Data *) in.GET_DATA    () ;
                        I2 = (TMP_TYPE_Data *) this->GET_DATA () ;
                    }
                public:
                    inline void BACKPROP (TYPE_Delta_Input const & in) {
                        SET_POINTERS ( in ) ;
                        for ( size_t i = 0 ; i < this->Size () ; i++ )
                        { TMP_TYPE_Data tmp = 1.0 - I2[i] ; O[i] = I1[i] / ( tmp * tmp ) ; }
                        this->INPUT.BACKPROP ( Delta ) ;
                    }
                    inline void UPDATE (TMP_TYPE_Data const Eta=0.01) {this->INPUT.UPDATE(Eta);}
                private:
                    TMP_TYPE_Data     * O     ;
                    TMP_TYPE_Data     * I1    ;
                    TMP_TYPE_Data     * I2    ;
                    TYPE_Delta_Output   Delta ;
                } ;
            }

            namespace Functions /* Defining namespaces:                       */ {
                using namespace Arrays;
                using namespace InputRelated;
            }
            namespace Functions /* Defining NeuralMultiply:                   */ {
                // Function to evaluate neural network activation:
                template <size_t Y, size_t B, size_t X, typename T>
                inline void NeuralMultiply (
                    N2DArray <Y,B,T>       * O ,
                    N2DArray <Y,X,T> const * W ,
                    N2DArray <X,B,T> const * I ,
                    NDArray  <Y,T>   const * S
                ) {
                    for(size_t y=0;y<Y;y++){O[0][y]=S[0][y];}
                    for(size_t y=0;y<Y;y++) {
                        for(size_t x=0;x<X;x++) {
                            for(size_t b=0;b<B;b++){O[0][y][b]+=W[0][y][x]*I[0][x][b];}
                        }
                    }
                }
                #ifdef CBLAS_H
                template <size_t Y, size_t B, size_t X>
                inline void NeuralMultiply (
                    N2DArray < Y , B , double >       * O ,
                    N2DArray < Y , X , double > const * W ,
                    N2DArray < X , B , double > const * I ,
                    NDArray  < Y ,     double > const * S
                ) {
                    for(size_t y=0;y<Y;y++){O[0][y]=S[0][y];}
                    cblas_dgemm (
                        CblasRowMajor, CblasNoTrans, CblasNoTrans,
                        (const int) /*M=*/Y, (const int) /*N=*/B, (const int) /*K=*/X,
                                 (const double) /*alpha=*/1.0,
                                 (const double *) W->GET_DATA(), (const int) /*lda=*/X,
                                 (const double *) I->GET_DATA(), (const int) /*ldb=*/B,
                                 (const double) /*beta=*/1.0,
                                 (double *) O->GET_DATA(), (const int) /*ldc=*/B
                    );
                }
                template <size_t Y, size_t B, size_t X>
                inline void NeuralMultiply (
                    N2DArray < Y , B , float >       * O ,
                    N2DArray < Y , X , float > const * W ,
                    N2DArray < X , B , float > const * I ,
                    NDArray  < Y ,     float > const * S
                ) {
                    for(size_t y=0;y<Y;y++){O[0][y]=S[0][y];}
                    cblas_sgemm (
                        CblasRowMajor, CblasNoTrans, CblasNoTrans,
                        (const int) /*M=*/Y, (const int) /*N=*/B, (const int) /*K=*/X,
                                 (const float) /*alpha=*/1.0,
                                 (const float *) W->GET_DATA(), (const int) /*lda=*/X,
                                 (const float *) I->GET_DATA(), (const int) /*ldb=*/B,
                                 (const float) /*beta=*/1.0,
                                 (float *) O->GET_DATA(), (const int) /*ldc=*/B
                    );
                }
                #endif
            }
            namespace Functions /* Defining EvalW for Backpropagation:        */ {
                // Functions for evaluating changes in weight:
                template <size_t Y, size_t X, size_t B, typename T>
                inline void EvalW (
                    N2DArray <Y,X,T>       * DW    ,
                    N2DArray <Y,B,T> const * Delta ,
                    N2DArray <X,B,T> const * Input
                ) {
                    DW[0] = 0 ;
                    for(size_t y=0;y<Y;y++) for(size_t x=0;x<X;x++) for(size_t b=0;b<B;b++)
                    { DW[0][y][x] += Delta[0][y][b] * Input[0][x][b] ; }
                }
                #ifdef CBLAS_H
                template <size_t Y, size_t X, size_t B>
                inline void EvalW (
                    N2DArray <Y,X,float>       * DW    ,
                    N2DArray <Y,B,float> const * Delta ,
                    N2DArray <X,B,float> const * Input
                ) {
                    cblas_sgemm (
                        CblasRowMajor, CblasNoTrans, CblasTrans,
                        (const int) /*M=*/Y, (const int) /*N=*/X, (const int) /*K=*/B,
                                 (const float) /*alpha=*/1.0,
                                 (const float *) Delta->GET_DATA(), (const int) /*lda=*/B,
                                 (const float *) Input->GET_DATA(), (const int) /*ldb=*/B,
                                 (const float) /*beta=*/1.0,
                                 (float *) DW->GET_DATA(), (const int) /*ldc=*/X
                    );
                }
                template <size_t Y, size_t X, size_t B>
                inline void EvalW (
                    N2DArray <Y,X,double>       * DW    ,
                    N2DArray <Y,B,double> const * Delta ,
                    N2DArray <X,B,double> const * Input
                ) {
                    cblas_dgemm (
                        CblasRowMajor, CblasNoTrans, CblasTrans,
                        (const int) /*M=*/Y, (const int) /*N=*/X, (const int) /*K=*/B,
                                 (const double) /*alpha=*/1.0,
                                 (const double *) Delta->GET_DATA(), (const int) /*lda=*/B,
                                 (const double *) Input->GET_DATA(), (const int) /*ldb=*/B,
                                 (const double) /*beta=*/1.0,
                                 (double *) DW->GET_DATA(), (const int) /*ldc=*/X
                    );
                }
                #endif
            }
            namespace Functions /* Defining the BackProp for Backpropagation: */ {
                // function to evaluate back propagation chain:
                template <size_t X, size_t B, size_t Y, typename T>
                inline void BackProp (
                    N2DArray <X,B,T>       * O ,
                    N2DArray <Y,X,T> const * W ,
                    N2DArray <Y,B,T> const * I
                ) {
                    O[0] = 0 ;
                    for(size_t y=0;y<Y;y++) for(size_t x=0;x<X;x++) for(size_t b=0;b<B;b++)
                    {O[0][x][b] += W[0][y][x] * I[0][y][b];}
                }
                #ifdef CBLAS_H
                template <size_t X, size_t B, size_t Y>
                inline void BackProp (
                    N2DArray <X,B,float>       * O ,
                    N2DArray <Y,X,float> const * W ,
                    N2DArray <Y,B,float> const * I
                ) {
                    cblas_sgemm (
                        CblasRowMajor, CblasTrans, CblasNoTrans,
                        (const int) /*M=*/X, (const int) /*N=*/B, (const int) /*K=*/Y,
                                 (const float) /*alpha=*/1.0,
                                 (const float *) W->GET_DATA(), (const int) /*lda=*/X,
                                 (const float *) I->GET_DATA(), (const int) /*ldb=*/B,
                                 (const float) /*beta=*/0,
                                 (float *) O->GET_DATA(), (const int) /*ldc=*/B
                    );
                }
                template <size_t X, size_t B, size_t Y>
                inline void BackProp (
                    N2DArray <X,B,double>       * O ,
                    N2DArray <Y,X,double> const * W ,
                    N2DArray <Y,B,double> const * I
                ) {
                    cblas_dgemm (
                        CblasRowMajor, CblasTrans, CblasNoTrans,
                        (const int) /*M=*/X, (const int) /*N=*/B, (const int) /*K=*/Y,
                                 (const double) /*alpha=*/1.0,
                                 (const double *) W->GET_DATA(), (const int) /*lda=*/X,
                                 (const double *) I->GET_DATA(), (const int) /*ldb=*/B,
                                 (const double) /*beta=*/0,
                                 (double *) O->GET_DATA(), (const int) /*ldc=*/B
                    );
                }
                #endif
            }

            namespace MainLayers /* The main intermediate layers part: */ {
                using namespace Arrays ;
                template <size_t Y, typename T_Input> class NNLayer : public N2DArray<Y,T_Input::SizeX(),typename T_Input::TYPE_Data> {
                public:
                    typedef T_Input TYPE_Input ;
                    typedef typename TYPE_Input::TYPE_FirstInput TYPE_FirstInput ;
                    typedef typename TYPE_Input::TYPE_Data TYPE_Data ;
                    inline static constexpr size_t SizeX () { return TYPE_Input::SizeX()     ; }
                    inline static constexpr size_t SizeY () { return Y                       ; }
                    inline static constexpr size_t Size  () { return SizeX() * SizeY()       ; }
                    inline static constexpr size_t Index () { return TYPE_Input::Index() + 1 ; }
                    typedef N2DArray <SizeY(),SizeX(),TYPE_Data> TYPE_Parent ;
                    typedef TYPE_Parent TYPE_Output ;
                    typedef NNLayer <Y,TYPE_Input> TYPE_Self ;
                    typedef ParameterRelated::Parameter <SizeY(),TYPE_Input::SizeY(),TYPE_Data> TYPE_Parameter ;
                    template <typename RefType> inline void GET_LAYER_REFERENCE (RefType*&ref) {
                        if(RefType::Index()==Index()){ref=(RefType*)this;}
                        else {INPUT.GET_LAYER_REFERENCE(ref);}
                    }
                    inline void SET_FIRST_INPUT (TYPE_FirstInput *_INPUT) {INPUT.SET_FIRST_INPUT(_INPUT);}
                    inline TYPE_Parent       * GET_OUTPUT () {return this;}
                    inline TYPE_Parent const * GET_OUTPUT () const {return this;}
                    inline void ACTIVATE () {
                        INPUT.ACTIVATE () ;
                        Functions::NeuralMultiply(GET_OUTPUT(),&(PARS->WEIGHT),INPUT.GET_OUTPUT(),&(PARS->BIAS));
                    }
                    inline void ATTACH (TYPE_Parameter*_PARS) {PARS=_PARS;}
                    inline void ATTACH (TYPE_Parameter&_PARS) {ATTACH(&_PARS);}
                    inline TYPE_Parent & operator () (TYPE_FirstInput&inref) {
                        SET_FIRST_INPUT (&inref) ;
                        ACTIVATE () ;
                        return this[0] ;
                    }
                    TYPE_Parameter * PARS   ;
                    TYPE_Input       INPUT  ;
                } ;

                template <size_t Y, typename T_Input> class NNLayerStopBP : public N2DArray<Y,T_Input::SizeX(),typename T_Input::TYPE_Data> {
                public:
                    typedef NNLayer  <Y,T_Input>                 TYPE_Parent       ;
                    typedef typename TYPE_Parent::TYPE_Output    TYPE_Delta_Input  ;
                    typedef typename T_Input::TYPE_Output        TYPE_Delta_Output ;
                private:
                    typedef typename TYPE_Parent::TYPE_Data      TMP_TYPE_Data     ;
                public:
                    inline void BACKPROP (TYPE_Delta_Input const & in) {}
                    inline void UPDATE (TMP_TYPE_Data const Eta=0.01) {}
                };
                template <size_t Y, typename T_Input> class NNLayer_BPDL : public NNLayer <Y,T_Input> {
                public:
                    typedef NNLayer  <Y,T_Input>                 TYPE_Parent       ;
                    typedef typename TYPE_Parent::TYPE_Output    TYPE_Delta_Input  ;
                    typedef typename T_Input::TYPE_Output        TYPE_Delta_Output ;
                private:
                    typedef typename TYPE_Parent::TYPE_Data      TMP_TYPE_Data     ;
                public:
                    inline void BACKPROP (TYPE_Delta_Input const & in) {
                        Functions::BackProp(&Delta,&(this->PARS->WEIGHT),&in);
                        this->INPUT.BACKPROP(Delta);
                    }
                    inline void UPDATE (TMP_TYPE_Data const Eta=0.01) {
                        this->INPUT.UPDATE (Eta) ;
                    }
                private:
                    TYPE_Delta_Output    Delta      ;
                } ;

                template <size_t Y, typename T_Input> class NNLayerD2 : public NNLayer <Y,T_Input> {
                public:
                    NNLayerD2(){DPars[0]=0;DPars[1]=0;}
                    typedef NNLayer  <Y,T_Input>                 TYPE_Parent       ;
                    typedef typename TYPE_Parent::TYPE_Output    TYPE_Delta_Input  ;
                    typedef typename T_Input::TYPE_Output        TYPE_Delta_Output ;
                private:
                    typedef typename TYPE_Parent::TYPE_Parameter TMP_TYPE_Parameter ;
                    typedef typename TYPE_Parent::TYPE_Data      TMP_TYPE_Data      ;
                public:
                    typedef ParameterRelated::ParameterAdam <TMP_TYPE_Parameter> TYPE_Parameter ;
                    inline void BACKPROP (TYPE_Delta_Input const & in) {
                        Functions::BackProp(&Delta,&(this->PARS->WEIGHT),&in);
                        in2.GET_SQUARED(in); INPUT2.GET_SQUARED(this->INPUT.GET_OUTPUT()[0]);
                        Functions::EvalW ( &DPars[0].WEIGHT , &in  , this->INPUT.GET_OUTPUT() ) ;
                        Functions::EvalW ( &DPars[1].WEIGHT , &in2 , &INPUT2                  ) ;
                        for(size_t y=0;y<TYPE_Delta_Input::SizeY();y++) {
                            for(size_t x=0;x<TYPE_Delta_Input::SizeX();x++)
                            { DPars[0].BIAS[y]+=in[y][x]; }
                        }
                        for(size_t y=0;y<TYPE_Delta_Input::SizeY();y++) {
                            for(size_t x=0;x<TYPE_Delta_Input::SizeX();x++)
                            { DPars[1].BIAS[y]+=in2[y][x]; }
                        }
                        this->INPUT.BACKPROP(Delta);
                    }
                    inline void UPDATE (TMP_TYPE_Data const Eta=0.01) {
                        PARS_TRAIN = static_cast<TYPE_Parameter*>(this->PARS) ;
                        PARS_TRAIN->UPDATE ( /*_M=*/DPars[0] , /*_V=*/DPars[1] , /*Eta=*/Eta ) ;
                        {DPars[0]=0;DPars[1]=0;}
                        this->INPUT.UPDATE (Eta) ;
                    }
                private:
                    TYPE_Parameter     * PARS_TRAIN ;
                    TMP_TYPE_Parameter   DPars[2]   ;
                    TYPE_Delta_Input     in2        ;
                    TYPE_Delta_Output    INPUT2     ;
                    TYPE_Delta_Output    Delta      ;
                } ;
            }
            namespace MainLayers /* The last error layer part: */ {

                template <typename T_Input> class Teacher
                : public N2DArray <
                T_Input::SizeY(),T_Input::SizeX(),typename T_Input::TYPE_Data
                > {
                public:
                    typedef T_Input TYPE_Input ;
                    typedef N2DArray <
                    TYPE_Input::SizeY(),TYPE_Input::SizeX(),typename TYPE_Input::TYPE_Data
                    > TYPE_Parent ;
                    typedef typename TYPE_Input::TYPE_FirstInput TYPE_FirstInput ;
                    inline static constexpr size_t Index () { return TYPE_Input::Index() + 1 ; }
                    typedef TYPE_Parent TYPE_Output ;
                    typedef Teacher <TYPE_Input> TYPE_Self ;
                    typedef Nothing TYPE_Parameter ;
                private:
                    typedef typename TYPE_Parent::TYPE_Data TMP_TYPE_Data ;
                    inline static constexpr TMP_TYPE_Data SmallEpsilon () {return 0.01;}
                public:
                    template <typename RefType> inline void GET_LAYER_REFERENCE (RefType*&ref) {
                        if(RefType::Index()==Index()){ref=(RefType*)this;}
                        else {INPUT.GET_LAYER_REFERENCE(ref);}
                    }
                    inline void SET_FIRST_INPUT (TYPE_FirstInput *_INPUT) {INPUT.SET_FIRST_INPUT(_INPUT);}
                    inline void SET_ANSWER (TYPE_Output * _Answer) {ANSWER=_Answer;}
                    inline TYPE_Parent       * GET_OUTPUT () {return this;}
                    inline TYPE_Parent const * GET_OUTPUT () const {return this;}
                    inline void ACTIVATE () { INPUT.ACTIVATE () ; }
                    inline void ATTACH (TYPE_Parameter*_PARS) const {}
                    inline void ATTACH (TYPE_Parameter&_PARS) const {}
                    inline TMP_TYPE_Data BACKPROP () {
                        TMP_TYPE_Data * Delta  = (TMP_TYPE_Data *) DELTA.GET_DATA    () ;
                        TMP_TYPE_Data * Input  = (TMP_TYPE_Data *) INPUT.GET_DATA    () ;
                        TMP_TYPE_Data * Answer = (TMP_TYPE_Data *) ANSWER->GET_DATA  () ;
                        constexpr size_t limit = TYPE_Parent::Size () ;
                        for(size_t i=0;i<limit;i++) { Delta[i] = Input[i] - Answer[i] ; }
                        INPUT.BACKPROP(DELTA);
                        TMP_TYPE_Data l1norm = 0 ;
                        for(size_t i=0;i<limit;i++){l1norm+=CPPFileIO::mymod(Delta[i]);}
                        return l1norm;
                    }
                    inline TMP_TYPE_Data BACKPROP_REL () {
                        TMP_TYPE_Data * Delta  = (TMP_TYPE_Data *) DELTA.GET_DATA    () ;
                        TMP_TYPE_Data * Input  = (TMP_TYPE_Data *) INPUT.GET_DATA    () ;
                        TMP_TYPE_Data * Answer = (TMP_TYPE_Data *) ANSWER->GET_DATA  () ;
                        constexpr size_t limit = TYPE_Parent::Size () ;
                        for(size_t i=0;i<limit;i++)
                        { Delta[i] = ( Input[i] - Answer[i] ) / ( CPPFileIO::mymod(Answer[i]) + SmallEpsilon() ) ; }
                        INPUT.BACKPROP(DELTA);
                        TMP_TYPE_Data l1norm = 0 ;
                        for(size_t i=0;i<limit;i++){l1norm+=CPPFileIO::mymod(Delta[i]);}
                        return l1norm;
                    }
                    inline void UPDATE (TMP_TYPE_Data const Eta=0.01) {INPUT.UPDATE(Eta);}
                    TYPE_Output * ANSWER ;
                    TYPE_Input INPUT ;
                private:
                    TYPE_Output DELTA ;
                };


                template <typename T_Input> class TeacherRelative
                : public N2DArray <
                T_Input::SizeY(),T_Input::SizeX(),typename T_Input::TYPE_Data
                > {
                public:
                    typedef T_Input TYPE_Input ;
                    typedef N2DArray <
                    TYPE_Input::SizeY(),TYPE_Input::SizeX(),typename TYPE_Input::TYPE_Data
                    > TYPE_Parent ;
                    typedef typename TYPE_Input::TYPE_FirstInput TYPE_FirstInput ;
                    inline static constexpr size_t Index () { return TYPE_Input::Index() + 1 ; }
                    typedef TYPE_Parent TYPE_Output ;
                    typedef TeacherRelative <TYPE_Input> TYPE_Self ;
                    typedef Nothing TYPE_Parameter ;
                private:
                    typedef typename TYPE_Input::TYPE_Data TMP_TYPE_Data ;
                    inline static constexpr TMP_TYPE_Data SmallEpsilon () {return 0.01;}
                public:
                    template <typename RefType> inline void GET_LAYER_REFERENCE (RefType*&ref) {
                        if(RefType::Index()==Index()){ref=(RefType*)this;}
                        else {INPUT.GET_LAYER_REFERENCE(ref);}
                    }
                    inline void SET_FIRST_INPUT (TYPE_FirstInput *_INPUT) {INPUT.SET_FIRST_INPUT(_INPUT);}
                    inline void SET_ANSWER (TYPE_Output * _Answer) {ANSWER=_Answer;}
                    inline TYPE_Parent       * GET_OUTPUT () {return this;}
                    inline TYPE_Parent const * GET_OUTPUT () const {return this;}
                    inline void ACTIVATE () { INPUT.ACTIVATE () ; }
                    inline void ATTACH (TYPE_Parameter*_PARS) const {}
                    inline void ATTACH (TYPE_Parameter&_PARS) const {}
                    inline TMP_TYPE_Data BACKPROP () {
                        TMP_TYPE_Data * Delta  = (TMP_TYPE_Data *) DELTA.GET_DATA    () ;
                        TMP_TYPE_Data * Input  = (TMP_TYPE_Data *) INPUT.GET_DATA    () ;
                        TMP_TYPE_Data * Answer = (TMP_TYPE_Data *) ANSWER->GET_DATA  () ;
                        constexpr size_t limit = TYPE_Parent::Size () ;
                        for(size_t i=0;i<limit;i++)
                        { Delta[i] = ( Input[i] - Answer[i] ) / ( CPPFileIO::mymod(Answer[i]) + SmallEpsilon() ) ; }
                        INPUT.BACKPROP(DELTA);
                        TMP_TYPE_Data l1norm = 0 ;
                        for(size_t i=0;i<limit;i++){l1norm+=CPPFileIO::mymod(Delta[i]);}
                        return l1norm;
                    }
                    inline void UPDATE (TMP_TYPE_Data const Eta=0.01) {INPUT.UPDATE(Eta);}
                    TYPE_Output * ANSWER ;
                    TYPE_Input INPUT ;
                private:
                    TYPE_Output DELTA ;
                };
            }
            namespace MainLayers /* These networks also evaluate derivatives: */ {
                template <size_t Y, typename T_Input> class NNDerivativeLayerD2 : public NNLayerD2 <Y,T_Input> {
                public:

                };
            }
        }
    }
}

namespace NN1 {

    typedef Tensors::Arrays::N2DArray <1,10000,double> TYPE_Input ;
    using namespace Tensors::NeuralNetwork::NeuralLayers ;
    typedef InputRelated::FirstLayer <TYPE_Input> NF0 ;

    typedef MainLayers::NNLayerD2 <10,NF0> NL1 ;
    typedef Activators::ActivatorSoftLRUD2 <NL1> NA1 ;

    typedef MainLayers::NNLayer_BPDL <10,NA1> NL2 ;
    typedef Activators::ActivatorSoftLRUD2 <NL2> NA2 ;

    typedef MainLayers::NNLayerD2 <10,NA2> NL3 ;
    typedef Activators::ActivatorSoftLRUD2 <NL3> NA3 ;

    typedef MainLayers::NNLayerD2 <1,NA3> NL4 ;

    typedef MainLayers::Teacher <NL4> MainNet ;


    typedef NL1::TYPE_Parameter NP1 ;
    typedef NL2::TYPE_Parameter NP2 ;
    typedef NL3::TYPE_Parameter NP3 ;
    typedef NL4::TYPE_Parameter NP4 ;

    constexpr double begin = -10 ;
    constexpr double end = 10 ;
    constexpr double dx = (end-begin)/((double)TYPE_Input::SizeX());

    class SampleNN {
    private:
        NP1          par1 ;
        NP2          par2 ;
        NP3          par3 ;
        NP4          par4 ;
        TYPE_Input   in_x ;
        TYPE_Input   in_y ;
        MainNet      net  ;
        NL1        * Ref1 ;
        NL2        * Ref2 ;
        NL3        * Ref3 ;
        NL4        * Ref4 ;
    public:
        inline ssize_t WRITE (std::string filename = "outpars") {
            CPPFileIO::FileFD writer(filename);
            writer.writefile();
            ssize_t ret = 0 ;
            ret += (par1>>writer) ;
            ret += (par2>>writer) ;
            ret += (par3>>writer) ;
            ret += (par4>>writer) ;
            return ret ;
        }
        inline ssize_t READ (std::string filename = "outpars") {
            CPPFileIO::FileFD reader(filename);
            reader.readfile();
            ssize_t ret = 0 ;
            ret += (par1<<reader) ;
            ret += (par2<<reader) ;
            ret += (par3<<reader) ;
            ret += (par4<<reader) ;
            return ret ;
        }
        inline void RANDOMIZE(){
            par1.RANDOMIZE();
            par2.RANDOMIZE();
            par3.RANDOMIZE();
            par4.RANDOMIZE();
        }
        inline void GET_LAYER_REFERENCE(){
            net.GET_LAYER_REFERENCE(Ref1);
            net.GET_LAYER_REFERENCE(Ref2);
            net.GET_LAYER_REFERENCE(Ref3);
            net.GET_LAYER_REFERENCE(Ref4);
        }
        inline void ATTACH () {
            Ref1->ATTACH(&par1);
            Ref2->ATTACH(&par2);
            Ref3->ATTACH(&par3);
            Ref4->ATTACH(&par4);
        }
        inline void INITIALIZE_DATA () {
            for(size_t x=0;x<TYPE_Input::SizeX();x++){
                in_x[0][x] = begin + (x*dx) ;
                in_y[0][x] = in_x[0][x]*in_x[0][x] ;
            }
            net.SET_FIRST_INPUT(&in_x);
            net.SET_ANSWER(&in_y);
        }
        inline void INIT () {
            RANDOMIZE           () ;
            GET_LAYER_REFERENCE () ;
            ATTACH              () ;
            INITIALIZE_DATA     () ;
        }
        inline void ACTIVATE () {net.ACTIVATE();}
        inline TYPE_Input::TYPE_Data BACKPROP () {return net.BACKPROP();}
        inline void UPDATE (TYPE_Input::TYPE_Data eta) {net.UPDATE(eta);}
        SampleNN(){INIT();}
        ~SampleNN(){}
    } ;
}

namespace NN2 {

    typedef Tensors::Arrays::N2DArray <1,1,double> TYPE_Input ;
    using namespace Tensors::NeuralNetwork::NeuralLayers ;
    typedef InputRelated::FirstLayer <TYPE_Input> NF0 ;

    typedef MainLayers::NNLayer <10,NF0> NL1 ;
    typedef Activators::ActivatorSoftLRU <NL1> NA1 ;

    typedef MainLayers::NNLayer <10,NA1> NL2 ;
    typedef Activators::ActivatorSoftLRU <NL2> NA2 ;

    typedef MainLayers::NNLayer <10,NA2> NL3 ;
    typedef Activators::ActivatorSoftLRU <NL3> NA3 ;

    typedef MainLayers::NNLayer <1,NA3> NL4 ;

    typedef NL4 MainNet ;

    typedef NL1::TYPE_Parameter NP1 ;
    typedef NL2::TYPE_Parameter NP2 ;
    typedef NL3::TYPE_Parameter NP3 ;
    typedef NL4::TYPE_Parameter NP4 ;

    class SampleNN {
    private:
        NP1          par1 ;
        NP2          par2 ;
        NP3          par3 ;
        NP4          par4 ;
        TYPE_Input   in_x ;
        MainNet      net  ;
        NL1        * Ref1 ;
        NL2        * Ref2 ;
        NL3        * Ref3 ;
        NL4        * Ref4 ;
    public:
        inline ssize_t READ (std::string filename = "outpars") {
            CPPFileIO::FileFD reader(filename);
            reader.readfile();
            ssize_t ret = 0 ;
            ret += (par1<<reader) ;
            ret += (par2<<reader) ;
            ret += (par3<<reader) ;
            ret += (par4<<reader) ;
            return ret ;
        }
        inline void ATTACH () {
            Ref1->ATTACH(&par1);
            Ref2->ATTACH(&par2);
            Ref3->ATTACH(&par3);
            Ref4->ATTACH(&par4);
        }
        inline void GET_LAYER_REFERENCE(){
            net.GET_LAYER_REFERENCE(Ref1);
            net.GET_LAYER_REFERENCE(Ref2);
            net.GET_LAYER_REFERENCE(Ref3);
            net.GET_LAYER_REFERENCE(Ref4);
        }
        inline void INITIALIZE_DATA () {
            net.SET_FIRST_INPUT(&in_x);
        }
        inline void INIT () {
            READ                () ;
            GET_LAYER_REFERENCE () ;
            ATTACH              () ;
            INITIALIZE_DATA     () ;
        }
        inline double ACTIVATE (double x) {
            in_x = x ;
            net.ACTIVATE();
            return net[0][0];
        }
        SampleNN(){INIT();}
        ~SampleNN(){}
    } ;
}

namespace TmpNameSpaces {
    using namespace Tensors::Arrays ;
    typedef NDArray <2,double> Element ;
    typedef NDArray <10000,Element> NDMassArray ;
    typedef NDArray <59,NDMassArray> MainArray ;
    typedef NDArray <6,double> SignForMass ;

    typedef NDArray <2,Element> FuncMaps1 ;
    typedef NDArray <4,Element> FuncMaps2 ;
    class Extrapolate1 {
    private:
        FuncMaps1 * in ;
        template <size_t i> inline double term (double x) {
            double ret = in[0][i][1] ;
            for(size_t j=0;j<FuncMaps1::Size();j++) if(j!=i) {
                ret*=(x-in[0][j][0])/(in[0][i][0]-in[0][j][0]);
            }
            return ret ;
        }
        inline double Eval (double x) { return term<0>(x)+term<1>(x); }
    public:
        inline double operator () (double x) {return Eval(x);}
        Extrapolate1(FuncMaps1 * _in){in=_in;}
        ~Extrapolate1(){}
    } ;

    class Extrapolate2 {
    private:
        FuncMaps2 * in ;
        template <size_t i> inline double term (double x) {
            double ret = in[0][i][1] ;
            for(size_t j=0;j<FuncMaps2::Size();j++) if(j!=i) {
                ret*=(x-in[0][j][0])/(in[0][i][0]-in[0][j][0]);
            }
            //printf("%ld %e %e %e\n",i,x,ret,in[0][i][1]);
            return ret ;
        }
        inline double Eval (double x) {
            return term<0>(x)+term<1>(x)+term<2>(x)+term<3>(x);
        }
    public:
        inline double operator () (double x) {return Eval(x);}
        Extrapolate2(FuncMaps2 * _in){in=_in;}
        ~Extrapolate2(){}
    } ;
}

namespace SAMPLE_ROC {
    typedef float FloatType ;
    inline std::string ROC_PARS_FILE () {return "./ROC/PARS_FILE";}
    inline std::string ROC_FILE () {return "./ROC/FILE";}
    inline std::string SIG_FILE () {return "./ROC/SIG_FILE";}
    inline std::string BKG_FILE () {return "./ROC/BKG_FILE";}
    inline std::string ROC_FILE_TXT () {return "./ROC/FILE.txt";}

    template <typename TF> class ROCElement {
    public:
        typedef ROCElement <TF> TYPE_Self ;
        int    type  ;
        size_t index ;
        TF     value ;
        inline bool operator > (TYPE_Self const & other) const {return value>other.value;}
        inline bool operator < (TYPE_Self const & other) const {return value<other.value;}
        ROCElement(TF _value, int _type, size_t _index):
        value(_value), index(_index), type(_type) {}
        ROCElement(){}
    } ;
    namespace Training {
        using namespace Tensors::NeuralNetwork::NeuralLayers ;
        template <size_t batchsize=4096> class SampleNN {
        public:
            typedef Tensors::Arrays::N2DArray <1,batchsize,FloatType> TYPE_Input ;
            typedef InputRelated::FirstLayer       < TYPE_Input > NL0 ;
            typedef MainLayers::NNLayerD2          < 10  , NL0  > NL1 ;
            typedef Activators::ActivatorSoftLRUD2 <       NL1  > NA1 ;
            typedef MainLayers::NNLayerD2          < 10  , NA1  > NL2 ;
            typedef Activators::ActivatorSoftLRUD2 <       NL2  > NA2 ;
            typedef MainLayers::NNLayerD2          <  1  , NA2  > NL3 ;
            typedef MainLayers::Teacher <NL3> MainNet ;
            typedef typename MainNet::TYPE_Output TYPE_Output;
            typedef typename NL1::TYPE_Parameter NP1 ;
            typedef typename NL2::TYPE_Parameter NP2 ;
            typedef typename NL3::TYPE_Parameter NP3 ;
            typedef typename TYPE_Input::TYPE_Data TYPE_Data ;
            typedef ROCElement <TYPE_Data> rocelement ;
        private:
            NP1   par1 ;
            NP2   par2 ;
            NP3   par3 ;
            NL1 * Ref1 ;
            NL2 * Ref2 ;
            NL3 * Ref3 ;
            CPPFileIO::FullFileReader <TYPE_Input> BKG ;
            CPPFileIO::FullFileReader <TYPE_Input> SIG ;
            TYPE_Output ANS_SIG ;
            TYPE_Output ANS_BKG ;
            size_t minsize ;
            MainNet net ;
            std::vector <rocelement> output ;
        public:
            static inline void MakeBatch ( std::string NAME_SIG , std::string NAME_BKG ) {
                /* The top part: */ {
                    Tensors::Arrays::Batcher <TYPE_Input> out (NAME_SIG+".batch") ;
                    out = NAME_SIG ;
                }
                /* The QCD Part: */ {
                    Tensors::Arrays::Batcher <TYPE_Input> out (NAME_BKG+".batch") ;
                    out = NAME_BKG ;
                }
            }
            inline ssize_t WRITE (std::string filename) {
                CPPFileIO::FileFD writer (filename) ;
                writer.writefile () ;
                ssize_t ret = 0 ;
                ret += ( par1 >> writer ) ;
                ret += ( par2 >> writer ) ;
                ret += ( par3 >> writer ) ;
                return ret ;
            }
            inline ssize_t READ  (std::string filename) {
                CPPFileIO::FileFD reader (filename) ;
                reader.readfile () ;
                ssize_t ret = 0 ;
                ret += ( par1 << reader ) ;
                ret += ( par2 << reader ) ;
                ret += ( par3 << reader ) ;
                return ret ;
            }
        private:
            inline void RANDOMIZE(){
                par1.RANDOMIZE();
                par2.RANDOMIZE();
                par3.RANDOMIZE();
            }
            inline void GET_LAYER_REFERENCE(){
                net.GET_LAYER_REFERENCE(Ref1);
                net.GET_LAYER_REFERENCE(Ref2);
                net.GET_LAYER_REFERENCE(Ref3);
            }
            inline void ATTACH () {
                Ref1->ATTACH(&par1);
                Ref2->ATTACH(&par2);
                Ref3->ATTACH(&par3);
            }
            inline void INIT () {
                RANDOMIZE           () ;
                GET_LAYER_REFERENCE () ;
                ATTACH              () ;
                minsize = CPPFileIO::mymin (SIG(),BKG()) ;
                ANS_SIG =  1.0 ;
                ANS_BKG = -1.0 ;
                printf ( "DEBUG: BKG() = %ld\n" , BKG () );
                printf ( "DEBUG: SIG() = %ld\n" , SIG () );
            }
        public:
            inline size_t operator () () {return minsize;}
            inline void EVAL_BATCH (size_t i, TYPE_Data eta) {
                net.SET_FIRST_INPUT(&(BKG(i)));
                net.SET_ANSWER(&ANS_BKG);
                net.ACTIVATE();
                TYPE_Data SE = net.BACKPROP();
                net.SET_FIRST_INPUT(&(SIG(i)));
                net.SET_ANSWER(&ANS_SIG);
                net.ACTIVATE();
                TYPE_Data BE = net.BACKPROP();
                printf("ERRORS: SE = %e, BE = %e\n",SE,BE);
                net.UPDATE(eta);
            }
            inline void EVAL_BATCH (TYPE_Data eta=0.01)
            { for(size_t i=0;i<minsize;i++){EVAL_BATCH(i,eta);} }
            inline void EVAL_ROC (size_t i) {
                if(batchsize==1){
                    net.SET_FIRST_INPUT(&(BKG(i)));
                    net.ACTIVATE();
                    FloatType RES_BKG = Ref3[0][0][0] ;
                    net.SET_FIRST_INPUT(&(SIG(i)));
                    net.ACTIVATE();
                    FloatType RES_SIG = Ref3[0][0][0] ;
                    output.push_back ( rocelement ( RES_BKG , -1 , i ) ) ;
                    output.push_back ( rocelement ( RES_SIG ,  1 , i ) ) ;
                } else { printf("ONLY batchsize=1 is supported for evaluation...\n"); }
            }
            inline void EVAL_ROC ( std::string outfilename ) {
                output.clear();
                for (size_t i=0;i<minsize;i++) {EVAL_ROC(i);}
                CPPFileIO::FileFD Writer (outfilename) ; Writer.writefile();
                std::sort (output.begin(),output.end()) ;
                Writer << output ;
            }
            SampleNN ( std::string NAME_SIG, std::string NAME_BKG ) :
            BKG(NAME_BKG), SIG(NAME_SIG) {INIT();}
            ~SampleNN(){}
            static inline SampleNN <batchsize> * NEW ( std::string NAME_SIG, std::string NAME_BKG ) {
                MakeBatch (NAME_SIG,NAME_BKG) ;
                SampleNN <batchsize> * ret = new SampleNN <batchsize> (NAME_SIG+".batch",NAME_BKG+".batch") ;
                return ret ;
            }
        } ;
    }
    inline void MakeROC () {
        using namespace Training;
        typedef SampleNN<1>::rocelement rocelement ;
        /* The NN Part: */ {
            auto * slave = SampleNN<1>::NEW(SIG_FILE(),BKG_FILE());
            slave->READ(ROC_PARS_FILE());
            slave->EVAL_ROC(ROC_FILE());
            delete slave ;
        }
        /* The actual ROC Part: */ {
            std::vector <rocelement> arrays ; /* Read in the data */ {
                std::vector <rocelement> tmparrays ;
                CPPFileIO::FileFD Reader(ROC_FILE()) ; Reader.readfile();
                Reader >> tmparrays ;
                for(size_t i=0;i<tmparrays.size();i++) {
                    arrays.push_back(tmparrays[i]);
                }
            }
            std::sort (arrays.begin(),arrays.end()) ;
            size_t TOTAL_SIG = 0 ;
            size_t TOTAL_BKG = 0 ;

            for(size_t i=0;i<arrays.size();i++){
                if      (arrays[i].type ==  1 ) {TOTAL_SIG++;}
                else if (arrays[i].type == -1 ) {TOTAL_BKG++;}
            }
            size_t NEW_BKG = TOTAL_BKG ;
            size_t NEW_SIG = TOTAL_SIG ;
            std::string outfilename = ROC_FILE_TXT () ;
            FILE * f = fopen (&(outfilename[0]),"w") ;
            for(size_t i=0;i<arrays.size();i++){
                if      ( arrays[i].type ==  1 ) { NEW_SIG-- ; }
                else if ( arrays[i].type == -1 ) { NEW_BKG-- ; }
                fprintf(f,"%e %e\n",((double)NEW_SIG/TOTAL_SIG),1.0/((double)NEW_BKG/TOTAL_BKG));
            }
            fclose(f);
        }
    }
    inline void Create () {
        using namespace Training;
        auto * slave = SampleNN<>::NEW(SIG_FILE(),BKG_FILE());
        slave->WRITE(ROC_PARS_FILE());
        delete slave ;
    }
    inline void Train () {
        using namespace Training;
        printf("Came here...\n");
        auto * slave = SampleNN<>::NEW(SIG_FILE(),BKG_FILE());
        slave->READ(ROC_PARS_FILE());
        for(size_t j=0;j<100;j++){
            for(size_t i=0;i<10;i++){slave->EVAL_BATCH(0.0001);}
            printf("Writing...\n");
            slave->WRITE(ROC_PARS_FILE());
            printf("Wrote...\n");
        }
        delete slave ;
    }
}

#endif
#endif
