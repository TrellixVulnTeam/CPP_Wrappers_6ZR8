namespace CPPFileIO {

	void getnames (
		std::vector <std::string> & lines ,
		std::string const filename
	) {
		lines.clear();
		char *line=NULL;
		size_t len=0;
		ssize_t read;
		FILE *stream = fopen (&(filename[0]),"r") ;
		while (
			(read = getline(&line, &len, stream)) != -1
		) {
			std::string linename(line);
			linename[linename.size()-1]=0;
			lines.push_back(linename);
		}
		if (len>0) {free(line);}
		fclose(stream);
	}

	class FileLines {
	private:
		std::vector <std::string> lines    ;
		std::string               filename ;
	public:
		FileLines(std::string _filename):
			filename(_filename) {
			getnames(lines,filename);
		}
		~FileLines () {}
		inline std::string & operator [] (size_t i)       { return lines[i]      ; }
		inline size_t        size        ()         const { return lines.size () ; }
		inline std::string & operator () (size_t i)       { return lines[i]      ; }
		inline size_t        operator () ()         const { return lines.size () ; }
		inline void operator () (FILE *f) { for (size_t i=0;i<lines.size();i++) {fprintf(f,"%s\n",&(lines[i][0]));} }
		void debug_show () { for (size_t i=0;i<lines.size();i++) {printf("%ld => [%s]\n",i,&(lines[i][0]));} }
	};

    class StringSplit {
    private:
        ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    public:
        ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

        ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        // The Main Data Elements: /////////////////////////////////////////////////////////////////////////////////////////////////
        ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        std::string               line    ; ////////////////////////////////////////////////////////////////////////////////////////
        std::vector <std::string> words   ; ////////////////////////////////////////////////////////////////////////////////////////
        char                      delimit ; ////////////////////////////////////////////////////////////////////////////////////////
        ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

        ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        // Important functions: ////////////////////////////////////////////////////////////////////////////////////////////////////
        ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        StringSplit  ( std::string _line = "" , char _delimit = ' ' ) : line(_line) , delimit(_delimit) { //////////////////////////
            std::vector <char> buf ; buf.reserve(line.size()) ; ////////////////////////////////////////////////////////////////////
            for (size_t i=0;i<line.size();i++) { ///////////////////////////////////////////////////////////////////////////////////
                if (line[i]==delimit) { ////////////////////////////////////////////////////////////////////////////////////////////
                    buf.push_back((char)0); ////////////////////////////////////////////////////////////////////////////////////////
                    words.push_back(std::string(&(buf[0]))); ///////////////////////////////////////////////////////////////////////
                    buf.resize(0) ; ////////////////////////////////////////////////////////////////////////////////////////////////
                    buf.push_back(line[i]); ////////////////////////////////////////////////////////////////////////////////////////
                    buf.push_back((char)0); ////////////////////////////////////////////////////////////////////////////////////////
                    words.push_back(std::string(&(buf[0]))); ///////////////////////////////////////////////////////////////////////
                    buf.resize(0) ; ////////////////////////////////////////////////////////////////////////////////////////////////
                } //////////////////////////////////////////////////////////////////////////////////////////////////////////////////
                else { buf.push_back(line[i]); } ///////////////////////////////////////////////////////////////////////////////////
            } //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
            if (buf.size()>0) { ////////////////////////////////////////////////////////////////////////////////////////////////////
                buf.push_back((char)0); ////////////////////////////////////////////////////////////////////////////////////////////
                words.push_back(std::string(&(buf[0]))); ///////////////////////////////////////////////////////////////////////////
                buf.resize(0) ; ////////////////////////////////////////////////////////////////////////////////////////////////////
            } //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
            ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        } //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        ~StringSplit () {} /////////////////////////////////////////////////////////////////////////////////////////////////////////
        ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

        ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        // Some convinent functions: ///////////////////////////////////////////////////////////////////////////////////////////////
        ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        inline std::string & operator [] (size_t i) {return words[i]     ; } ///////////////////////////////////////////////////////
        inline size_t        size        ()         {return words.size() ; } ///////////////////////////////////////////////////////
        inline std::string & operator () (size_t i) {return words[i]     ; } ///////////////////////////////////////////////////////
        inline size_t        operator () ()         {return words.size() ; } ///////////////////////////////////////////////////////
        ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

        ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        // Print the string: ///////////////////////////////////////////////////////////////////////////////////////////////////////
        ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        void show (std::string & in_line) { ////////////////////////////////////////////////////////////////////////////////////////
            std::vector <char> outline ; ///////////////////////////////////////////////////////////////////////////////////////////
            for(size_t i=0;i<words.size();i++) for(size_t j=0;j<words[i].size();j++) if(words[i][j]!=(char)0) {outline.push_back(words[i][j]);}
            outline.push_back((char)0); ////////////////////////////////////////////////////////////////////////////////////////////
            in_line = std::string( &(outline[0]) ); ////////////////////////////////////////////////////////////////////////////////
        } //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        inline void operator () (std::string & in_line) {show(in_line);} ///////////////////////////////////////////////////////////
        ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        void debug_show () { for (size_t i=0;i<words.size();i++) {printf("(%ld:%s)",i,&(words[i][0]));} } //////////////////////////
        ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

        ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    } ; ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

	class FileFD {

	private:

		std::string  filename  ;
		int          fd        ;
		struct stat  abtme     ;
		int          filemode  ;
		void        *mapped    ;
		size_t       maplength ;
		int          mmapprot  ;

		inline void
		construct (
			std::string const Afile =
			std::string("outfile")
		) {
			filename  = Afile      ;
		        fd        = -1         ;
			filemode  = -1         ;
			mapped    = MAP_FAILED ;
			mmapprot  = PROT_NONE  ;
			maplength = 0          ;
		}

	public:

		inline int
		closefile () {
			unmapfile()          ;
			filemode = -1        ;
			mmapprot = PROT_NONE ;
			if (fd<0) {return 0;}
			else {
				int const ret = close (fd) ;
				fd = -1 ;
				return ret ;
			}
		}

		inline void
		check_file_mode (
			int const newfilemode = -1
		) {
			if (filemode!=newfilemode) {
				closefile();
			}
			if (fd<0) {
				fd =
					open (
						static_cast<const char *>(&(filename[0])) ,
						newfilemode ,
						static_cast<mode_t>(0755)
					)
				; //
				filemode = newfilemode ;
			}
		}

		inline void
		readfile(){
			check_file_mode ( static_cast <int> (O_RDONLY) ) ;
			mmapprot = static_cast <int> (PROT_READ) ;
		}

		inline void
		writefile  () {
			check_file_mode (
				static_cast <int> ( O_WRONLY | O_CREAT | O_TRUNC )
			) ; //
			mmapprot =
				static_cast <int> (PROT_WRITE)
			; //
		}

		inline void
		appendfile () {
			check_file_mode (
				static_cast <int> ( O_RDWR | O_CREAT )
			) ; //
			mmapprot =
				static_cast <int> ( PROT_READ | PROT_WRITE )
			; //
		}

		inline void
		destroy () {
			closefile() ;
		}

		FileFD  ( const char *Afile ) { construct ( Afile ) ; }
		FileFD  (                   ) { construct (       ) ; }
		FileFD  ( std::string Afile ) { construct ( Afile ) ; }
		~FileFD (                   ) { destroy   (       ) ; }

		inline void
		reconstruct (
			std::string const Afile =
				std::string("outfile")
		) {
			destroy() ;
			construct (Afile) ;
		}

		inline void
		reconstruct (char const *Afile) {
			reconstruct (std::string(Afile)) ;
		}

		inline FileFD &
		operator () (
			std::string const name
		) {
			reconstruct(name) ;
			return (*this);
		}

		inline int
		truncatefile (
			off_t const length = 0
		) {
			return
				static_cast <int> (
					ftruncate ( fd , length )
				)
			;
		}

		inline off_t
		seekfile (
			off_t const offset = 0 ,
			int const whence = SEEK_CUR
		) {
			return
				static_cast<off_t>(
					lseek (
						fd , offset , whence
					)
				)
			; //
		}

		inline ssize_t
		read2file (
			void *buf = NULL ,
			size_t const count = 0
		) {
			return
				static_cast <ssize_t> (
					read (
						fd , buf , count
					)
				)
			; //
		}

		inline ssize_t
		write2file (
			const void *buf = NULL ,
			size_t const count = 0
		) {
			return
				static_cast <ssize_t> (
					write ( fd , buf , count )
				)
			; //
		}

		inline int
		info () {
			return
				static_cast <int> (
					fstat (
						fd ,
						static_cast<struct stat *>
							(&abtme)
					)
				)
			; //
		}

		inline off_t
		sizefile () {
			info() ;
			return
				static_cast<off_t>
					(abtme.st_size)
			;
		}

		inline std::string const &
		getfilename () const {
			return filename;
		}

		inline off_t
		operator () (
			off_t const offset = 0
		) {
			return seekfile ( offset ) ;
		}

		inline FileFD &
		operator [] (
			off_t const pos
		) {
			seekfile (
				static_cast<off_t>(pos) ,
				SEEK_SET
			) ;
			return (*this) ;
		}

		inline int
		getfd () const {
			return fd ;
		}

		inline void *
		mapfile (
			size_t const length,
			off_t const offset = 0
		) {
			if(
				(maplength==0) &&
				(mmapprot!=PROT_NONE) &&
				(mapped==MAP_FAILED)
			) {
				off_t const total_len = length + offset ;
				if (sizefile()<total_len) {truncatefile(total_len);}
				mapped =
					reinterpret_cast<void *>(
						mmap (
							reinterpret_cast<void *>(NULL)  ,
							length, mmapprot,
							static_cast<int>(MAP_SHARED) ,
							fd , offset
						)
					)
				; //
				if (mapped!=MAP_FAILED) {maplength=length;}
				else {printf("MMAP FAILED 1 !!! %s\n",&(filename[0]));}
			}
			else {printf("MMAP FAILED 2 !!!\n");}
			return mapped;
		}

		inline int
		unmapfile () {
			int ret = 0 ;
			if (
				(mapped!=MAP_FAILED) &&
				(maplength>0) &&
				(mmapprot!=PROT_NONE)
			) {
				ret =
					munmap (
						reinterpret_cast<void *>(mapped) ,
						reinterpret_cast<size_t>(maplength)
					)
				; //
				maplength = 0 ;
				mapped = MAP_FAILED ;
			}
			return ret;
		}

		inline size_t
		getmaplength () const {
			return maplength ;
		}

		template <typename T>
		inline ssize_t
		multiread2file (
			T & buf ,
			size_t const count = 1
		) {
			return
				read2file (
					reinterpret_cast<void *>(&buf) ,
					static_cast<size_t>(sizeof(T)*count)
				)
			;
		}

		template <typename T>
		inline ssize_t
		multiwrite2file (
			const T &buf ,
			size_t count = 1
		) {
			return
				write2file (
					reinterpret_cast<const void *> (&buf) ,
					static_cast<size_t>(sizeof(T)*count)
				)
			; //
		}

		template <typename T>
		inline ssize_t
		WriteVector (
			std::vector <T> const & out
		) {
			size_t const count = out.size() ;
			ssize_t writtensize = multiwrite2file (count) ;
			writtensize = writtensize + multiwrite2file (out[0],count) ;
			return writtensize;
		}

		template <typename T>
		inline ssize_t
		ReadVector (
			std::vector <T> & out
		) {
			size_t count = 0 ;
			size_t const oldsize = out.size() ;
			ssize_t writtensize = multiread2file (count) ;
			out.resize ( oldsize + count ) ;
			writtensize = multiread2file ( out[oldsize], count ) ;
			return writtensize;
		}

		inline ssize_t
		WriteString ( std::string const &out ) {
			size_t count       = out.size() ;
			ssize_t writtensize = multiwrite2file ( count ) ;
			writtensize = writtensize + multiwrite2file(out[0],count) ;
			return writtensize;
		}

		inline ssize_t operator >> ( char & out ) { return multiread2file (out) ; }
		inline ssize_t operator << ( char const out ) { return multiwrite2file ( out ) ; }
		inline ssize_t operator >> ( int & out ) { return multiread2file ( out ) ; }
		inline ssize_t operator << ( int const out ) { return multiwrite2file ( out ) ; }
		inline ssize_t operator >> ( float & out ) { return multiread2file ( out ) ; }
		inline ssize_t operator << ( float const out ) { return multiwrite2file ( out ) ; }
		inline ssize_t operator >> ( double & out ) { return multiread2file ( out ) ; }
		inline ssize_t operator << ( double const out ) { return multiwrite2file ( out ) ; }
		inline ssize_t operator >> ( long & out ) { return multiread2file ( out ) ; }
		inline ssize_t operator << ( long const out ) { return multiwrite2file ( out ) ; }
		inline ssize_t operator >> ( size_t & out ) { return multiread2file ( out ) ; }
		inline ssize_t operator << ( size_t const out ) { return multiwrite2file ( out ) ; }
		inline ssize_t operator << ( std::string const out ) { return WriteString ( out ) ; }

		template <typename T> inline ssize_t operator << ( std::vector <T> const & out ) { return WriteVector(out); }
		template <typename T> inline ssize_t operator >> ( std::vector <T> &out ) { return ReadVector (out); }
    };

    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Simple function for TRUE random number generation: //////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    double unique () { /////////////////////////////////////////////////////////////////////////////////////////////////////////////
        struct timespec timeout ; //////////////////////////////////////////////////////////////////////////////////////////////////
        clock_gettime(CLOCK_REALTIME,&timeout); ////////////////////////////////////////////////////////////////////////////////////
        double ret = (double) ( timeout.tv_sec + ( (double) timeout.tv_nsec / 1000000000 ) ) ; /////////////////////////////////////
        FileFD urandom((char *)"/dev/urandom"); ////////////////////////////////////////////////////////////////////////////////////
        urandom.readfile(); ////////////////////////////////////////////////////////////////////////////////////////////////////////
        double rnd ; ///////////////////////////////////////////////////////////////////////////////////////////////////////////////
        urandom >> rnd ; ///////////////////////////////////////////////////////////////////////////////////////////////////////////
        ret = ret * rnd ; //////////////////////////////////////////////////////////////////////////////////////////////////////////
        return ret;  ///////////////////////////////////////////////////////////////////////////////////////////////////////////////
    } //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    template <typename T> void GetUnique (T & Var) { double ptr = unique() ; Var=*((T*)&ptr); } ////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

	template <typename T>
	class FileArray {

	private:

		T * mainptr  ;

		size_t const sizes[4] = {
			4096 ,
			sizeof (T) ,
			LCM (sizes[0],sizes[1]) ,
			sizes[2] / sizes[1]
		} ; //

		std::string filename ;
		FileFD filefd ;
		size_t offset ;
		size_t begin, end, length ;
		size_t act_begin, act_end, act_length ;

	public:

		inline void
		construct (
			std::string const Afilename = std::string ("outfile") ,
			size_t const Aoffset = 0
		) {
			filename = Afilename ;
			filefd(filename).readfile() ;
			offset = Aoffset ;
			begin = 0 ; act_begin = 0 ;
			end = 0 ; act_end = 0 ;
			length = 0 ; act_length = 0 ;
		}

		inline void
		destroy () {
			filefd.destroy () ;
		}

		inline void
		reconstruct (
			std::string const Afilename = std::string ("outfile") ,
			size_t const Aoffset = 0
		) {
			destroy();
			construct(Afilename,Aoffset);
		}

		inline FileArray &
		operator () (
			std::string const Afilename = std::string ("outfile") ,
			size_t const Aoffset = 0
		) {
			reconstruct (Afilename,Aoffset) ;
			return (*this) ;
		}

		FileArray (
			std::string const Afilename = std::string ("outfile") ,
			size_t const Aoffset = 0
		) {
			construct(Afilename,Aoffset);
		}

		~FileArray () {destroy();}

		inline void
		writeable (bool const arg = true ) {
			if(arg) {filefd(filename).appendfile();}
			else {filefd(filename).readfile();}
		}

		inline void
		map (
			size_t const t_begin=0,
			size_t const t_length=1
		) {
			size_t const t_end = t_begin + t_length ;
			if ((t_begin<begin)||(t_end>end)) {
				/* Match to sector sizes: */ {
					begin =
						static_cast <size_t> (
							static_cast<double>(t_begin)/
							static_cast<double>(sizes[3])
						) * sizes[3]
					; //
					length =
						static_cast <size_t> (
							static_cast<double>(t_length) /
							static_cast<double>(sizes[3])
						)
					; //
					length++ ;
					length = length * sizes[3] ;
					end = begin + length ;
				}
				/* Reinitiate map: */ {
					filefd.unmapfile () ;
					mainptr =
						static_cast<T*>(
							filefd.mapfile (
								(length*sizes[1]) ,
								(begin*sizes[1]) + (offset*sizes[0])
							)
						)
					; //
				}
			}
		}

		inline T &
		operator () (
			size_t const A_begin=0 ,
			size_t const A_length=1
		) {
			map (A_begin,A_length) ;
			return mainptr [A_begin-begin] ;
		}

		inline off_t
		filesize () {
			return filefd.sizefile () ;
		}

		inline off_t
		size () {
			return
				filefd.sizefile ()
				/ sizes[1]
			; //
		}

		inline off_t
		size ( long const num ) {
			filefd.unmapfile();
			filefd.truncatefile(num*sizes[1]);
			return size();
		}

	};

	template <typename T>
	class FullFileReader {

	private:

		FileArray <T> MainReader ;
		size_t const limit ;
		T const * const ptr ;

	public:

		inline T const & operator () (size_t i) const { return ptr[i] ; }
	        inline size_t    operator () ()         const { return limit  ; }

		FullFileReader (
			std::string const filename
		)	: MainReader (filename)
			, limit (MainReader.size())
			, ptr (&(MainReader(0,limit)))
		{}

		~FullFileReader(){}

	} ;

#define _MACRO_CLASS_NAME_ FileWriter

	template <typename T>
	class _MACRO_CLASS_NAME_ {

	public:

		using TYPE_ELEMENT = T ;
		
		using TYPE_SELF =
			_MACRO_CLASS_NAME_ <TYPE_ELEMENT>
		; //

	private:

		FileArray <T> infile ;
		size_t count ;
		size_t const bufsize ;
		size_t const mask ;
		TYPE_ELEMENT * buf ;

	public:

		_MACRO_CLASS_NAME_ (
			std::string const name
			, size_t const _bufsize = 10
		)	: infile(name)
			, bufsize(shifter(_bufsize))
			, mask(bufsize-1)
		{	infile.writeable();
			count=0;
			infile.size(count);
		}

		~_MACRO_CLASS_NAME_ ()
		{infile.size(count);}

	private:

		inline size_t
		size() const
		{return count;}

	public:

		inline void
		push_back (
			TYPE_ELEMENT const &
				indata
		) {	size_t const mod 
				= count & mask
			; //
			if(mod==0){
				buf = & (infile(count,bufsize)) ;
			}
			buf[mod] = indata ;
			count++ ;
		}

		inline size_t
		operator () () const
		{return size();}

		inline void
		operator ()
		(TYPE_ELEMENT const & indata)
		{push_back(indata);}

	} ;

#undef _MACRO_CLASS_NAME_

	template <typename T>
	class FileVector {
	private:

		FileArray <T> infile ;
		size_t count ;

	public:

		FileVector (
			std::string const name
		) : infile(name) {
			infile.writeable();
			count=0;
			infile.size(count);
		}

		~FileVector() {
			infile.size(count);
		}

		inline size_t size() const {return count ;}
		inline void resize(size_t _size) {count=_size;}

		inline void
		push_back (T const & indata) {
			infile(count) = indata ;
			count++ ;
		}

		inline T &
		operator [] (size_t i)
		{return infile(i);}

	};


    ///////////////////////////////////////////////////////////////////
    ///////////////////////////////////////////////////////////////////
    ///////////////////////////////////////////////////////////////////
    template < typename T > class latexshow { /////////////////////////
        ///////////////////////////////////////////////////////////////
    private:
        ///////////////////////////////////////////////////////////////
        long power; ///////////////////////////////////////////////////
        T num; ////////////////////////////////////////////////////////
        T input; //////////////////////////////////////////////////////
        ///////////////////////////////////////////////////////////////
        inline void reduce () { ///////////////////////////////////////
            ///////////////////////////////////////////////////////////
            while ((-1<num) && (num<1) && (num!=0)) { /////////////////
                num = num * 10.0; /////////////////////////////////////
                power--; //////////////////////////////////////////////
            } /////////////////////////////////////////////////////////
            while ((num > 10) || (-10 > num)) { ///////////////////////
                num = num / 10.0; /////////////////////////////////////
                power++; //////////////////////////////////////////////
            } /////////////////////////////////////////////////////////
        } /////////////////////////////////////////////////////////////
        ///////////////////////////////////////////////////////////////
        inline char * show (char * b) { ///////////////////////////////
            ///////////////////////////////////////////////////////////
            if ( mymod(power) > limit ) { /////////////////////////////
                sprintf (b, "{$%.3lf \\times 10^{%ld}$}", num, power);
            } else { //////////////////////////////////////////////////
                sprintf (b, "{$%.3lf$}", input); //////////////////////
            } /////////////////////////////////////////////////////////
            return b ; ////////////////////////////////////////////////
        } /////////////////////////////////////////////////////////////
        ///////////////////////////////////////////////////////////////
    public:
        ///////////////////////////////////////////////////////////////
        size_t limit; /////////////////////////////////////////////////
        ///////////////////////////////////////////////////////////////
        latexshow (T a) { /////////////////////////////////////////////
            ///////////////////////////////////////////////////////////
            input = a; ////////////////////////////////////////////////
            num = a; //////////////////////////////////////////////////
            power = 0; ////////////////////////////////////////////////
            limit = 2; ////////////////////////////////////////////////
            reduce (); ////////////////////////////////////////////////
        } /////////////////////////////////////////////////////////////
        ///////////////////////////////////////////////////////////////
        ~latexshow () { ///////////////////////////////////////////////
        } /////////////////////////////////////////////////////////////
        ///////////////////////////////////////////////////////////////
        inline char * operator  () (char * b) { ///////////////////////
            return show (b); //////////////////////////////////////////
        } /////////////////////////////////////////////////////////////
        ///////////////////////////////////////////////////////////////

    }; ////////////////////////////////////////////////////////////////
    ///////////////////////////////////////////////////////////////////

    template <typename T>
    std::string showlatex (
        T a
    ) {
        latexshow <T> tmp(a) ;
        char buf[128] ;
        tmp(buf);
        std::string ret(buf);
        return buf;
    }

    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Class to Easily generate fancy looking tables: //////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    template <typename T> class flowtable { ////////////////////////////////////////////////////////////////////////////////////////
        ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    private:
        ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        size_t current ; ///////////////////////////////////////////////////////////////////////////////////////////////////////////
        ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        std::vector <T>           L     ; //////////////////////////////////////////////////////////////////////////////////////////
        std::vector <std::string> names ; //////////////////////////////////////////////////////////////////////////////////////////
        ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        void safefill ( size_t CLimit ) { //////////////////////////////////////////////////////////////////////////////////////////
            while ( L.size     () <= CLimit    ) { L.push_back     (0)                      ; } /////////////////////////////////////
            while ( names.size () <  L.size () ) { names.push_back (std::string("nothing")) ; } /////////////////////////////////////
        } //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        inline void safefill ()    { safefill (current) ; } ////////////////////////////////////////////////////////////////////////
        inline void namefill ()    { if (L.size()>0) { safefill (L.size()-1) ; } } /////////////////////////////////////////////////
        ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        inline void copyfrom ( const flowtable <T> & other ) { /////////////////////////////////////////////////////////////////////
            safefill (other.L.size()) ; ////////////////////////////////////////////////////////////////////////////////////////////
            memcpy ( (void*) &(L[0]) , (const void*) &(other.L[0]) , (size_t) sizeof(T) * L.size() ) ; /////////////////////////////
            current = other.current ; //////////////////////////////////////////////////////////////////////////////////////////////
        } //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        inline void startover () { current = 0 ; } /////////////////////////////////////////////////////////////////////////////////
        ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        inline void fill ( T val = 1 , std::string name = "noothing" ) { ///////////////////////////////////////////////////////////
            safefill () ; //////////////////////////////////////////////////////////////////////////////////////////////////////////
            L[current]     = L[current] + val ; ////////////////////////////////////////////////////////////////////////////////////
            names[current] = name             ; ////////////////////////////////////////////////////////////////////////////////////
            current++                         ; ////////////////////////////////////////////////////////////////////////////////////
        } //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        inline void fill ( bool val , std::string name = "nothing" ) { /////////////////////////////////////////////////////////////
            if (val) {fill(1,name);} ///////////////////////////////////////////////////////////////////////////////////////////////
            else     {fill(0,name);} ///////////////////////////////////////////////////////////////////////////////////////////////
        } //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        char * showhorizontal (std::string & linetitle) { //////////////////////////////////////////////////////////////////////////
            std::vector <std::string> parts ; /**/ { ///////////////////////////////////////////////////////////////////////////////
                std::string tmp = "\\hline " + linetitle + " &" ; //////////////////////////////////////////////////////////////////
                parts.push_back (tmp) ; ////////////////////////////////////////////////////////////////////////////////////////////
            } //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
            for(size_t i=0;i<L.size();i++){ ////////////////////////////////////////////////////////////////////////////////////////
                latexshow <T> tmplatex (L[i]) ; ////////////////////////////////////////////////////////////////////////////////////
                char tmpbuf [512] ; ////////////////////////////////////////////////////////////////////////////////////////////////
                tmplatex (tmpbuf) ; ////////////////////////////////////////////////////////////////////////////////////////////////
                if (i<L.size()-1) {parts.push_back(std::string(tmpbuf)+" &");} /////////////////////////////////////////////////////
                else {parts.push_back(std::string(tmpbuf)+" \\\\");} ///////////////////////////////////////////////////////////////
            } //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
            linetitle = parts[0] ; /////////////////////////////////////////////////////////////////////////////////////////////////
            for(size_t i=1;i<parts.size();i++){ ////////////////////////////////////////////////////////////////////////////////////
                linetitle = linetitle + parts[i] ; /////////////////////////////////////////////////////////////////////////////////
            } //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
            return &(linetitle[0]) ; ///////////////////////////////////////////////////////////////////////////////////////////////
        } //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        void showvals (std::vector <std::string> & outvals) { //////////////////////////////////////////////////////////////////////
            for(size_t i=0;i<L.size();i++) { ///////////////////////////////////////////////////////////////////////////////////////
                latexshow <double> tmpshow (L[i]) ; ////////////////////////////////////////////////////////////////////////////////
                char tmp[128] ; tmpshow(tmp) ; /////////////////////////////////////////////////////////////////////////////////////
                outvals.push_back(std::string(tmp)); ///////////////////////////////////////////////////////////////////////////////
            } //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        } //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    public:
        ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        inline void operator () () {startover();} //////////////////////////////////////////////////////////////////////////////////
        inline void operator () ( T    val , std::string name = "nothing" , bool inflag = true ) { /////////////////////////////////
            if   (inflag) { fill ( val  , name ) ; } ///////////////////////////////////////////////////////////////////////////////
            else          { fill ( (T)0 , name ) ; } ///////////////////////////////////////////////////////////////////////////////
        } //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        inline void operator () ( bool val , std::string name = "nothing" ) {fill(val,name);} //////////////////////////////////////
        inline char * operator () (std::string & linetitle) {return showhorizontal(linetitle);} ////////////////////////////////////
        inline size_t size() {return L.size();} ////////////////////////////////////////////////////////////////////////////////////
        inline T & operator [] (size_t i) {return L[i];} ///////////////////////////////////////////////////////////////////////////
        inline std::vector <std::string> & operator () (std::vector <std::string> & outvals) { /////////////////////////////////////
            showvals(outvals); /////////////////////////////////////////////////////////////////////////////////////////////////////
            return outvals; ////////////////////////////////////////////////////////////////////////////////////////////////////////
        } //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        inline size_t operator >> (CPPFileIO::FileFD & outfile) {return (outfile<<L);} /////////////////////////////////////////////
        inline size_t operator << (CPPFileIO::FileFD & outfile) {return (outfile>>L);} /////////////////////////////////////////////
        inline void operator = (const flowtable <T> & other) {copyfrom(other);} ////////////////////////////////////////////////////
        ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        void filewrite (std::string filename) { ////////////////////////////////////////////////////////////////////////////////////
            FILE *f = fopen (&(filename[0]),"w") ; /////////////////////////////////////////////////////////////////////////////////
            namefill(); ////////////////////////////////////////////////////////////////////////////////////////////////////////////
            size_t min_v = L.size(); ///////////////////////////////////////////////////////////////////////////////////////////////
            for (size_t i=0;i<min_v;i++) {fprintf(f," L [%ld] = %e \t : \t %s \n",i,(double)L[i],&(names[i][0]));} /////////////////
            fclose(f); /////////////////////////////////////////////////////////////////////////////////////////////////////////////
        } //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        flowtable() { //////////////////////////////////////////////////////////////////////////////////////////////////////////////
            L.clear(); /////////////////////////////////////////////////////////////////////////////////////////////////////////////
            current=0; /////////////////////////////////////////////////////////////////////////////////////////////////////////////
        } //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        flowtable (const flowtable & other) { //////////////////////////////////////////////////////////////////////////////////////
            copyfrom(other); ///////////////////////////////////////////////////////////////////////////////////////////////////////
            current=0; /////////////////////////////////////////////////////////////////////////////////////////////////////////////
        } //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        ~flowtable(){} /////////////////////////////////////////////////////////////////////////////////////////////////////////////
        ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    }; /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Printing the Tables: ////////////////////////////////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    class flowtables { /////////////////////////////////////////////////////////////////////////////////////////////////////////////
    private:
        FILE *f ;
    public:
        void operator () (std::string infile) {
            FileLines reader(infile);
            fprintf(f,"{|");
            for (size_t i=0;i<reader.size();i++) {fprintf(f,"c|");}
            fprintf(f,"}\n");
            for (size_t i=0;i<reader();i++) {
                if(i==0) {fprintf(f,"\\hline ");}
                else {fprintf(f,"& ");}
                fprintf(f,"%s",&(reader(i)[0]));
            }
            fprintf(f," \\\\ \n");
        }
        template <typename T> void operator () (flowtable <T> & intable, std::string eventtype) {
            fprintf(f,"%s\n",intable(eventtype));
        }
        flowtables  (FILE * _f) {f=_f;fprintf(f,"\\begin{tabular}");}
        ~flowtables ()          {fprintf(f,"\\hline \\end{tabular}\n");} ///////////////////////////////////////////////////////////
    }; /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    class LatexPrintMatrix {
    private:
        std::vector <std::string> elements ;
        size_t X, Y ;
        inline std::string & GetElement ( size_t x , size_t y ) {
            if(x>=X) {printf("BUG!!! out of bounds in x !!!\n");}
            if(y>=Y) {printf("BUG!!! out of bounds in y !!!\n");}
            return elements [x+(X*y)] ;
        }
        void Write2FILE ( FILE * f ) {
            fprintf(f,"\\begin{tabular}");
            for(size_t x=0;x<X;x++) {
                if(x==0){fprintf(f,"{|");}
                fprintf(f,"c|");
                if(x==(X-1)){fprintf(f,"}\n");}
            }
            for (size_t y=0;y<Y;y++) {
                for (size_t x=0;x<X;x++) {
                    if(x==0) {fprintf(f," \\hline %s ",&(GetElement(x,y)[0]));}
                    else     {fprintf(f," & %s ",&(GetElement(x,y)[0]));}
                }
                fprintf(f," \\\\ \n");
            }
            fprintf(f,"\\hline \\end{tabular}\n");
        }
        inline void Write2FILE ( std::string filename ) {
            FILE *f = fopen(&(filename[0]),"w");
            Write2FILE(f);
            fclose(f);
        }
    public:
        inline void operator () (std::vector <std::string> & x, size_t y) {
            size_t limit = mymin (x.size(),X) ;
            for(size_t i=0;i<limit;i++) {GetElement(i,y)=x[i];}
        }
        inline void operator () (size_t x, std::vector <std::string> & y) {
            size_t limit = mymin (y.size(),Y) ;
            for(size_t i=0;i<limit;i++) {GetElement(x,i)=y[i];}
        }
        inline void operator () (FileLines & x, size_t y) {
            size_t limit = mymin(x(),X);
            for(size_t i=0;i<limit;i++) {GetElement(i,y)=x(i);}
        }
        inline void operator () (size_t x, FileLines & y) {
            size_t limit = mymin(y(),Y);
            for(size_t i=0;i<limit;i++) {GetElement(x,i)=y(i);}
        }
        inline void operator () (FILE *f)              {Write2FILE(f);}
        inline void operator () (std::string filename) {Write2FILE(filename);}
        LatexPrintMatrix (size_t _X, size_t _Y) {
            X=_X;Y=_Y;
            elements.resize(X*Y);
        }
        ~LatexPrintMatrix(){}
    };
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Convinent multi threadable class for uniform double random number generation: ///////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    template <typename T> class myrandgen { ////////////////////////////////////////////////////////////////////////////////////////
        ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    private:
        ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        std::vector <T*> engines ; /////////////////////////////////////////////////////////////////////////////////////////////////
        std::uniform_real_distribution <double> dist ; /////////////////////////////////////////////////////////////////////////////
        ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        inline void allocate () { //////////////////////////////////////////////////////////////////////////////////////////////////
            std::random_device random_seeds ; //////////////////////////////////////////////////////////////////////////////////////
            for(size_t i=0;i<engines.size();i++) {engines[i]=new T(random_seeds());} ///////////////////////////////////////////////
        } //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    public:
        ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        double low, high ; /////////////////////////////////////////////////////////////////////////////////////////////////////////
        ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        myrandgen(size_t threads, double _low=0, double _high=1) : low(_low) , high(_high) , dist(_low,_high) { ////////////////////
            engines.resize(threads) ; //////////////////////////////////////////////////////////////////////////////////////////////
            allocate() ; ///////////////////////////////////////////////////////////////////////////////////////////////////////////
        } //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        ~myrandgen(){ //////////////////////////////////////////////////////////////////////////////////////////////////////////////
            for(size_t i=0;i<engines.size();i++) {delete engines[i];} //////////////////////////////////////////////////////////////
        } //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        inline double operator [] (size_t th) { ////////////////////////////////////////////////////////////////////////////////////
            double ret = dist(engines[th][0]) ; ////////////////////////////////////////////////////////////////////////////////////
            return ret ; ///////////////////////////////////////////////////////////////////////////////////////////////////////////
        } //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    } ; ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    class ToDir {
    private:
        std::string originaldir ;
        inline void godir (std::string dirname) {
            mkdir((const char*)&(dirname[0]),(mode_t)0755);
            chdir((const char*)&(dirname[0]));
        }
        bool goback ;
    public:
        inline void operator () (std::string dirname) {godir(dirname);}
        inline void operator () (const char *dirname) {godir(std::string(dirname));}
        inline void operator () (long innum) {
            char tmp[128] ;
            sprintf(tmp,"%ld",innum);
            godir(std::string(tmp));
        }
        inline void operator () () {godir(originaldir);}
        inline void showdir() {
            char tmp[1024] ;
            getcwd((char*)tmp,(size_t)1024);
            printf("%s\n",tmp);
        }
        inline std::string getoriginal () {return originaldir;}
        ToDir(bool _goback=false){
            goback = _goback ;
            char tmp[1024] ;
            getcwd((char*)tmp,(size_t)1024);
            originaldir = std::string(tmp);
            std::cout << originaldir << "\n" ;
        }
        ~ToDir(){if(goback){godir(originaldir);}}
    };

    template <typename T>
    class MemContainer {
    public:
        //
        T * const PTR ;
        T &       REF ;
        //
        MemContainer ( T * const _PTR ) :
        PTR(_PTR) , REF(PTR[0]) {}
        //
        ~MemContainer () { delete PTR ; }
        //
        inline T & operator () (size_t i)
            { return PTR [i] ; }
        //
    } ;

    template <typename T> inline
    MemContainer <T> GET_MemContainer
    ( T * a ) {
        MemContainer <T> ret (a) ;
        return ret ;
    }

	template <typename T>
	inline void
	SortFile (std::string const filename) {
		FileArray <T> buffer (filename) ;
		size_t const limit = buffer.size();
		buffer.writeable(true);
		T * data = & (buffer(0,limit) ) ;
		std::sort(&(data[0]),&(data[limit]));
		buffer.size(limit);
	}

	template <typename T>
	inline void
	MergeFile(
		std::string const file1 ,
		std::string const file2 ,
		std::string const fileo
	) {
		CPPFileIO::FileArray <T> reader1 (file1) ;
		CPPFileIO::FileArray <T> reader2 (file2) ;
		CPPFileIO::FileWriter <T> writer (fileo) ;
		size_t const limit1 = reader1.size() ;
		size_t const limit2 = reader2.size() ;
		size_t i1 = 0 ;
		size_t i2 = 0 ;
		while ( (i1<limit1) && (i2<limit2) ) {
			T const & V1 = reader1(i1) ;
			T const & V2 = reader2(i2) ;
			if (V1<V2) {
				writer(V1);
				i1++;
			} else {
				writer(V2);
				i2++;
			}
		}
		while(i1<limit1){
			writer(reader1(i1));
			i1++;
		}
		while(i2<limit2){
			writer(reader2(i2));
			i2++;
		}
	}

}
