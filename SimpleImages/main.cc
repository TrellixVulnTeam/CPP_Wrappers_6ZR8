#define USE_PYTHIA
#define USE_FASTJET
#define USE_ROOT
#include "./pcg.hh"
#include "./MainHeaders.hh"
#include "TH2F.h"

int main () {
    constexpr size_t N_Events = 10000 ;
    CPPFileIO::ForkMe forker ; // this is required for parallelism
// QCD, W and ttbar event sare generated in parallel.
    /* QCD Part: */ if(forker.InKid ()) { // The block which generates QCD part:
        Pythia8::Pythia pythia ; // declaring the main generator
        pythia.readString ( "Beams:eCM = 13000"         ) ; // configure the generator to have beam collision energy 13 TeV
        pythia.readString ( "HardQCD:all = on"          ) ; // generate QCD events
        pythia.readString ( "PhaseSpace:pTHatMin = 500" ) ; // minimum pt at the partonic level for the QCD jets
        pythia.init(); // initialize the generator
        fastjet::JetAlgorithm algo = fastjet::antikt_algorithm ; // anti-kt Algorithm used for jet clustering
        fastjet::JetDefinition def(algo,1.0) ; // Radius of jet is 1
        TH2F JetImages ("image","image",40,0,40,40,0,40) ; // Declare the histogram to fill and make jet images
        for(size_t ievent=0;ievent<N_Events;ievent++) // the event Generation loop (10000 events are generated for now)
        if (pythia.next()) { // Ensure the event generated by pythia is fine.
            //printf("ievent = %ld\n",ievent); // print the current event number being generated
            std::vector <fastjet::PseudoJet> FinalClusters ; // the list to hold the final stable 4 vectors to be clustered into jets
            for(size_t i=0;i<pythia.event.size();i++) // the event loop, this goes through each particle in the event
            if(pythia.event[i].isFinal()) { // only bother with final stable particles
                int pid = pythia.event[i].id() ; // get the particle id of the final particle
                if (pid<0) {pid=-pid;} // take the absolute value
                if((pid!=12)&&(pid!=14)&&(pid!=16)){ // ensure we are not clustering neutrinos.
                    fastjet::PseudoJet // extract the final 4 momentum information in a formate required for fastjet
                        tmp ( // we donot apply any pt or eta cut right now on the constituents to keep things simple
                            pythia.event[i].px(), // but this can be done easily later on.
                            pythia.event[i].py(), // fastjet expects ( x, y, z, t ) formate of four vectors contrary to the usual
                            pythia.event[i].pz(), // convention of ( t, x, y, z ) formate.
                            pythia.event[i].e()
                        )
                    ; //
                    FinalClusters.push_back(tmp); // record the 4 momentum vector into the list
                }
            }
            fastjet::ClusterSequence clus ( FinalClusters , def ) ; // for the jet clustering class of fastjet
            std::vector <fastjet::PseudoJet> jets = // get the clustered jets, a minimum pt cut of 600 GeV is applied
                    sorted_by_pt ( clus.inclusive_jets (600) ) // the jets are also sorted accoring to harder pt first
            ; //
            NewHEPHeaders::MyJetImageGen <40,float> images ; // Declaring the image forming class, (40,40) is the dimension of the 2D image and the values stored are floats
            if(jets.size()>0){ // Ensure that we have atleast 1 jet which satisfied the cuts on pt
                images(jets[0]); // form the image
                if(images.eventpass){ // Ensure the image was correctly formed (there were atleast 3 constituents in jet which is required for gram schmidt)
                    for(size_t y=0;y<images.MainStore.SIZE_Y();y++){
                        for(size_t x=0;x<images.MainStore.SIZE_X();x++){
                            JetImages.Fill(x,y,images.MainStore[y][x]); // fill the histogram and make the image
                        }
                    }
                }
            }
        }
        /* Draw and save the image: */ {
            TCanvas C;
            JetImages.Draw("colz"); // plot with fancy colors
            C.SaveAs("imageQCD.pdf"); // save as pdf file
        }
    }
    /* TOP Part: */ if(forker.InKid ()) { // This part evaluates the jet images for top, most of the lines are identical except for the event generation step
        Pythia8::Pythia pythia ;
        pythia.readString ( "Beams:eCM = 13000"         ) ;
        pythia.readString ( "Top:gg2ttbar = on"         ) ; // generate ttbar events
        pythia.readString ( "PhaseSpace:pTHatMin = 500" ) ;
        pythia.readString ( "24:onMode = off"           ) ; // force w to decay hadronically
        pythia.readString ( "24:onIfAny = 1 2 3 4 5"    ) ;
        pythia.init();
        fastjet::JetAlgorithm algo = fastjet::antikt_algorithm ;
        fastjet::JetDefinition def(algo,1.0) ;
        TH2F JetImages ("image","image",40,0,40,40,0,40) ;
        for(size_t ievent=0;ievent<N_Events;ievent++)
        if (pythia.next()) {
            //printf("ievent = %ld\n",ievent);
            std::vector <fastjet::PseudoJet> FinalClusters ;
            for(size_t i=0;i<pythia.event.size();i++)
            if(pythia.event[i].isFinal()) {
                int pid = pythia.event[i].id() ;
                if (pid<0) {pid=-pid;}
                if((pid!=12)&&(pid!=14)&&(pid!=16)){
                    fastjet::PseudoJet
                        tmp (
                            pythia.event[i].px(),
                            pythia.event[i].py(),
                            pythia.event[i].pz(),
                            pythia.event[i].e()
                        )
                    ; //
                    FinalClusters.push_back(tmp);
                }
            }
            fastjet::ClusterSequence clus ( FinalClusters , def ) ;
            std::vector <fastjet::PseudoJet> jets =
                    sorted_by_pt ( clus.inclusive_jets (600) )
            ; //
            NewHEPHeaders::MyJetImageGen <40,float> images ;
            if(jets.size()>0){
                images(jets[0]);
                if(images.eventpass){
                    for(size_t y=0;y<images.MainStore.SIZE_Y();y++){
                        for(size_t x=0;x<images.MainStore.SIZE_X();x++){
                            JetImages.Fill(x,y,images.MainStore[y][x]);
                        }
                    }
                }
            }
        }
        /* Draw and save the image: */ {
            TCanvas C;
            JetImages.Draw("colz");
            C.SaveAs("imageTOP.pdf");
        }
    }
    /* W Part:   */ if(forker.InKid ()) { // This part evaluates the jet images for W, most of the lines are identical except for the event generation step
        Pythia8::Pythia pythia ;
        pythia.readString ( "Beams:eCM = 13000"             ) ;
        pythia.readString ( "WeakDoubleBoson:ffbar2ZW = on" ) ; // generate W events
        pythia.readString ( "PhaseSpace:pTHatMin = 500"     ) ;
        pythia.readString ( "23:onMode = off"               ) ;
        pythia.readString ( "23:onIfAny = 12"               ) ;
        pythia.readString ( "24:onMode = off"               ) ;
        pythia.readString ( "24:onIfAny = 1 2 3 4"          ) ;
        pythia.init();
        fastjet::JetAlgorithm algo = fastjet::antikt_algorithm ;
        fastjet::JetDefinition def(algo,1.0) ;
        TH2F JetImages ("image","image",40,0,40,40,0,40) ;
        for(size_t ievent=0;ievent<N_Events;ievent++)
        if (pythia.next()) {
//            printf("ievent = %ld\n",ievent);
            std::vector <fastjet::PseudoJet> FinalClusters ;
            for(size_t i=0;i<pythia.event.size();i++)
            if(pythia.event[i].isFinal()) {
                int pid = pythia.event[i].id() ;
                if (pid<0) {pid=-pid;}
                if((pid!=12)&&(pid!=14)&&(pid!=16)){
                    fastjet::PseudoJet
                        tmp (
                            pythia.event[i].px(),
                            pythia.event[i].py(),
                            pythia.event[i].pz(),
                            pythia.event[i].e()
                        )
                    ; //
                    FinalClusters.push_back(tmp);
                }
            }
            fastjet::ClusterSequence clus ( FinalClusters , def ) ;
            std::vector <fastjet::PseudoJet> jets =
                    sorted_by_pt ( clus.inclusive_jets (600) )
            ; //
            NewHEPHeaders::MyJetImageGen <40,float> images ;
            if(jets.size()>0){
                images(jets[0]);
                if(images.eventpass){
                    for(size_t y=0;y<images.MainStore.SIZE_Y();y++){
                        for(size_t x=0;x<images.MainStore.SIZE_X();x++){
                            JetImages.Fill(x,y,images.MainStore[y][x]);
                        }
                    }
                }
            }
        }
        /* Draw and save the image: */ {
            TCanvas C;
            JetImages.Draw("colz");
            C.SaveAs("imageW.pdf");
        }
    }
    return 0 ;
}
