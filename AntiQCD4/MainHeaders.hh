#ifndef NewHEPHeaders2_HH
#define NewHEPHeaders2_HH

#ifdef USE_ALL
#define USE_PYTHIA
#define USE_FASTJET
#define USE_DELPHES
#define USE_ROOT
#endif

#ifndef CPPFileIO_HH
#define CPPFileIO_HH
#define _GNU_SOURCE

/////////////////////////
#include <sched.h> //////
/////////////////////////
#include <stdio.h> //////
#include <time.h>   /////
#include <stdlib.h> /////
#include <string.h> /////
#include <sys/types.h> //
#include <sys/wait.h> ///
#include <sys/stat.h> ///
#include <sys/mman.h> ///
#include <fcntl.h> //////
#include <unistd.h> /////
#include <math.h> ///////
#include <string.h> /////
/////////////////////////
#include <iostream> /////
#include <vector> ///////
#include <algorithm> ////
#include <random> ///////
#include <complex> //////
/////////////////////////

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
namespace CPPFileIO { //////////////////////////////////////////////////////////////////////////////////////////////////////////////

    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Pointer Management: /////////////////////////////////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    const char junk_address = 0 ; //////////////////////////////////////////////////////////////////////////////////////////////////
    const bool DEBUG = false; //////////////////////////////////////////////////////////////////////////////////////////////////////
    template <typename T> inline void set_junked  ( T * & inptr ) { inptr=(T*)(&junk_address);} ////////////////////////////////////
    template <typename T> inline bool is_junked   ( T * & inptr ) { return (inptr==(T*)(&junk_address));} //////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    template <typename T> inline bool safe_delete ( T * & inptr ) { ////////////////////////////////////////////////////////////////
        if (!is_junked(inptr)) { delete inptr; set_junked(inptr); return true; } else {return false;} //////////////////////////////
    } //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    template <typename T> inline bool safe_delete_array ( T * & inptr ) { //////////////////////////////////////////////////////////
        if (!is_junked(inptr)) { delete[] inptr; set_junked(inptr); return true; } else {return false;} ////////////////////////////
    } //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    inline size_t shifter  (size_t in) {return (1<<in);} ///////////////////////////////////////////////////////////////////////////
    inline bool   checkbit (size_t inbits, size_t checkbits) {return ((inbits&checkbits)==checkbits);} /////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    size_t NTHREADS = 4 ; //////////////////////////////////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Useful template functions : /////////////////////////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    template <typename T> inline T    mymod  ( T   a         ) { if (a<0) { return -a ; } else { return a ; } } ////////////////////
    template <typename T> inline T    mymax  ( T   a , T   b ) { if (a<b) { return  b ; } else { return a ; } } ////////////////////
    template <typename T> inline T    mymin  ( T   a , T   b ) { if (a<b) { return  a ; } else { return b ; } } ////////////////////
    template <typename T> inline T    mysign ( T   a         ) { if (a<0) { return -1 ; } else { return 1 ; } } ////////////////////
    template <typename T> inline void myswap ( T & a , T & b ) { T tmp = b ; b = a ; a = tmp ;                } ////////////////////
    template <typename T> inline long myint  ( T   x         ) { return (long) x ;                            } ////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Some simple and essential mathematics functions: ////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    template <typename T> inline T GCD (T a, T b) { ////////////////////////////////////////////////////////////////////////////////
        T ret ; ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        while( (a!=0) && (b!=0) ) { ////////////////////////////////////////////////////////////////////////////////////////////////
            if (a>b) { a = a % b ; ret = b ; } /////////////////////////////////////////////////////////////////////////////////////
            else     { b = b % a ; ret = a ; } /////////////////////////////////////////////////////////////////////////////////////
        } //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        return ret; ////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    } //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    template <typename T> inline T LCM (T a, T b) { ////////////////////////////////////////////////////////////////////////////////
        T ret ; ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        ret = GCD(a,b); ////////////////////////////////////////////////////////////////////////////////////////////////////////////
        if (ret>0) { ret = a * ( b / ret ) ; } /////////////////////////////////////////////////////////////////////////////////////
        return ret; ////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    } //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Some useful OS related functions : //////////////////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    void starter_self ( std::vector <std::string> & program ) { ////////////////////////////////////////////////////////////////////
        std::vector <char*> arrs ; /////////////////////////////////////////////////////////////////////////////////////////////////
        int j = program.size() ; ///////////////////////////////////////////////////////////////////////////////////////////////////
        arrs.resize(j+1); //////////////////////////////////////////////////////////////////////////////////////////////////////////
        for(int i=0;i<j;i++) { arrs[i] = & (program[i][0]) ; } /////////////////////////////////////////////////////////////////////
        arrs[j] = (char*) NULL ; ///////////////////////////////////////////////////////////////////////////////////////////////////
        execvp ( (const char *) arrs[0] , & (arrs[0]) ) ; //////////////////////////////////////////////////////////////////////////
    } //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    pid_t starter_fork ( std::vector <std::string> & program ) { ///////////////////////////////////////////////////////////////////
        pid_t tmp_pid = fork(); ////////////////////////////////////////////////////////////////////////////////////////////////////
        if (tmp_pid==0) { starter_self (program) ; } ///////////////////////////////////////////////////////////////////////////////
        else { return tmp_pid ; } //////////////////////////////////////////////////////////////////////////////////////////////////
        return tmp_pid ; ///////////////////////////////////////////////////////////////////////////////////////////////////////////
    } //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    void waitonall (std::vector <pid_t> childs) { //////////////////////////////////////////////////////////////////////////////////
        for(int i=0;i<childs.size();i++) { pid_t tmp = waitpid ( (pid_t) childs[i] , (int *) NULL , (int) 0 ) ; } //////////////////
    } //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    class GetArgs { ////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    private:
        ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    public:
        ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        std::vector <std::string> args ; ///////////////////////////////////////////////////////////////////////////////////////////
        ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        GetArgs  (int _argc, char ** _argv) {for(size_t i=0;i<_argc;i++){args.push_back(_argv[i]);}} ///////////////////////////////
        ~GetArgs ()                         {} /////////////////////////////////////////////////////////////////////////////////////
        ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        inline std::string & operator () (size_t i) { return args[i]      ; } //////////////////////////////////////////////////////
        inline size_t        operator () ()         { return args.size () ; } //////////////////////////////////////////////////////
        ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    }; /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Nice Class to handel forking: ///////////////////////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    class ForkMe { /////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        private: ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
            ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
            std::vector <pid_t> kids  ; ////////////////////////////////////////////////////////////////////////////////////////////
            bool                child ; ////////////////////////////////////////////////////////////////////////////////////////////
            size_t              kid_count ; ////////////////////////////////////////////////////////////////////////////////////////
            ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        public: ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
            ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
            inline bool WaitOnKids () { ////////////////////////////////////////////////////////////////////////////////////////////
                if      ( child           ) { exit (0)         ; return false ;               } ////////////////////////////////////
                else if ( kids.size() > 0 ) { waitonall (kids) ; kids.clear() ; return true ; } ////////////////////////////////////
                else                        { return false     ;                              } ////////////////////////////////////
                kid_count = 1 ; ////////////////////////////////////////////////////////////////////////////////////////////////////
            } //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
            ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
            ForkMe  () { kids.clear () ; child = false ; kid_count = 1 ; } /////////////////////////////////////////////////////////
            ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
            ~ForkMe () { if (child) { exit (0) ; } else { WaitOnKids () ; } } //////////////////////////////////////////////////////
            ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
            inline bool InKid () { /////////////////////////////////////////////////////////////////////////////////////////////////
                if (!child){ ///////////////////////////////////////////////////////////////////////////////////////////////////////
                    pid_t tmp_pid = fork () ; //////////////////////////////////////////////////////////////////////////////////////
                    if (tmp_pid==0) { child = true             ; return true  ; } //////////////////////////////////////////////////
                    else            { kids.push_back (tmp_pid) ; kid_count++ ; return false ; } ////////////////////////////////////
                } //////////////////////////////////////////////////////////////////////////////////////////////////////////////////
                else { exit (0) ; return false ; } /////////////////////////////////////////////////////////////////////////////////
            } //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
            ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
            inline void operator () (size_t _count=1) { ////////////////////////////////////////////////////////////////////////////
                if(kid_count>_count) { WaitOnKids () ; } ///////////////////////////////////////////////////////////////////////////
            } //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    }; /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    class starter { ////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    private:
        ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        // The main elements: //////////////////////////////////////////////////////////////////////////////////////////////////////
        ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        ForkMe forks ; /////////////////////////////////////////////////////////////////////////////////////////////////////////////
        ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    public:
        ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        // Constructor and Destructor: /////////////////////////////////////////////////////////////////////////////////////////////
        ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        starter  () {} /////////////////////////////////////////////////////////////////////////////////////////////////////////////
        ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        ~starter () {} /////////////////////////////////////////////////////////////////////////////////////////////////////////////
        ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

        ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        // The main functions: /////////////////////////////////////////////////////////////////////////////////////////////////////
        ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        void series (std::vector <std::string> & program) { ////////////////////////////////////////////////////////////////////////
            ForkMe tmp ; ///////////////////////////////////////////////////////////////////////////////////////////////////////////
            if(tmp.InKid()) {starter_self(program);} ///////////////////////////////////////////////////////////////////////////////
        } //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        void parallel (std::vector <std::string> & program) { //////////////////////////////////////////////////////////////////////
            if(forks.InKid()) {starter_self(program);} /////////////////////////////////////////////////////////////////////////////
        } //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        void wait () {forks.WaitOnKids();} /////////////////////////////////////////////////////////////////////////////////////////
        ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    }; /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // CPU AFFINITY RELATED: ///////////////////////////////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    inline void SetCPUAffinity (int cpunum) { //////////////////////////////////////////////////////////////////////////////////////
        cpu_set_t set; CPU_ZERO(&set); CPU_SET(cpunum, &set); //////////////////////////////////////////////////////////////////////
        if (sched_setaffinity(getpid(), sizeof(set), &set) == -1) {printf(" Error setting affinity...\n ");} ///////////////////////
    } //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Some functions to simplify handling vectors: ////////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    template <typename T> void clone_vector ( const std::vector <T> & src , std::vector <T> & dest ) { /////////////////////////////
        size_t n = src.size() ; ////////////////////////////////////////////////////////////////////////////////////////////////////
        dest.resize(n); ////////////////////////////////////////////////////////////////////////////////////////////////////////////
        (void *) memcpy ( (void *) &(dest[0]), (const void *) &(src[0]), (size_t) n*sizeof(T) ); ///////////////////////////////////
    } //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    template <typename T> void deduplicate (std::vector <T> & array) { /////////////////////////////////////////////////////////////
        std::vector <T> tmp_array ; ////////////////////////////////////////////////////////////////////////////////////////////////
        size_t SZ = array.size(); //////////////////////////////////////////////////////////////////////////////////////////////////
        if(SZ>1) { /////////////////////////////////////////////////////////////////////////////////////////////////////////////////
            std::sort(array.begin(),array.end()); tmp_array.push_back(array[0]); ///////////////////////////////////////////////////
            for(size_t i=1;i<SZ;i++) if(array[i]!=array[i-1]) {tmp_array.push_back(array[i]);} /////////////////////////////////////
            array.resize(tmp_array.size()) ; ///////////////////////////////////////////////////////////////////////////////////////
            memcpy ( (void *) &(array[0]) , (const void *) &(tmp_array[0]) , sizeof(T) * tmp_array.size() ) ; //////////////////////
        } //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    } //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Function to read a file line by line: ///////////////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    void getnames ( std::vector <std::string> & lines , std::string filename ) { ///////////////////////////////////////////////////
        lines.clear(); /////////////////////////////////////////////////////////////////////////////////////////////////////////////
        char *line=NULL; ///////////////////////////////////////////////////////////////////////////////////////////////////////////
        size_t len=0; //////////////////////////////////////////////////////////////////////////////////////////////////////////////
        ssize_t read; //////////////////////////////////////////////////////////////////////////////////////////////////////////////
        FILE *stream = fopen (&(filename[0]),"r") ; ////////////////////////////////////////////////////////////////////////////////
        while ((read = getline(&line, &len, stream)) != -1) { //////////////////////////////////////////////////////////////////////
            std::string linename(line); ////////////////////////////////////////////////////////////////////////////////////////////
            linename[linename.size()-1]=0; /////////////////////////////////////////////////////////////////////////////////////////
            lines.push_back(linename); /////////////////////////////////////////////////////////////////////////////////////////////
        } //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        if (len>0) {free(line);} ///////////////////////////////////////////////////////////////////////////////////////////////////
        fclose(stream); ////////////////////////////////////////////////////////////////////////////////////////////////////////////
    } //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    class FileLines { //////////////////////////////////////////////////////////////////////////////////////////////////////////////
    private:
        ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    public:
        ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        std::vector <std::string> lines    ; ///////////////////////////////////////////////////////////////////////////////////////
        std::string               filename ; ///////////////////////////////////////////////////////////////////////////////////////
        ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        FileLines  (std::string _filename) : filename(_filename) {getnames(lines,filename);} ///////////////////////////////////////
        ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        ~FileLines () {} ///////////////////////////////////////////////////////////////////////////////////////////////////////////
        ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        inline std::string & operator [] (size_t i) { return lines[i]      ; } /////////////////////////////////////////////////////
        inline size_t        size        ()         { return lines.size () ; } /////////////////////////////////////////////////////
        inline std::string & operator () (size_t i) { return lines[i]      ; } /////////////////////////////////////////////////////
        inline size_t        operator () ()         { return lines.size () ; } /////////////////////////////////////////////////////
        ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        inline void operator () (FILE *f) { for (size_t i=0;i<lines.size();i++) {fprintf(f,"%s\n",&(lines[i][0]));} } //////////////
        ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        void debug_show () { for (size_t i=0;i<lines.size();i++) {printf("%ld => [%s]\n",i,&(lines[i][0]));} } /////////////////////
        ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    }; /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    class StringSplit { ////////////////////////////////////////////////////////////////////////////////////////////////////////////
        ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    private:
        ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    public:
        ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

        ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        // The Main Data Elements: /////////////////////////////////////////////////////////////////////////////////////////////////
        ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        std::string               line    ; ////////////////////////////////////////////////////////////////////////////////////////
        std::vector <std::string> words   ; ////////////////////////////////////////////////////////////////////////////////////////
        char                      delimit ; ////////////////////////////////////////////////////////////////////////////////////////
        ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

        ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        // Important functions: ////////////////////////////////////////////////////////////////////////////////////////////////////
        ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        StringSplit  ( std::string _line = "" , char _delimit = ' ' ) : line(_line) , delimit(_delimit) { //////////////////////////
            std::vector <char> buf ; buf.reserve(line.size()) ; ////////////////////////////////////////////////////////////////////
            for (size_t i=0;i<line.size();i++) { ///////////////////////////////////////////////////////////////////////////////////
                if (line[i]==delimit) { ////////////////////////////////////////////////////////////////////////////////////////////
                    buf.push_back((char)0); ////////////////////////////////////////////////////////////////////////////////////////
                    words.push_back(std::string(&(buf[0]))); ///////////////////////////////////////////////////////////////////////
                    buf.resize(0) ; ////////////////////////////////////////////////////////////////////////////////////////////////
                    buf.push_back(line[i]); ////////////////////////////////////////////////////////////////////////////////////////
                    buf.push_back((char)0); ////////////////////////////////////////////////////////////////////////////////////////
                    words.push_back(std::string(&(buf[0]))); ///////////////////////////////////////////////////////////////////////
                    buf.resize(0) ; ////////////////////////////////////////////////////////////////////////////////////////////////
                } //////////////////////////////////////////////////////////////////////////////////////////////////////////////////
                else { buf.push_back(line[i]); } ///////////////////////////////////////////////////////////////////////////////////
            } //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
            if (buf.size()>0) { ////////////////////////////////////////////////////////////////////////////////////////////////////
                buf.push_back((char)0); ////////////////////////////////////////////////////////////////////////////////////////////
                words.push_back(std::string(&(buf[0]))); ///////////////////////////////////////////////////////////////////////////
                buf.resize(0) ; ////////////////////////////////////////////////////////////////////////////////////////////////////
            } //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
            ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        } //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        ~StringSplit () {} /////////////////////////////////////////////////////////////////////////////////////////////////////////
        ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

        ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        // Some convinent functions: ///////////////////////////////////////////////////////////////////////////////////////////////
        ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        inline std::string & operator [] (size_t i) {return words[i]     ; } ///////////////////////////////////////////////////////
        inline size_t        size        ()         {return words.size() ; } ///////////////////////////////////////////////////////
        inline std::string & operator () (size_t i) {return words[i]     ; } ///////////////////////////////////////////////////////
        inline size_t        operator () ()         {return words.size() ; } ///////////////////////////////////////////////////////
        ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

        ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        // Print the string: ///////////////////////////////////////////////////////////////////////////////////////////////////////
        ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        void show (std::string & in_line) { ////////////////////////////////////////////////////////////////////////////////////////
            std::vector <char> outline ; ///////////////////////////////////////////////////////////////////////////////////////////
            for(size_t i=0;i<words.size();i++) for(size_t j=0;j<words[i].size();j++) if(words[i][j]!=(char)0) {outline.push_back(words[i][j]);}
            outline.push_back((char)0); ////////////////////////////////////////////////////////////////////////////////////////////
            in_line = std::string( &(outline[0]) ); ////////////////////////////////////////////////////////////////////////////////
        } //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        inline void operator () (std::string & in_line) {show(in_line);} ///////////////////////////////////////////////////////////
        ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        void debug_show () { for (size_t i=0;i<words.size();i++) {printf("(%ld:%s)",i,&(words[i][0]));} } //////////////////////////
        ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

        ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    } ; ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // The Main and most important class for simplifying file handeling: ///////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    class FileFD { /////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    private:
        std::string  filename  ;
        int          fd        ;
        struct stat  abtme     ;
        int          filemode  ;
        void        *mapped    ;
        size_t       maplength ;
        int          mmapprot  ;

    public:
        void construct ( std::string Afile = std::string("outfile") ) {
            filename  = Afile      ;
            fd        = -1         ;
            filemode  = -1         ;
            mapped    = MAP_FAILED ;
            mmapprot  = PROT_NONE  ;
            maplength = 0          ;
        }
        int closefile () {
            unmapfile()          ;
            filemode = -1        ;
            mmapprot = PROT_NONE ;
            if (fd<0) {return 0;}
            else {
                int ret = (int) close ( (int) fd ) ;
                fd = -1 ;
                return ret ;
            }
        }
        inline void check_file_mode (int newfilemode = -1) {
            if (filemode!=newfilemode) {closefile();}
            if (fd<0) {
                fd = (int) open ( (const char *) &(filename[0]) , newfilemode , (mode_t) 0755 ) ;
                filemode = newfilemode ;
            }
        }
        inline void readfile   () { check_file_mode ( (int) O_RDONLY                     ) ; mmapprot = ( (int) PROT_READ               ) ; }
        inline void writefile  () { check_file_mode ( (int) O_WRONLY | O_CREAT | O_TRUNC ) ; mmapprot = ( (int) PROT_WRITE              ) ; }
        inline void appendfile () { check_file_mode ( (int) O_RDWR   | O_CREAT           ) ; mmapprot = ( (int) PROT_READ  | PROT_WRITE ) ; }
        inline void destroy    () { closefile       (                                    ) ;                                                }

        FileFD  ( const char *Afile ) { construct ( Afile ) ; }
        FileFD  (                   ) { construct (       ) ; }
        FileFD  ( std::string Afile ) { construct ( Afile ) ; }
        ~FileFD (                   ) { destroy   (       ) ; }

        void reconstruct (std::string Afile = std::string("outfile")) { destroy() ; construct (Afile) ; }
        void reconstruct (char *Afile) { reconstruct (std::string(Afile)) ; }
        inline FileFD & operator () ( std::string name ) { reconstruct(name) ; return (*this); }

        inline int truncatefile ( off_t length = 0 ) { return (int) ftruncate ( (int) fd , (off_t) length ) ; }
        inline off_t seekfile ( off_t offset = 0 , int whence = SEEK_CUR ) { return (off_t) lseek ( (int) fd , (off_t) offset , (int) whence ) ; }
        inline ssize_t read2file ( void *buf = NULL , size_t count = 0 ) { return (ssize_t) read ( (int) fd , ( void *) buf , (size_t) count ) ; }
        inline ssize_t write2file ( const void *buf = NULL , size_t count = 0 ) { return (ssize_t) write ( (int) fd , (const void *) buf , (size_t) count ) ; }
        inline int info () { return (int) fstat ( (int) fd , (struct stat *) &abtme ) ; }
        inline off_t sizefile () { info() ; return (off_t) abtme.st_size ; }
        inline std::string getfilename () { return filename; }
        inline off_t operator () ( off_t offset = 0 ) { return seekfile ( offset ) ; }
        inline FileFD & operator [] ( off_t pos ) { seekfile ( (off_t) pos , SEEK_SET ) ; return (*this) ; }
        inline int getfd () { return fd ; }

        void * mapfile ( size_t length, off_t offset = 0 ) {
            if( (maplength==0) && (mmapprot!=PROT_NONE) && (mapped==MAP_FAILED) ) {
                off_t total_len = length + offset ;
                if (sizefile()<total_len) {truncatefile(total_len);}
                mapped = (void *) mmap ( (void *) NULL , (size_t) length, (int) mmapprot , (int) MAP_SHARED , (int) fd , (off_t) offset );
                if (mapped!=MAP_FAILED) {maplength=length;}
                else {printf("MMAP FAILED 1 !!! %s\n",&(filename[0]));}
            }
            else {printf("MMAP FAILED 2 !!!\n");}
            return mapped;
        }

        int unmapfile () {
            int ret = 0 ;
            if ( (mapped!=MAP_FAILED) && (maplength>0) && (mmapprot!=PROT_NONE) ) {
                ret = (int) munmap ( (void *) mapped , (size_t) maplength ) ;
                maplength = 0 ;
                mapped = MAP_FAILED ;
            }
            return ret;
        }

        inline size_t getmaplength () { return maplength ; }

        template <typename T> inline ssize_t multiread2file  ( T &buf , size_t count = 1 ) { return read2file  ( (      void *) &buf , (size_t) sizeof(T) * count ) ; }
        template <typename T> inline ssize_t multiwrite2file ( const T &buf , size_t count = 1 ) { return write2file ( (const void *) &buf , (size_t) sizeof(T) * count ) ; }

        template <typename T> inline ssize_t WriteVector ( std::vector <T> &out ) {
            size_t count = out.size() ;
            ssize_t writtensize = multiwrite2file (count) ;
            writtensize = writtensize + multiwrite2file (out[0],count) ;
            return writtensize;
        }

        template <typename T> inline ssize_t ReadVector ( std::vector <T> &out ) {
            size_t count = 0 ;
            size_t oldsize = out.size() ;
            ssize_t writtensize = multiread2file (count) ;
            out.resize ( oldsize + count ) ;
            writtensize = multiread2file ( out[oldsize], count ) ;
            return writtensize;
        }

        inline ssize_t WriteString ( std::string &out ) {
            size_t count       = out.size() ;
            ssize_t writtensize = multiwrite2file ( count ) ;
            writtensize = writtensize + multiwrite2file(out[0],count) ;
            return writtensize;
        }

        inline ssize_t operator >> ( char      & out ) { return multiread2file  ( out ) ; }
        inline ssize_t operator << ( char        out ) { return multiwrite2file ( out ) ; }
        inline ssize_t operator >> ( int       & out ) { return multiread2file  ( out ) ; }
        inline ssize_t operator << ( int         out ) { return multiwrite2file ( out ) ; }
        inline ssize_t operator >> ( float     & out ) { return multiread2file  ( out ) ; }
        inline ssize_t operator << ( float       out ) { return multiwrite2file ( out ) ; }
        inline ssize_t operator >> ( double    & out ) { return multiread2file  ( out ) ; }
        inline ssize_t operator << ( double      out ) { return multiwrite2file ( out ) ; }
        inline ssize_t operator >> ( long      & out ) { return multiread2file  ( out ) ; }
        inline ssize_t operator << ( long        out ) { return multiwrite2file ( out ) ; }
        inline ssize_t operator >> ( size_t    & out ) { return multiread2file  ( out ) ; }
        inline ssize_t operator << ( size_t      out ) { return multiwrite2file ( out ) ; }
        inline ssize_t operator << ( std::string out ) { return WriteString     ( out ) ; }

        template <typename T> inline ssize_t operator << ( std::vector <T> &out ) { return WriteVector(out); }
        template <typename T> inline ssize_t operator >> ( std::vector <T> &out ) { return ReadVector (out); }
    }; /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Class for simplifying memory mapping and array handeling: ///////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    template <typename T> class FileArray { ////////////////////////////////////////////////////////////////////////////////////////
    private:
        T *mainptr  ;
        size_t sizes[4] ;
        std::string filename ;
        FileFD filefd ;
        size_t offset ;
        size_t begin, end, length ;
        size_t act_begin, act_end, act_length ;
    public:
        inline void construct ( std::string Afilename = std::string ("outfile") , size_t Aoffset = 0 ) {
            filename = Afilename ;
            filefd(filename).readfile() ;
            sizes[0] = 4096 ;
            sizes[1] = sizeof (T) ;
            sizes[2] = LCM (sizes[0],sizes[1]) ;
            sizes[3] = sizes[2] / sizes[1] ;
            offset = Aoffset ;
            begin = 0 ; act_begin = 0 ;
            end = 0 ; act_end = 0 ;
            length = 0 ; act_length = 0 ;
        }

        inline void destroy () { filefd.destroy () ; }
        inline void reconstruct ( std::string Afilename = std::string ("outfile") , size_t Aoffset = 0 ) { destroy(); construct(Afilename,Aoffset); }
        inline FileArray & operator () ( std::string Afilename = std::string ("outfile") , size_t Aoffset = 0 ) {
            reconstruct (Afilename,Aoffset) ;
            return (*this) ;
        }

        FileArray ( std::string Afilename = std::string ("outfile") , size_t Aoffset = 0 ) { construct(Afilename,Aoffset); }
        ~FileArray () {destroy();}

        inline void writeable ( bool arg = true ) {
            if(arg) {filefd(filename).appendfile();}
            else {filefd(filename).readfile();}
        }

        void map (size_t t_begin=0, size_t t_length=1) {
            size_t t_end = t_begin + t_length ;
            if ((t_begin<begin)||(t_end>end)) {
                /* Match to sector sizes: */ {
                    begin = myint ((double)t_begin/sizes[3]) ; begin = begin * sizes[3] ;
                    length = myint ((double)t_length/sizes[3]) ; length++ ; length = length * sizes[3] ;
                    end = begin + length ;
                }
                /* Reinitiate map: */ {
                    filefd.unmapfile () ;
                    mainptr = (T*) filefd.mapfile ( (length*sizes[1]) , (begin*sizes[1]) + (offset*sizes[0]) ) ;
                }
            }
        }

        inline T & operator () ( size_t A_begin=0 , size_t A_length=1 ) {
            map (A_begin,A_length) ;
            return mainptr [A_begin-begin] ;
        }

        inline off_t filesize () { return filefd.sizefile () ; }
        inline off_t size () { return filefd.sizefile () / sizes[1] ; }
        inline off_t size ( long num ) { filefd.unmapfile(); filefd.truncatefile(num*sizes[1]); return size(); }
    }; /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    template <typename T> class FullFileReader {
    private:
        FileArray <T> MainReader ;
        size_t limit ;
        T * ptr ;
    public:
        inline T const & operator () (size_t i) const { return ptr[i] ; }
        inline T       & operator () (size_t i)       { return ptr[i] ; }
        inline size_t    operator () ()         const { return limit  ; }
        FullFileReader (std::string filename) : MainReader(filename)
        { limit = MainReader.size() ; ptr = & (MainReader(0,limit)) ; }
    } ;
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    template <typename T> class FileVector { ///////////////////////////////////////////////////////////////////////////////////////
        ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    private:
        ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        FileArray <T> infile ; /////////////////////////////////////////////////////////////////////////////////////////////////////
        size_t count ; /////////////////////////////////////////////////////////////////////////////////////////////////////////////
        ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    public:
        ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        FileVector(std::string name): infile(name){ ////////////////////////////////////////////////////////////////////////////////
            infile.writeable(); ////////////////////////////////////////////////////////////////////////////////////////////////////
            count=0; ///////////////////////////////////////////////////////////////////////////////////////////////////////////////
            infile.size(count); ////////////////////////////////////////////////////////////////////////////////////////////////////
        } //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        ~FileVector(){infile.size(count);} /////////////////////////////////////////////////////////////////////////////////////////
        ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        inline size_t size() {return count ;} ////////////////////////////////////////////////////////////////////////////////
        inline void resize(size_t _size) {count=_size;} //////////////////////////////////////////////////////////////////////
        inline void push_back (T indata) { /////////////////////////////////////////////////////////////////////////////////////////
            infile(count) = indata ; ///////////////////////////////////////////////////////////////////////////////////////////////
            count++ ; //////////////////////////////////////////////////////////////////////////////////////////////////////////////
        } //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        inline T & operator [] (size_t i) {return infile(i);} //////////////////////////////////////////////////////////////////////
    }; /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    ///////////////////////////////////////////////////////////////////
    ///////////////////////////////////////////////////////////////////
    ///////////////////////////////////////////////////////////////////
    template < typename T > class latexshow { /////////////////////////
        ///////////////////////////////////////////////////////////////
    private:
        ///////////////////////////////////////////////////////////////
        long power; ///////////////////////////////////////////////////
        T num; ////////////////////////////////////////////////////////
        T input; //////////////////////////////////////////////////////
        ///////////////////////////////////////////////////////////////
        inline void reduce () { ///////////////////////////////////////
            ///////////////////////////////////////////////////////////
            while ((-1<num) && (num<1) && (num!=0)) { /////////////////
                num = num * 10.0; /////////////////////////////////////
                power--; //////////////////////////////////////////////
            } /////////////////////////////////////////////////////////
            while ((num > 10) || (-10 > num)) { ///////////////////////
                num = num / 10.0; /////////////////////////////////////
                power++; //////////////////////////////////////////////
            } /////////////////////////////////////////////////////////
        } /////////////////////////////////////////////////////////////
        ///////////////////////////////////////////////////////////////
        inline char * show (char * b) { ///////////////////////////////
            ///////////////////////////////////////////////////////////
            if ( mymod(power) > limit ) { /////////////////////////////
                sprintf (b, "{$%.3lf \\times 10^{%ld}$}", num, power);
            } else { //////////////////////////////////////////////////
                sprintf (b, "{$%.3lf$}", input); //////////////////////
            } /////////////////////////////////////////////////////////
            return b ; ////////////////////////////////////////////////
        } /////////////////////////////////////////////////////////////
        ///////////////////////////////////////////////////////////////
    public:
        ///////////////////////////////////////////////////////////////
        size_t limit; /////////////////////////////////////////////////
        ///////////////////////////////////////////////////////////////
        latexshow (T a) { /////////////////////////////////////////////
            ///////////////////////////////////////////////////////////
            input = a; ////////////////////////////////////////////////
            num = a; //////////////////////////////////////////////////
            power = 0; ////////////////////////////////////////////////
            limit = 2; ////////////////////////////////////////////////
            reduce (); ////////////////////////////////////////////////
        } /////////////////////////////////////////////////////////////
        ///////////////////////////////////////////////////////////////
        ~latexshow () { ///////////////////////////////////////////////
        } /////////////////////////////////////////////////////////////
        ///////////////////////////////////////////////////////////////
        inline char * operator  () (char * b) { ///////////////////////
            return show (b); //////////////////////////////////////////
        } /////////////////////////////////////////////////////////////
        ///////////////////////////////////////////////////////////////

    }; ////////////////////////////////////////////////////////////////
    ///////////////////////////////////////////////////////////////////

    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Class to Easily generate fancy looking tables: //////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    template <typename T> class flowtable { ////////////////////////////////////////////////////////////////////////////////////////
        ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    private:
        ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        size_t current ; ///////////////////////////////////////////////////////////////////////////////////////////////////////////
        ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        std::vector <T>           L     ; //////////////////////////////////////////////////////////////////////////////////////////
        std::vector <std::string> names ; //////////////////////////////////////////////////////////////////////////////////////////
        ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        void safefill ( size_t CLimit ) { //////////////////////////////////////////////////////////////////////////////////////////
            while ( L.size     () <= CLimit    ) { L.push_back     (0)                      ; } /////////////////////////////////////
            while ( names.size () <  L.size () ) { names.push_back (std::string("nothing")) ; } /////////////////////////////////////
        } //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        inline void safefill ()    { safefill (current) ; } ////////////////////////////////////////////////////////////////////////
        inline void namefill ()    { if (L.size()>0) { safefill (L.size()-1) ; } } /////////////////////////////////////////////////
        ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        inline void copyfrom ( const flowtable <T> & other ) { /////////////////////////////////////////////////////////////////////
            safefill (other.L.size()) ; ////////////////////////////////////////////////////////////////////////////////////////////
            memcpy ( (void*) &(L[0]) , (const void*) &(other.L[0]) , (size_t) sizeof(T) * L.size() ) ; /////////////////////////////
            current = other.current ; //////////////////////////////////////////////////////////////////////////////////////////////
        } //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        inline void startover () { current = 0 ; } /////////////////////////////////////////////////////////////////////////////////
        ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        inline void fill ( T val = 1 , std::string name = "noothing" ) { ///////////////////////////////////////////////////////////
            safefill () ; //////////////////////////////////////////////////////////////////////////////////////////////////////////
            L[current]     = L[current] + val ; ////////////////////////////////////////////////////////////////////////////////////
            names[current] = name             ; ////////////////////////////////////////////////////////////////////////////////////
            current++                         ; ////////////////////////////////////////////////////////////////////////////////////
        } //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        inline void fill ( bool val , std::string name = "nothing" ) { /////////////////////////////////////////////////////////////
            if (val) {fill(1,name);} ///////////////////////////////////////////////////////////////////////////////////////////////
            else     {fill(0,name);} ///////////////////////////////////////////////////////////////////////////////////////////////
        } //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        char * showhorizontal (std::string & linetitle) { //////////////////////////////////////////////////////////////////////////
            std::vector <std::string> parts ; /**/ { ///////////////////////////////////////////////////////////////////////////////
                std::string tmp = "\\hline " + linetitle + " &" ; //////////////////////////////////////////////////////////////////
                parts.push_back (tmp) ; ////////////////////////////////////////////////////////////////////////////////////////////
            } //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
            for(size_t i=0;i<L.size();i++){ ////////////////////////////////////////////////////////////////////////////////////////
                latexshow <T> tmplatex (L[i]) ; ////////////////////////////////////////////////////////////////////////////////////
                char tmpbuf [512] ; ////////////////////////////////////////////////////////////////////////////////////////////////
                tmplatex (tmpbuf) ; ////////////////////////////////////////////////////////////////////////////////////////////////
                if (i<L.size()-1) {parts.push_back(std::string(tmpbuf)+" &");} /////////////////////////////////////////////////////
                else {parts.push_back(std::string(tmpbuf)+" \\\\");} ///////////////////////////////////////////////////////////////
            } //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
            linetitle = parts[0] ; /////////////////////////////////////////////////////////////////////////////////////////////////
            for(size_t i=1;i<parts.size();i++){ ////////////////////////////////////////////////////////////////////////////////////
                linetitle = linetitle + parts[i] ; /////////////////////////////////////////////////////////////////////////////////
            } //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
            return &(linetitle[0]) ; ///////////////////////////////////////////////////////////////////////////////////////////////
        } //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        void showvals (std::vector <std::string> & outvals) { //////////////////////////////////////////////////////////////////////
            for(size_t i=0;i<L.size();i++) { ///////////////////////////////////////////////////////////////////////////////////////
                latexshow <double> tmpshow (L[i]) ; ////////////////////////////////////////////////////////////////////////////////
                char tmp[128] ; tmpshow(tmp) ; /////////////////////////////////////////////////////////////////////////////////////
                outvals.push_back(std::string(tmp)); ///////////////////////////////////////////////////////////////////////////////
            } //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        } //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    public:
        ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        inline void operator () () {startover();} //////////////////////////////////////////////////////////////////////////////////
        inline void operator () ( T    val , std::string name = "nothing" , bool inflag = true ) { /////////////////////////////////
            if   (inflag) { fill ( val  , name ) ; } ///////////////////////////////////////////////////////////////////////////////
            else          { fill ( (T)0 , name ) ; } ///////////////////////////////////////////////////////////////////////////////
        } //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        inline void operator () ( bool val , std::string name = "nothing" ) {fill(val,name);} //////////////////////////////////////
        inline char * operator () (std::string & linetitle) {return showhorizontal(linetitle);} ////////////////////////////////////
        inline size_t size() {return L.size();} ////////////////////////////////////////////////////////////////////////////////////
        inline T & operator [] (size_t i) {return L[i];} ///////////////////////////////////////////////////////////////////////////
        inline std::vector <std::string> & operator () (std::vector <std::string> & outvals) { /////////////////////////////////////
            showvals(outvals); /////////////////////////////////////////////////////////////////////////////////////////////////////
            return outvals; ////////////////////////////////////////////////////////////////////////////////////////////////////////
        } //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        inline size_t operator >> (CPPFileIO::FileFD & outfile) {outfile<<L;} //////////////////////////////////////////////////////
        inline size_t operator << (CPPFileIO::FileFD & outfile) {outfile>>L;} //////////////////////////////////////////////////////
        inline void operator = (const flowtable <T> & other) {copyfrom(other);} ////////////////////////////////////////////////////
        ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        void filewrite (std::string filename) { ////////////////////////////////////////////////////////////////////////////////////
            FILE *f = fopen (&(filename[0]),"w") ; /////////////////////////////////////////////////////////////////////////////////
            namefill(); ////////////////////////////////////////////////////////////////////////////////////////////////////////////
            size_t min_v = L.size(); ///////////////////////////////////////////////////////////////////////////////////////////////
            for (size_t i=0;i<min_v;i++) {fprintf(f," L [%ld] = %e \t : \t %s \n",i,(double)L[i],&(names[i][0]));} /////////////////
            fclose(f); /////////////////////////////////////////////////////////////////////////////////////////////////////////////
        } //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        flowtable() { //////////////////////////////////////////////////////////////////////////////////////////////////////////////
            L.clear(); /////////////////////////////////////////////////////////////////////////////////////////////////////////////
            current=0; /////////////////////////////////////////////////////////////////////////////////////////////////////////////
        } //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        flowtable (const flowtable & other) { //////////////////////////////////////////////////////////////////////////////////////
            copyfrom(other); ///////////////////////////////////////////////////////////////////////////////////////////////////////
            current=0; /////////////////////////////////////////////////////////////////////////////////////////////////////////////
        } //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        ~flowtable(){} /////////////////////////////////////////////////////////////////////////////////////////////////////////////
        ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    }; /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Printing the Tables: ////////////////////////////////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    class flowtables { /////////////////////////////////////////////////////////////////////////////////////////////////////////////
    private:
        FILE *f ;
    public:
        void operator () (std::string infile) {
            FileLines reader(infile);
            fprintf(f,"{|");
            for (size_t i=0;i<reader.size();i++) {fprintf(f,"c|");}
            fprintf(f,"}\n");
            for (size_t i=0;i<reader();i++) {
                if(i==0) {fprintf(f,"\\hline ");}
                else {fprintf(f,"& ");}
                fprintf(f,"%s",&(reader(i)[0]));
            }
            fprintf(f," \\\\ \n");
        }
        template <typename T> void operator () (flowtable <T> & intable, std::string eventtype) {
            fprintf(f,"%s\n",intable(eventtype));
        }
        flowtables  (FILE * _f) {f=_f;fprintf(f,"\\begin{tabular}");}
        ~flowtables ()          {fprintf(f,"\\hline \\end{tabular}\n");} ///////////////////////////////////////////////////////////
    }; /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    class LatexPrintMatrix {
    private:
        std::vector <std::string> elements ;
        size_t X, Y ;
        inline std::string & GetElement ( size_t x , size_t y ) {
            if(x>=X) {printf("BUG!!! out of bounds in x !!!\n");}
            if(y>=Y) {printf("BUG!!! out of bounds in y !!!\n");}
            return elements [x+(X*y)] ;
        }
        void Write2FILE ( FILE * f ) {
            fprintf(f,"\\begin{tabular}");
            for(size_t x=0;x<X;x++) {
                if(x==0){fprintf(f,"{|");}
                fprintf(f,"c|");
                if(x==(X-1)){fprintf(f,"}\n");}
            }
            for (size_t y=0;y<Y;y++) {
                for (size_t x=0;x<X;x++) {
                    if(x==0) {fprintf(f," \\hline %s ",&(GetElement(x,y)[0]));}
                    else     {fprintf(f," & %s ",&(GetElement(x,y)[0]));}
                }
                fprintf(f," \\\\ \n");
            }
            fprintf(f,"\\hline \\end{tabular}\n");
        }
        inline void Write2FILE ( std::string filename ) {
            FILE *f = fopen(&(filename[0]),"w");
            Write2FILE(f);
            fclose(f);
        }
    public:
        inline void operator () (std::vector <std::string> & x, size_t y) {
            size_t limit = mymin (x.size(),X) ;
            for(size_t i=0;i<limit;i++) {GetElement(i,y)=x[i];}
        }
        inline void operator () (size_t x, std::vector <std::string> & y) {
            size_t limit = mymin (y.size(),Y) ;
            for(size_t i=0;i<limit;i++) {GetElement(x,i)=y[i];}
        }
        inline void operator () (FileLines & x, size_t y) {
            size_t limit = mymin(x(),X);
            for(size_t i=0;i<limit;i++) {GetElement(i,y)=x(i);}
        }
        inline void operator () (size_t x, FileLines & y) {
            size_t limit = mymin(y(),Y);
            for(size_t i=0;i<limit;i++) {GetElement(x,i)=y(i);}
        }
        inline void operator () (FILE *f)              {Write2FILE(f);}
        inline void operator () (std::string filename) {Write2FILE(filename);}
        LatexPrintMatrix (size_t _X, size_t _Y) {
            X=_X;Y=_Y;
            elements.resize(X*Y);
        }
        ~LatexPrintMatrix(){}
    };
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Convinent multi threadable class for uniform double random number generation: ///////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    template <typename T> class myrandgen { ////////////////////////////////////////////////////////////////////////////////////////
        ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    private:
        ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        std::vector <T*> engines ; /////////////////////////////////////////////////////////////////////////////////////////////////
        std::uniform_real_distribution <double> dist ; /////////////////////////////////////////////////////////////////////////////
        ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        inline void allocate () { //////////////////////////////////////////////////////////////////////////////////////////////////
            std::random_device random_seeds ; //////////////////////////////////////////////////////////////////////////////////////
            for(size_t i=0;i<engines.size();i++) {engines[i]=new T(random_seeds());} ///////////////////////////////////////////////
        } //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    public:
        ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        double low, high ; /////////////////////////////////////////////////////////////////////////////////////////////////////////
        ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        myrandgen(size_t threads, double _low=0, double _high=1) : low(_low) , high(_high) , dist(_low,_high) { ////////////////////
            engines.resize(threads) ; //////////////////////////////////////////////////////////////////////////////////////////////
            allocate() ; ///////////////////////////////////////////////////////////////////////////////////////////////////////////
        } //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        ~myrandgen(){ //////////////////////////////////////////////////////////////////////////////////////////////////////////////
            for(size_t i=0;i<engines.size();i++) {delete engines[i];} //////////////////////////////////////////////////////////////
        } //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        inline double operator [] (size_t th) { ////////////////////////////////////////////////////////////////////////////////////
            double ret = dist(engines[th][0]) ; ////////////////////////////////////////////////////////////////////////////////////
            return ret ; ///////////////////////////////////////////////////////////////////////////////////////////////////////////
        } //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    } ; ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    class ToDir {
    private:
        std::string originaldir ;
        inline void godir (std::string dirname) {
            mkdir((const char*)&(dirname[0]),(mode_t)0755);
            chdir((const char*)&(dirname[0]));
        }
        bool goback ;
    public:
        inline void operator () (std::string dirname) {godir(dirname);}
        inline void operator () (const char *dirname) {godir(std::string(dirname));}
        inline void operator () (long innum) {
            char tmp[128] ;
            sprintf(tmp,"%ld",innum);
            godir(std::string(tmp));
        }
        inline void operator () () {godir(originaldir);}
        inline void showdir() {
            char tmp[1024] ;
            getcwd((char*)tmp,(size_t)1024);
            printf("%s\n",tmp);
        }
        inline std::string getoriginal () {return originaldir;}
        ToDir(bool _goback=false){
            goback = _goback ;
            char tmp[1024] ;
            getcwd((char*)tmp,(size_t)1024);
            originaldir = std::string(tmp);
            std::cout << originaldir << "\n" ;
        }
        ~ToDir(){if(goback){godir(originaldir);}}
    };

    template <typename T>
    class MemContainer {
    public:
        //
        T * const PTR ;
        T &       REF ;
        //
        MemContainer ( T * const _PTR ) :
        PTR(_PTR) , REF(PTR[0]) {}
        //
        ~MemContainer () { delete PTR ; }
        //
        inline T & operator () (size_t i)
            { return PTR [i] ; }
        //
    } ;

    template <typename T> inline
    MemContainer <T> GET_MemContainer
    ( T * a ) {
        MemContainer <T> ret (a) ;
        return ret ;
    }


} //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#ifdef USECBLAS
#include "cblas.h"
#endif

#ifdef USEPCG
#include "pcg.hh"
#endif

namespace Tensors {
    class Nothing {
    public:
        Nothing(){}
        ~Nothing(){}
    } ;
    ////////////////////////////////////////////////////////////////
    namespace NN /* 1 D Array */ {
        template <size_t X, typename T=float>
        class ND_ARRAY {
        public:
            typedef T TYPE_DATA ;
            //
            inline static constexpr size_t
                SIZE() {return X;}
            //
            typedef ND_ARRAY <SIZE(),TYPE_DATA>
                TYPE_SELF ;
            //
        private:
            TYPE_DATA DATA[SIZE()] ;
        private:
            ////////////////////////////////////////////////////////////////
            inline void Add ( const TYPE_SELF & other ) {
                for ( size_t x = 0 ; x < SIZE() ; x++ )
                { DATA[x] += other.DATA[x] ; }
            }
            //
            inline void Sub ( const TYPE_SELF & other ) {
                for ( size_t x = 0 ; x < SIZE() ; x++ )
                { DATA[x] -= other.DATA[x] ; }
            }
            //
            inline void Mul ( const TYPE_SELF & other ) {
                for ( size_t x = 0 ; x < SIZE() ; x++ )
                { DATA[x] *= other.DATA[x] ; }
            }
            //
            inline void Div ( const TYPE_SELF & other ) {
                for ( size_t x = 0 ; x < SIZE() ; x++ )
                { DATA[x] /= other.DATA[x] ; }
            }
            ////////////////////////////////////////////////////////////////
            inline void Add ( const TYPE_DATA & other ) {
                for ( size_t x = 0 ; x < SIZE() ; x++ )
                { DATA[x] += other ; }
            }
            //
            inline void Sub ( const TYPE_DATA & other ) {
                for ( size_t x = 0 ; x < SIZE() ; x++ )
                { DATA[x] -= other ; }
            }
            //
            inline void Mul ( const TYPE_DATA & other ) {
                for ( size_t x = 0 ; x < SIZE() ; x++ )
                { DATA[x] *= other ; }
            }
            //
            inline void Div ( const TYPE_DATA & other ) {
                for ( size_t x = 0 ; x < SIZE() ; x++ )
                { DATA[x] /= other ; }
            }
            //
            inline void Eqt ( const TYPE_DATA & other ) {
                for ( size_t x = 0 ; x < SIZE() ; x++ )
                { DATA[x] = other ; }
            }
            ////////////////////////////////////////////////////////////////
            inline TYPE_DATA Dot
            ( const TYPE_SELF & other ) const {
                double ret = 0 ;
                for ( size_t i = 0 ; i < SIZE() ; i++ )
                { ret += DATA[i] * other.DATA[i] ; }
                return ret ;
            }
            ////////////////////////////////////////////////////////////////
            inline void * CopyFrom
            ( const void * __restrict__ other ) {
                return (void *) memcpy (
                    (       void * ) /* dest = */ DATA  ,
                    ( const void * ) /* src  = */ other ,
                    (     size_t   ) /* n    = */ sizeof (TYPE_SELF)
                ) ;
            }
            //
            inline void * CopyFrom
            ( const TYPE_DATA * __restrict__ other ) {
                return CopyFrom (
                    ( const void * )
                        /* other = */ other
                ) ;
            }
            //
            inline void * CopyFrom
            ( const TYPE_SELF other ) {
                return CopyFrom (
                    ( const TYPE_DATA * )
                        /* other = */ other.DATA
                ) ;
            }
            ////////////////////////////////////////////////////////////////
        public:
            ////////////////////////////////////////////////////////////////
            inline void operator +=
            ( const TYPE_SELF & other )
            { Add (other) ; }
            //
            inline void operator -=
            ( const TYPE_SELF & other )
            { Sub (other) ; }
            //
            inline void operator *=
            ( const TYPE_SELF & other )
            { Mul (other) ; }
            //
            inline void operator /=
            ( const TYPE_SELF & other )
            { Div (other) ; }
            //
            ////////////////////////////////////////////////////////////////
            inline void operator +=
            ( const TYPE_DATA & other )
            { Add (other) ; }
            //
            inline void operator -=
            ( const TYPE_DATA & other )
            { Sub (other) ; }
            //
            inline void operator *=
            ( const TYPE_DATA & other )
            { Mul (other) ; }
            //
            inline void operator /=
            ( const TYPE_DATA & other )
            { Div (other) ; }
            //
            inline void operator  =
            ( const TYPE_DATA & other )
            { Eqt (other) ; }
            ////////////////////////////////////////////////////////////////
            //
            inline TYPE_SELF & FLATTEN ()
            { return this[0] ; }
            //
            inline TYPE_SELF const &
            FLATTEN () const
            { return this[0] ; }
            //
            inline void GET_SQUARED
            ( const TYPE_SELF & other ) {
                for ( size_t x = 0 ; x < SIZE() ; x++ )
                { DATA[x] = other.DATA[x] * other.DATA[x] ; }
            }
            //
            inline TYPE_DATA operator *
            ( const TYPE_SELF & other ) const
            { return Dot (other) ; }
            //
            inline TYPE_DATA &
            operator [] (size_t x)
            { return DATA[x] ; }
            //
            inline TYPE_DATA const
            operator [] (size_t x) const
            { return DATA[x] ; }
            //
            inline TYPE_DATA *
            GET_DATA () {
                return reinterpret_cast
                    < TYPE_DATA * > ( DATA ) ;
            }
            //
            inline TYPE_DATA const *
            GET_DATA () const {
                return reinterpret_cast
                    < TYPE_DATA const * > ( DATA ) ;
            }
            //
            inline TYPE_DATA L1_NORM () const {
                TYPE_DATA Ret = 0 ;
                for ( size_t i = 0 ; i < SIZE () ; i++ )
                { Ret += CPPFileIO::mymod (DATA[i]) ; }
                return Ret ;
            }
            //
            inline TYPE_DATA L2_NORM () const {
                TYPE_DATA Ret = 0 ;
                for ( size_t i = 0 ; i < SIZE () ; i++ )
                { Ret += ( DATA[i] * DATA[i] ) ; }
                return Ret ;
            }
            //
        } ;
    }
    namespace NN /* 2 D Array */ {
        template <size_t Y, size_t X, typename T=float>
        class N2D_ARRAY :
        public ND_ARRAY <Y,ND_ARRAY<X,T>> {
        public:
            //
            typedef T TYPE_DATA   ;
            inline static constexpr
                size_t SIZE_X ()
                { return X;}
            //
            inline static constexpr
                size_t SIZE_Y ()
                { return Y;}
            //
            inline static constexpr
                size_t SIZE ()
                { return SIZE_X() * SIZE_Y() ; }
            //
            typedef ND_ARRAY <SIZE(),TYPE_DATA>
                TYPE_FLATTEN ;
            //
            inline TYPE_FLATTEN const & FLATTEN () const {
                return reinterpret_cast
                    < TYPE_FLATTEN const & >
                    ( this[0] ) ;
            }
            //
            inline TYPE_FLATTEN & FLATTEN () {
                return reinterpret_cast
                    < TYPE_FLATTEN & >
                    ( this[0] ) ;
            }
            //
            typedef N2D_ARRAY <
                SIZE_Y() ,
                SIZE_X() ,
                TYPE_DATA
            > TYPE_SELF ;
            //
            typedef ND_ARRAY <
                SIZE_Y() ,
                ND_ARRAY < SIZE_X() , TYPE_DATA >
            > TYPE_PARENT ;
            //
            inline void GET_SQUARED
            ( TYPE_SELF const & other ) {
                FLATTEN().GET_SQUARED
                    (other.FLATTEN()) ;
                //
            }
            //
            inline void operator =
            (TYPE_DATA const & a)
            { FLATTEN() = a ; }
            //
            inline void operator +=
            (TYPE_DATA const & a)
            { FLATTEN() += a ; }
            //
            inline void operator -=
            (TYPE_DATA const & a)
            { FLATTEN() -= a ; }
            //
            inline void operator *=
            (TYPE_DATA const & a)
            { FLATTEN() *= a ; }
            //
            inline void operator /=
            (TYPE_DATA const & a)
            { FLATTEN() /= a ; }
            //
            inline TYPE_DATA const
            L1_NORM () const
            { return FLATTEN().L1_NORM() ; }
            //
            inline TYPE_DATA const
            L2_NORM () const
            { return FLATTEN().L2_NORM() ; }
            //
            inline TYPE_DATA *
            GET_DATA ()
            { return FLATTEN().GET_DATA(); }
            //
            inline TYPE_DATA const *
            GET_DATA () const
            { return FLATTEN().GET_DATA(); }
            //
        } ;
    }
    namespace NN /* 3 D Array */ {
        template <
            size_t Z,
            size_t Y,
            size_t X,
            typename T=float
        > class N3D_ARRAY : public
        ND_ARRAY <Z,N2D_ARRAY<Y,X,T>> {
        public:
            //
            typedef T TYPE_DATA   ;
            inline static constexpr
                size_t SIZE_X ()
                { return X;}
            //
            inline static constexpr
                size_t SIZE_Y ()
                { return Y;}
            //
            inline static constexpr
                size_t SIZE_Z ()
                { return Z;}
            //
            inline static constexpr
            size_t SIZE () {
                return
                    SIZE_X() *
                    SIZE_Y() *
                    SIZE_Z() ;
                //
            }
            //
            typedef ND_ARRAY <
                SIZE(),
                TYPE_DATA
            > TYPE_FLATTEN ;
            //
            inline TYPE_FLATTEN const &
            FLATTEN () const {
                return reinterpret_cast
                    < TYPE_FLATTEN const & >
                    ( this[0] ) ;
            }
            //
            inline TYPE_FLATTEN &
            FLATTEN () {
                return reinterpret_cast
                    < TYPE_FLATTEN & >
                    ( this[0] ) ;
            }
            //
            typedef N3D_ARRAY <
                SIZE_Z()  ,
                SIZE_Y()  ,
                SIZE_X()  ,
                TYPE_DATA
            > TYPE_SELF   ;
            //
            typedef ND_ARRAY <
                SIZE_Z(),
                N2D_ARRAY <
                    SIZE_Y(),
                    SIZE_X(),
                    TYPE_DATA
                >
            > TYPE_PARENT ;
            //
            inline void GET_SQUARED
            ( TYPE_SELF const & other ) {
                FLATTEN().GET_SQUARED
                    (other.FLATTEN()) ;
                //
            }
            //
            inline void operator =
            (TYPE_DATA const & a)
            { FLATTEN() = a ; }
            //
            inline void operator +=
            (TYPE_DATA const & a)
            { FLATTEN() += a ; }
            //
            inline void operator -=
            (TYPE_DATA const & a)
            { FLATTEN() -= a ; }
            //
            inline void operator *=
            (TYPE_DATA const & a)
            { FLATTEN() *= a ; }
            //
            inline void operator /=
            (TYPE_DATA const & a)
            { FLATTEN() /= a ; }
            //
            inline TYPE_DATA const
            L1_NORM () const {
                return
                    FLATTEN()
                    .L1_NORM() ;
                //
            }
            //
            inline TYPE_DATA const
            L2_NORM () const {
                return
                    FLATTEN()
                    .L2_NORM() ;
                //
            }
            //
            inline TYPE_DATA *
            GET_DATA () {
                return
                    FLATTEN()
                    .GET_DATA();
                //
            }
            //
            inline TYPE_DATA const *
            GET_DATA () const {
                return
                    FLATTEN()
                    .GET_DATA();
                //
            }
            //
        } ;
    }
    ////////////////////////////////////////////////////////////////
    namespace FUNCTIONS /* The neural network multiplication function: */ {
        using namespace NN ;
        // Function to evaluate neural network activation:
        template <
            size_t B , size_t   Y ,
            size_t X , typename T
        > inline void NeuralMultiply (
            N2D_ARRAY < B , Y , T >       & Output ,
            N2D_ARRAY < Y , X , T > const & Weight ,
            N2D_ARRAY < B , X , T > const & Input ,
            ND_ARRAY  < Y ,     T > const & Bias
        ) {
            for(size_t b=0;b<B;b++)
            { Output[b] = Bias ; }
            //
            for(size_t y=0;y<Y;y++){
                for(size_t b=0;b<B;b++){
                    for(size_t x=0;x<X;x++){
                        Output[b][y] +=
                            Weight[y][x] * Input[b][x] ;
                    }
                }
            }
            //
        }
        #ifdef CBLAS_H
        template <
            size_t B ,
            size_t Y ,
            size_t X
        > inline void
        NeuralMultiply (
            N2D_ARRAY < B , Y , double >       & Output ,
            N2D_ARRAY < Y , X , double > const & Weight ,
            N2D_ARRAY < B , X , double > const & Input  ,
            ND_ARRAY  < Y ,     double > const & Bias
        ) {
            for(size_t b=0;b<B;b++)
            { Output[b] = Bias ; }
            //
            cblas_dgemm (
                CblasRowMajor, CblasNoTrans, CblasTrans,
                (const int) /*M=*/B, (const int) /*N=*/Y, (const int) /*K=*/X,
                (const double) /*alpha=*/1.0,
                (const double *) Input.GET_DATA(), (const int) /*ldb=*/X,
                (const double *) Weight.GET_DATA(), (const int) /*lda=*/X,
                (const double) /*beta=*/1.0,
                (double *) Output.GET_DATA(), (const int) /*ldc=*/Y
            ) ;
            //
        }
        template <
            size_t B ,
            size_t Y ,
            size_t X
        > inline void
        NeuralMultiply (
            N2D_ARRAY < B , Y , float >       & Output ,
            N2D_ARRAY < Y , X , float > const & Weight ,
            N2D_ARRAY < B , X , float > const & Input  ,
            ND_ARRAY  < Y ,     float > const & Bias
        ) {
            for(size_t b=0;b<B;b++)
            { Output[b] = Bias ; }
            //
            cblas_sgemm (
                CblasRowMajor, CblasNoTrans, CblasTrans,
                (const int) /*M=*/B, (const int) /*N=*/Y, (const int) /*K=*/X,
                (const float) /*alpha=*/1.0,
                (const float *) Input.GET_DATA(), (const int) /*ldb=*/X,
                (const float *) Weight.GET_DATA(), (const int) /*lda=*/X,
                (const float) /*beta=*/1.0,
                (float *) Output.GET_DATA(), (const int) /*ldc=*/Y
            ) ;
            //
        }
        #endif
    }
    namespace FUNCTIONS /* Defining EvalW for Backpropagation: */ {
        // Functions for evaluating changes in weight:
        template <
            size_t Y , size_t   X ,
            size_t B , typename T
        > inline void EvalW (
            N2D_ARRAY <Y,X,T>       & DW    ,
            N2D_ARRAY <B,Y,T> const & Delta ,
            N2D_ARRAY <B,X,T> const & Input
        ) {
            for(size_t b=0;b<B;b++){
                for(size_t y=0;y<Y;y++){
                    for(size_t x=0;x<X;x++) {
                        DW[y][x] +=
                            Delta[b][y] * Input[b][x] ;
                    }
                }
            }
        }
        #ifdef CBLAS_H
        template <
            size_t Y ,
            size_t X ,
            size_t B
        > inline void EvalW (
            N2D_ARRAY < Y , X , float >       & DW    ,
            N2D_ARRAY < B , Y , float > const & Delta ,
            N2D_ARRAY < B , X , float > const & Input
        ) {
            cblas_sgemm (
                CblasRowMajor, CblasTrans, CblasNoTrans,
                (const int) /*M=*/Y, (const int) /*N=*/X, (const int) /*K=*/B,
                (const float) /*alpha=*/1.0,
                (const float *) Delta.GET_DATA(), (const int) /*lda=*/Y,
                (const float *) Input.GET_DATA(), (const int) /*ldb=*/X,
                (const float) /*beta=*/1.0,
                (float *) DW.GET_DATA(), (const int) /*ldc=*/X
            ) ;
        }
        template <
            size_t Y ,
            size_t X ,
            size_t B
        > inline void EvalW (
            N2D_ARRAY < Y , X , double >       & DW    ,
            N2D_ARRAY < B , Y , double > const & Delta ,
            N2D_ARRAY < B , X , double > const & Input
        ) {
            cblas_dgemm (
                CblasRowMajor, CblasTrans, CblasNoTrans,
                (const int) /*M=*/Y, (const int) /*N=*/X, (const int) /*K=*/B,
                (const double) /*alpha=*/1.0,
                (const double *) Delta.GET_DATA(), (const int) /*lda=*/Y,
                (const double *) Input.GET_DATA(), (const int) /*ldb=*/X,
                (const double) /*beta=*/1.0,
                (double *) DW.GET_DATA(), (const int) /*ldc=*/X
            ) ;
        }
        #endif
    }
    namespace FUNCTIONS /* Defining the DELTA_PRIME evaluation: */ {
        // function to evaluate DELTA_PRIME of the back propagation chain:
        template <
            size_t   B , size_t   X ,
            size_t   Y , typename T
        > inline void BackProp (
            N2D_ARRAY <B,X,T>       & DeltaPrime ,
            N2D_ARRAY <B,Y,T> const & Delta      ,
            N2D_ARRAY <Y,X,T> const & Weight
        ) {
            DeltaPrime = 0 ;
            for(size_t b=0;b<B;b++){
                for(size_t y=0;y<Y;y++){
                    for(size_t x=0;x<X;x++){
                        DeltaPrime[b][x] +=
                            Delta[b][y] * Weight[y][x] ;
                    }
                }
            }
        }
        #ifdef CBLAS_H
        template <
            size_t B ,
            size_t X ,
            size_t Y
        > inline void BackProp (
            N2D_ARRAY < B , X , float >       & DeltaPrime ,
            N2D_ARRAY < B , Y , float > const & Delta      ,
            N2D_ARRAY < Y , X , float > const & Weight
        ) {
            cblas_sgemm (
                CblasRowMajor, CblasNoTrans, CblasNoTrans,
                (const int) /*M=*/B, (const int) /*N=*/X, (const int) /*K=*/Y,
                (const float) /*alpha=*/1.0,
                (const float *) Delta.GET_DATA(), (const int) /*lda=*/Y,
                (const float *) Weight.GET_DATA(), (const int) /*ldb=*/X,
                (const float) /*beta=*/0,
                (float *) DeltaPrime.GET_DATA(), (const int) /*ldc=*/X
            );
        }
        template <
            size_t B ,
            size_t X ,
            size_t Y
        > inline void BackProp (
            N2D_ARRAY < B , X , double >       & DeltaPrime ,
            N2D_ARRAY < B , Y , double > const & Delta      ,
            N2D_ARRAY < Y , X , double > const & Weight
        ) {
            cblas_dgemm (
                CblasRowMajor, CblasNoTrans, CblasNoTrans,
                (const int) /*M=*/B, (const int) /*N=*/X , (const int) /*K=*/Y,
                (const double) /*alpha=*/1.0 ,
                (const double *) Delta.GET_DATA () , (const int) /*lda=*/Y,
                (const double *) Weight.GET_DATA () , (const int) /*ldb=*/X,
                (const double) /*beta=*/0,
                (double *) DeltaPrime.GET_DATA () , (const int) /*ldc=*/X
            );
        }
        #endif
    }
    namespace FUNCTIONS /* The Gradient Propagator: */ {
        template <
            size_t   B , size_t   M ,
            size_t   Y , size_t   X ,
            typename T
        > inline void
        GRAD_PROPAGATE (
            N3D_ARRAY < B , Y , M , T >       & OK ,
            N2D_ARRAY < Y , X ,     T > const & WK ,
            N3D_ARRAY < B , X , M , T > const & IK
        ) {
            OK=0.0;
            for(size_t b=0;b<B;b++){
                for(size_t y=0;y<Y;y++){
                    for(size_t x=0;x<X;x++){
                        for(size_t m=0;m<M;m++){
                            OK[b][y][m] +=
                                WK[y][x]    *
                                IK[b][x][m] ;
                            //
                        }
                    }
                }
            }
        }
        //
        #ifdef CBLAS_H
        template <
            size_t   B , size_t   M ,
            size_t   Y , size_t   X
        > inline void
        GRAD_PROPAGATE (
            N3D_ARRAY < B , Y , M , float >       & OK ,
            N2D_ARRAY < Y , X ,     float > const & WK ,
            N3D_ARRAY < B , X , M , float > const & IK
        ) {
            for(size_t b=0;b<B;b++){
                cblas_sgemm (
                    CblasRowMajor, CblasNoTrans, CblasNoTrans,
                    (const int) /*M=*/Y, (const int) /*N=*/M, (const int) /*K=*/X,
                    (const float) /*alpha=*/1.0,
                    (const float *) WK.GET_DATA(), (const int) /*lda=*/X,
                    (const float *) IK[b].GET_DATA(), (const int) /*ldb=*/M,
                    (const float) /*beta=*/0,
                    (float *) OK[b].GET_DATA(), (const int) /*ldc=*/M
                ) ;
            }
        }
        template <
            size_t   B , size_t   M ,
            size_t   Y , size_t   X
        > inline void
        GRAD_PROPAGATE (
            N3D_ARRAY < B , Y , M , double >       & OK ,
            N2D_ARRAY < Y , X ,     double > const & WK ,
            N3D_ARRAY < B , X , M , double > const & IK
        ) {
            for(size_t b=0;b<B;b++){
                cblas_dgemm (
                    CblasRowMajor, CblasNoTrans, CblasNoTrans,
                    (const int) /*M=*/Y, (const int) /*N=*/M, (const int) /*K=*/X,
                    (const double) /*alpha=*/1.0,
                    (const double *) WK.GET_DATA(), (const int) /*lda=*/X,
                    (const double *) IK[b].GET_DATA(), (const int) /*ldb=*/M,
                    (const double) /*beta=*/0,
                    (double *) OK[b].GET_DATA(), (const int) /*ldc=*/M
                ) ;
            }
        }
        #endif
        //
        template <
            size_t   B , size_t   M ,
            size_t   Y , size_t   X ,
            typename T
        > inline void
        GRAD_PROPAGATE (
            N3D_ARRAY < B , Y , M , T >       & OK ,
            N2D_ARRAY < Y , X ,     T > const & WK ,
            bool                        const   IK
        ) {
            for(size_t b=0;b<B;b++){
                OK[b] = WK ;
                //
            }
        }
    }
    ////////////////////////////////////////////////////////////////
    namespace FUNCTIONS /* Show Functions */ {
        template <size_t Y, typename T>
        inline void ShowMatrix
        ( ND_ARRAY <Y,T> const & in ) {
            for (size_t y=0;y<Y;y++) {
                printf("%e ",in[y]);
            }
            printf("\n");
        }
        template <size_t Y, size_t X, typename T>
        inline void ShowMatrix
        ( N2D_ARRAY <Y,X,T> const & in ) {
            for (size_t y=0;y<Y;y++) {
                for (size_t x=0;x<X;x++) {
                    printf("%e ",in[y][x]);
                }
                printf("\n");
            }
        }
    }
    ////////////////////////////////////////////////////////////////
    namespace FUNCTIONS /* Show Functions */ {
        template <size_t Y, typename T>
        inline void ShowMatrix
        ( ND_ARRAY <Y,std::complex<T>> const & in ) {
            for (size_t y=0;y<Y;y++) {
                printf("(%e,%e) ",in[y].real(),in[y].imag());
            }
            printf("\n");
        }
        template <size_t Y, size_t X, typename T>
        inline void ShowMatrix
        ( N2D_ARRAY <Y,X,std::complex<T>> const & in ) {
            for (size_t y=0;y<Y;y++) {
                for (size_t x=0;x<X;x++) {
                    printf("(%e,%e) ",in[y][x].real(),in[y][x].imag());
                }
                printf("\n");
            }
        }
    }
    ////////////////////////////////////////////////////////////////
    namespace NN /* PARAMETER */ {
        template <size_t Y, size_t X, typename T>
        class PARAMETER {
        public:
            //
            typedef T TYPE_DATA   ;
            //
            inline static constexpr size_t
            SIZE_X ()
            { return X ; }
            //
            inline static constexpr size_t
            SIZE_Y ()
            { return Y ; }
            //
            inline static size_t constexpr
            SIZE ()
            { return SIZE_X() * SIZE_Y() ; }
            //
            typedef PARAMETER
            < SIZE_Y() , SIZE_X() , TYPE_DATA >
            TYPE_SELF ;
            //
            typedef N2D_ARRAY
            < SIZE_Y() , SIZE_X() , TYPE_DATA >
            TYPE_WEIGHT ;
            //
            typedef ND_ARRAY
            < SIZE_Y() , TYPE_DATA >
            TYPE_BIAS ;
            //
            inline TYPE_DATA &
                operator ()
                ( size_t y , size_t x )
                { return WEIGHT[y][x] ; }
            //
            inline TYPE_DATA const
                operator ()
                ( size_t y , size_t x ) const
                { return WEIGHT[y][x] ; }
            //
            inline TYPE_DATA &
                operator () (size_t y)
                { return BIAS[y] ; }
            //
            inline TYPE_DATA const
                operator () (size_t y) const
                { return BIAS[y] ; }
            //
            inline void RANDOMIZE () {
                //
                constexpr TYPE_DATA Var =
                    2.0 /
                    ((TYPE_DATA)SIZE_X()+SIZE_Y()) ;
                //
                std::normal_distribution
                    <double> dist (0.0,Var) ;
                //
                #ifdef PCG_RAND_HPP_INCLUDED
                    pcg64_fast engine ;
                #else
                    std::mt19937 engine ;
                #endif
                //
                for ( size_t y = 0 ; y < Y ; y++ ) {
                    for ( size_t x = 0 ; x < X ; x++ )
                    { WEIGHT[y][x] = dist(engine) ; }
                }
                for ( size_t y = 0 ; y < Y ; y++ )
                { BIAS[y] = dist(engine) ; }
                //
            }
            //
            inline void RELEASE_LOCK ()
            { pthread_mutex_unlock (&lock) ; }
            //
            inline void ACQUIRE_LOCK ()
            { pthread_mutex_lock (&lock) ; }
            //
            inline void operator =
                (TYPE_DATA const & a)
                { WEIGHT = a ; BIAS = a ; }
            //
            inline void operator /=
                (TYPE_DATA const & a)
                { WEIGHT /= a ; BIAS /= a ; }
            //
            inline void operator *=
                (TYPE_DATA const & a)
                { WEIGHT *= a ; BIAS *= a ; }
            //
            inline void operator +=
                (TYPE_DATA const & a)
                { WEIGHT += a ; BIAS += a ; }
            //
            inline void operator -=
                (TYPE_DATA const & a)
                { WEIGHT -= a ; BIAS -= a ; }
            //
            inline void operator =
            (TYPE_SELF const & other) {
                WEIGHT = other.WEIGHT ;
                BIAS = other.BIAS ;
            }
            //
        private:
            //
            inline ssize_t WriteToFile
            (CPPFileIO::FileFD & file) const {
                ssize_t ret = 0 ;
                ret += file.multiwrite2file
                    ( WEIGHT ) ;
                //
                ret += file.multiwrite2file
                    ( BIAS ) ;
                //
                return ret;
            }
            //
            inline ssize_t WriteToFile
            (std::string filename) const {
                CPPFileIO::FileFD Writer
                    (filename) ;
                //
                Writer.writefile();
                return WriteToFile(Writer);
            }
            //
            inline ssize_t ReadFromFile
            (CPPFileIO::FileFD & file) {
                ssize_t ret = 0 ;
                ret += file.multiread2file
                    ( WEIGHT ) ;
                //
                ret += file.multiread2file
                    (   BIAS ) ;
                //
                return ret;
            }
            //
            inline ssize_t ReadFromFile
            (std::string filename) {
                CPPFileIO::FileFD Reader
                    (filename) ;
                //
                Reader.readfile();
                return ReadFromFile(Reader);
            }
            //
        public:
            //
            inline ssize_t operator >>
            ( CPPFileIO::FileFD & file ) const
            { return WriteToFile  (file) ; }
            //
            inline ssize_t operator <<
            ( CPPFileIO::FileFD & file )
            { return ReadFromFile (file) ; }
            //
            inline ssize_t operator >>
            ( std::string filename ) const
            { return WriteToFile (filename) ; }
            //
            inline ssize_t operator <<
            ( std::string filename )
            { return ReadFromFile (filename) ; }
            //
            TYPE_WEIGHT     WEIGHT ;
            TYPE_BIAS       BIAS   ;
            //
        private:
            pthread_mutex_t lock   ;
        } ;
    }
    namespace NN /* PARAMETER_ADAM */ {
        template <typename T>
        class PARAMETER_ADAM : public T {
        public:
            //
            typedef T TYPE_PARENT ;
            //
            PARAMETER_ADAM  () {
                Beta[0] = GET_BETA1 () ;
                Beta[1] = GET_BETA2 () ;
                M=0;V=0;
            }
            //
            typedef PARAMETER_ADAM
                <TYPE_PARENT> TYPE_SELF ;
            //
        private:
            //
            typedef typename TYPE_PARENT::TYPE_DATA
                TMP_TYPE_DATA ;
            //
        public:
            //
            inline static constexpr
            TMP_TYPE_DATA GET_BETA1 ()
            { return 0.90 ; }
            //
            inline static constexpr
            TMP_TYPE_DATA GET_BETA2 ()
            { return 0.99 ; }
            //
            inline static constexpr
            TMP_TYPE_DATA Eps ()
            { return 0.001 ; }
            //
        private:
            //
            template <typename InType>
            inline void AddParameter (
                InType              & DST ,
                InType        const & SRC ,
                TMP_TYPE_DATA const   beta
            ) {
                auto const & TMP_SRC = SRC.FLATTEN() ;
                auto       & TMP_DST = DST.FLATTEN() ;
                constexpr size_t limit = InType::SIZE();
                for(size_t i=0;i<limit;i++) {
                    TMP_DST[i] =
                        (beta*TMP_DST[i]) +
                        ((1.0-beta)*TMP_SRC[i]) ;
                }
            }
            //
            inline void AddBoth (
                TYPE_PARENT         & DST  ,
                TYPE_PARENT   const & SRC  ,
                TMP_TYPE_DATA const   beta
            ) {
                AddParameter (
                    DST.WEIGHT ,
                    SRC.WEIGHT ,
                    beta
                ) ;
                AddParameter (
                    DST.BIAS ,
                    SRC.BIAS ,
                    beta
                ) ;
            }
            //
            template <typename InType>
            inline void Apply (
                InType              & DST  ,
                InType        const & SRCM ,
                InType        const & SRCV ,
                TMP_TYPE_DATA const   Eta
            ) {
                constexpr size_t limit = InType::SIZE();
                auto       &  dst = DST.FLATTEN  () ;
                auto const & srcm = SRCM.FLATTEN () ;
                auto const & srcv = SRCV.FLATTEN () ;
                //
                for (size_t i=0;i<limit;i++) {
                    dst[i] = dst[i] - (
                        Eta * srcm[i] /
                        ( Eps() + sqrt(srcv[i]) )
                    ) ;
                }
                //
            }
            //
            inline void ApplyBoth (
                TYPE_PARENT         & DST  ,
                TYPE_PARENT   const & SRCM ,
                TYPE_PARENT   const & SRCV ,
                TMP_TYPE_DATA const   Eta
            ) {
                Apply (
                    DST.WEIGHT , SRCM.WEIGHT ,
                    SRCV.WEIGHT , Eta
                ) ;
                Apply (
                    DST.BIAS , SRCM.BIAS ,
                    SRCV.BIAS , Eta
                ) ;
            }

        public:
            inline void UPDATE (
                TYPE_PARENT   const & _M  ,
                TYPE_PARENT   const & _V  ,
                TMP_TYPE_DATA const   Eta
            ) {
                this->ACQUIRE_LOCK();
                AddBoth(M,_M,Beta[0]);
                AddBoth(V,_V,Beta[1]);
                ApplyBoth(this[0],M,V,Eta);
                this->RELEASE_LOCK();
            }
        private:
            TMP_TYPE_DATA Beta[2];
            TYPE_PARENT M, V;
        };
    }
    ////////////////////////////////////////////////////////////////
    namespace NN /* FirstLayer */ {
        template <typename T>
        class FirstLayer {
        public:
            typedef T
                TYPE_FIRST_INPUT ;
            //
            typedef typename
                TYPE_FIRST_INPUT::TYPE_DATA
                TYPE_DATA ;
            //
            typedef TYPE_FIRST_INPUT
                TYPE_INPUT ;
            //
            typedef TYPE_INPUT
                TYPE_OUTPUT ;
            //
            typedef Nothing
                TYPE_PARAMETER ;
            //
            typedef FirstLayer
                <TYPE_FIRST_INPUT>
                TYPE_SELF ;
            //
            inline static bool constexpr
            FORWARD_GRAD () {
                return false ;
            }
            //
            inline static bool constexpr
            FORWARD_GRAD (
                TYPE_FIRST_INPUT const & in
            ) {
                return false ;
            }
            //
            inline static size_t constexpr
            SIZE_X () {
                return
                    TYPE_FIRST_INPUT
                        ::SIZE_X () ;
                //
            }
            //
            inline static constexpr
            size_t SIZE_Y () {
                return
                    TYPE_FIRST_INPUT
                        ::SIZE_Y () ;
                //
            }
            //
            inline static constexpr
            size_t SIZE () {
                return
                    TYPE_FIRST_INPUT
                        ::SIZE () ;
                //
            }
            //
            inline static constexpr
            size_t INDEX ()
            { return 0 ; }
            //
            inline void
            GET_LAYER_REFERENCE (
                TYPE_SELF *& ref
            ) { ref = this ; }
            //
            inline void
            SET_FIRST_INPUT (
                TYPE_FIRST_INPUT * _INPUT
            ) { INPUT = _INPUT ; }
            //
            inline TYPE_OUTPUT const &
            GET_OUTPUT () const {
                return INPUT[0];
            }
            //
            inline void FORWARD () const {}
            //
            inline TYPE_FIRST_INPUT const &
            FORWARD (
                TYPE_FIRST_INPUT const & in
            ) {
                INPUT = & in ;
                return INPUT[0] ;
            }
            //
            template <typename Tin>
            inline void BACKWARD (
                Tin const & in
            ) const {}
            //
            inline void ATTACH (
                TYPE_PARAMETER const * _PARS
            ) const {}
            //
            inline void ATTACH (
                TYPE_PARAMETER const & _PARS
            ) const {}
            //
            inline void UPDATE (
                TYPE_DATA const Eta=0.01
            ) const {}
            //
            TYPE_FIRST_INPUT const * INPUT ;
            //
            inline void CONSTRUCT () {}
            //
        } ;
    }
    namespace NN /* BaseNNType */ {
        template <
            size_t   X         ,
            typename inputtype ,
            typename selftype
        > class BaseNNType {
        public:
            //
            typedef inputtype TYPE_INPUT ;
            //
            typedef typename TYPE_INPUT::TYPE_FIRST_INPUT
                TYPE_FIRST_INPUT ;
            //
            typedef typename TYPE_INPUT::TYPE_DATA
                TYPE_DATA ;
            //
            typedef selftype TYPE_PROXY ;
            //
            inline TYPE_PROXY &
            SELF () {
                return static_cast
                    < TYPE_PROXY & >
                    ( this[0] ) ;
            }
            //
            inline TYPE_PROXY const &
            SELF () const {
                return static_cast
                    < TYPE_PROXY const & >
                    ( this[0] ) ;
            }
            //
            static inline size_t constexpr
            SIZE_Y () {
                return TYPE_INPUT::SIZE_Y () ;
            }
            //
            static inline size_t constexpr
            SIZE_X () {
                return X ;
            }
            //
            typedef BaseNNType <
                SIZE_Y ()  ,
                TYPE_INPUT ,
                TYPE_PROXY
            > TYPE_SELF ;
            //
            typedef N2D_ARRAY <
                TYPE_INPUT::SIZE_Y(),
                TYPE_INPUT::SIZE_X(),
                TYPE_DATA
            > TYPE_MATRIX_INPUT ;
            //
            typedef N2D_ARRAY <
                SIZE_Y(),
                SIZE_X(),
                TYPE_DATA
            > TYPE_MATRIX_OUTPUT ;
            //
            typedef PARAMETER <
                TYPE_MATRIX_OUTPUT::SIZE_X () ,
                TYPE_MATRIX_INPUT::SIZE_X  () ,
                TYPE_DATA
            > TYPE_PARAMETER ;
            //
            inline TYPE_MATRIX_OUTPUT const &
            FORWARD ( TYPE_FIRST_INPUT const & in ) {
                return SELF()
                    .MAIN_FORWARD
                    (INPUT.FORWARD(in)) ;
            }
            //
            inline TYPE_MATRIX_OUTPUT &
            GET_OUTPUT ()
            { return OUTPUT ; }
            //
            inline TYPE_MATRIX_OUTPUT const &
            GET_OUTPUT () const
            { return OUTPUT ; }
            //
            inline void SET_FIRST_INPUT
            (TYPE_FIRST_INPUT * _INPUT)
            { INPUT.SET_FIRST_INPUT (_INPUT) ; }
            //
            inline static size_t
            constexpr INDEX ()
            { return TYPE_INPUT::INDEX() + 1 ; }
            //
            template <typename T>
            inline void GET_LAYER_REFERENCE
            (T *& ref) { INPUT.GET_LAYER_REFERENCE(ref); }
            //
            inline void GET_LAYER_REFERENCE
            ( TYPE_PROXY * & ref )
            { ref = & SELF () ; }
            //
            inline void GET_LAYER_REFERENCE
            ( TYPE_PROXY const * & ref ) const
            { ref = & SELF () ; }
            //
            inline void
            CONSTRUCT () {
                SELF().MAIN_CONSTRUCT () ;
                INPUT.CONSTRUCT () ;
            }
            //
            inline void MAIN_CONSTRUCT () {}
            //
            inline TYPE_MATRIX_OUTPUT const & MAIN_FORWARD
            ( TYPE_MATRIX_INPUT const & in ) {
                /* Do Stuff Here... */
                printf(" This should not have been called... MAIN_FORWARD ");
                return this->GET_OUTPUT();
            }
            //
            TYPE_INPUT INPUT ;
            //
            TYPE_MATRIX_OUTPUT OUTPUT ;
            //
        } ;
    }
    namespace NN /* BaseNNTypeTrainable */ {
        template <
            size_t   X         ,
            typename inputtype ,
            typename selftype
        > class BaseNNTypeTrainable :
        public BaseNNType <
            X , inputtype ,
            selftype
        > {
            //
        public:
            //
            typedef BaseNNType <
                X , inputtype ,
                selftype
            > TYPE_BASE_CLASS ;
            //
            typedef typename
                TYPE_BASE_CLASS::TYPE_MATRIX_INPUT
                TYPE_MATRIX_INPUT ;
            //
            typedef typename
                TYPE_BASE_CLASS::TYPE_MATRIX_OUTPUT
                TYPE_MATRIX_OUTPUT ;
            //
            typedef typename
                TYPE_BASE_CLASS::TYPE_PARAMETER
                TYPE_DELTA_PARAMETER ;
            //
            typedef PARAMETER_ADAM
                <TYPE_DELTA_PARAMETER>
                TYPE_PARAMETER ;
            //
            typedef typename
                TYPE_BASE_CLASS::TYPE_DATA
                TYPE_DATA ;
            //
            inline TYPE_MATRIX_INPUT const &
            BACKWARD (
                TYPE_MATRIX_OUTPUT const & delta
            ) {
                //
                TYPE_MATRIX_INPUT const &
                    delta_prime =
                        this->SELF()
                        .MAIN_BACKWARD(delta) ;
                //
                if (false) {
                    auto norm =
                        DELTA_PRIME.L2_NORM();
                    //
                    DELTA_PRIME /= norm ;
                    //
                }
                //
                this->INPUT.BACKWARD
                    ( delta_prime ) ;
                //
                return delta_prime ;
                //
            }
            //
            inline TYPE_MATRIX_INPUT &
            GET_DELTA_PRIME ()
            { return DELTA_PRIME ; }
            //
            inline TYPE_MATRIX_INPUT const &
            GET_DELTA_PRIME () const
            { return DELTA_PRIME ; }
            //
            inline TYPE_MATRIX_INPUT const &
            MAIN_BACKWARD
            ( TYPE_MATRIX_OUTPUT const & in ) {
                printf(" This should not have been called... MAIN_BACKWARD ");
                return GET_DELTA_PRIME () ;
            }
            //
            inline void UPDATE
            ( TYPE_DATA const Eta=0.01 ) {
                this->SELF()
                    .MAIN_UPDATE(Eta);
                //
                this->INPUT.UPDATE (Eta) ;
            }
            //
            inline void MAIN_UPDATE
            ( TYPE_DATA const Eta=0.01 ) {}
            //
            TYPE_MATRIX_INPUT DELTA_PRIME ;
            //
        } ;
    }
    namespace NN /* BaseNNTypeTrainableGrad */ {
        template <
            size_t   X         ,
            typename inputtype ,
            typename selftype
        > class BaseNNTypeTrainableGrad :
        public BaseNNTypeTrainable <
            X , inputtype ,
            selftype
        > {
            //
        public:
            //
            typedef
                BaseNNTypeTrainableGrad <
                    X , inputtype ,
                    selftype
                > TYPE_SELF ;
            //
            typedef
                BaseNNTypeTrainable <
                    X , inputtype ,
                    selftype
                > TYPE_PARENT ;
            //
            typedef typename
                TYPE_PARENT::TYPE_DATA
                    TYPE_DATA ;
            //
            typedef typename
                TYPE_PARENT::TYPE_FIRST_INPUT
                    TYPE_FIRST_INPUT ;
            //
            typedef selftype
                TYPE_PROXY ;
            //
            ////////////////////////////////////////////////////////////////
            // y = TYPE_PARENT::SIZE_X()           /////////////////////////
            // b = TYPE_PARENT::SIZE_Y()           /////////////////////////
            // m = TYPE_FIRST_INPUT::SIZE_X()      /////////////////////////
            // x = TYPE_SELF::TYPE_INPUT::SIZE_X() /////////////////////////
            ////////////////////////////////////////////////////////////////
            //
            typedef N3D_ARRAY <
                TYPE_PARENT::SIZE_Y      () ,
                TYPE_PARENT::SIZE_X      () ,
                TYPE_FIRST_INPUT::SIZE_X () ,
                TYPE_DATA
            > TYPE_GRAD_OUTPUT ;
            //
            typedef N3D_ARRAY <
                TYPE_PARENT::SIZE_Y           () ,
                TYPE_SELF::TYPE_INPUT::SIZE_X () ,
                TYPE_FIRST_INPUT::SIZE_X      () ,
                TYPE_DATA
            > TYPE_GRAD_INPUT ;
            //
            TYPE_GRAD_OUTPUT GRAD ;
            //
            inline TYPE_GRAD_OUTPUT &
            GET_GRAD () {
                return GRAD ;
            }
            //
            inline TYPE_GRAD_OUTPUT const &
            GET_GRAD () const {
                return GRAD ;
            }
            //
            inline TYPE_GRAD_OUTPUT const &
            FORWARD_GRAD () {
                return
                    this->SELF()
                        .MAIN_FORWARD_GRAD(
                            this->INPUT
                                .FORWARD_GRAD()
                        );
                //
            }
            //
            inline TYPE_GRAD_OUTPUT const &
            FORWARD_GRAD (
                TYPE_FIRST_INPUT const & in
            ) {
                this->FORWARD(in); //
                return
                    this->SELF()
                        .MAIN_FORWARD_GRAD (
                            this->INPUT
                                .FORWARD_GRAD()
                        )
                ; //
            }
            //
            inline TYPE_GRAD_OUTPUT const &
            MAIN_FORWARD_GRAD (
                TYPE_GRAD_INPUT const & in
            ) {
                printf("This should not have been called... MAIN_FORWARD_GRAD\n");
                return GET_GRAD();
            }
            //
            inline TYPE_GRAD_OUTPUT const &
            MAIN_FORWARD_GRAD (
                bool const in
            ) {
                printf("This should not have been called... MAIN_FORWARD_GRAD\n");
                return GET_GRAD();
            }
        } ;
    }
    ////////////////////////////////////////////////////////////////
    namespace NN /* Main multiplying layer */ {
        template <size_t Y, typename inputtype>
        class MainNNLayer : public
        BaseNNType <
            Y , inputtype ,
            MainNNLayer
                < Y , inputtype >
        > {
        public:
            typedef BaseNNType <
                Y , inputtype ,
                MainNNLayer
                    < Y , inputtype >
            > TYPE_BASE_CLASS ;
            //
            typedef typename
                TYPE_BASE_CLASS::TYPE_PARAMETER
                TYPE_PARAMETER ;
            //
            typedef typename
                TYPE_BASE_CLASS::TYPE_MATRIX_INPUT
                TYPE_MATRIX_INPUT ;
            //
            typedef typename
                TYPE_BASE_CLASS::TYPE_MATRIX_OUTPUT
                TYPE_MATRIX_OUTPUT ;
            //
            inline TYPE_MATRIX_OUTPUT const & MAIN_FORWARD
            ( TYPE_MATRIX_INPUT const & in ) {
                FUNCTIONS::NeuralMultiply (
                    this->GET_OUTPUT () ,
                    PARAMETER->WEIGHT   ,
                    in                  ,
                    PARAMETER->BIAS
                ) ;
                return this->GET_OUTPUT () ;
            }
            //
            inline void ATTACH_PARAMETER
            ( TYPE_PARAMETER & in )
            { PARAMETER = & in ; }
            //
            TYPE_PARAMETER * PARAMETER ;
            //
        } ;
    }
    namespace NN /* Activation layer: SoftLRU */ {
        template <typename inputtype>
        class ActivateSoftLRU : public
        BaseNNType <
            inputtype::SIZE_X() , inputtype ,
            ActivateSoftLRU < inputtype >
        > {
        public:
            typedef BaseNNType <
                inputtype::SIZE_X() , inputtype ,
                ActivateSoftLRU < inputtype >
            > TYPE_BASE_CLASS ;
            //
            typedef typename
                TYPE_BASE_CLASS::TYPE_DATA
                TYPE_DATA ;
            //
            static inline TYPE_DATA
            SOFT_LRU ( TYPE_DATA const x ) {
                if ( x < 0 ) {
                    return x / ( 1.0 - x ) ;
                } else {
                    return x ;
                }
            }
            //
            typedef typename
                TYPE_BASE_CLASS::TYPE_MATRIX_INPUT
                TYPE_MATRIX_INPUT ;
            //
            typedef typename
                TYPE_BASE_CLASS::TYPE_MATRIX_OUTPUT
                TYPE_MATRIX_OUTPUT ;
            //
            inline TYPE_MATRIX_OUTPUT const & MAIN_FORWARD
            ( TYPE_MATRIX_INPUT const & in ) {
                auto & tmp_in =
                    in.FLATTEN () ;
                //
                auto & tmp_out =
                    this->GET_OUTPUT()
                        .FLATTEN() ;
                //
                for ( size_t i=0 ; i<tmp_in.SIZE() ; i++ )
                { tmp_out[i] = SOFT_LRU (tmp_in[i]) ; }
                //
                return this->GET_OUTPUT () ;
            }
            //
        } ;
    }
    namespace NN /* Activation layer: SoftSign */ {
        template <typename inputtype>
        class ActivateSoftSign : public
        BaseNNType <
            inputtype::SIZE_Y() , inputtype ,
            ActivateSoftSign < inputtype >
        > {
        public:
            typedef BaseNNType <
                inputtype::SIZE_Y() , inputtype ,
                ActivateSoftSign < inputtype >
            > TYPE_BASE_CLASS ;
            //
            typedef typename
                TYPE_BASE_CLASS::TYPE_DATA
                TYPE_DATA ;
            //
            static inline TYPE_DATA
            SOFT_SIGN ( TYPE_DATA const x ) {
                if ( x < 0 ) {
                    return x / ( 1.0 - x ) ;
                } else {
                    return x / ( 1.0 + x ) ;
                }
            }
            //
            typedef typename
                TYPE_BASE_CLASS::TYPE_MATRIX_INPUT
                TYPE_MATRIX_INPUT ;
            //
            typedef typename
                TYPE_BASE_CLASS::TYPE_MATRIX_OUTPUT
                TYPE_MATRIX_OUTPUT ;
            //
            inline TYPE_MATRIX_OUTPUT const & MAIN_FORWARD
            ( TYPE_MATRIX_INPUT const & in ) {
                auto & tmp_in =
                    in.FLATTEN () ;
                //
                auto & tmp_out =
                    this->GET_OUTPUT()
                        .FLATTEN() ;
                //
                for ( size_t i=0 ; i<tmp_in.SIZE() ; i++ )
                { tmp_out[i] = SOFT_SIGN (tmp_in[i]) ; }
                //
                return this->GET_OUTPUT () ;
            }
            //
        } ;
    }
    ////////////////////////////////////////////////////////////////
    namespace NN /* Main trainable layer */ {
        template <size_t Y, typename inputtype>
        class MainNNLayerTrainable : public
        BaseNNTypeTrainable <
            Y , inputtype ,
            MainNNLayerTrainable
                < Y , inputtype >
        > {
            //
        public:
            //
            typedef BaseNNTypeTrainable <
                Y , inputtype ,
                MainNNLayerTrainable
                    < Y , inputtype >
            > TYPE_BASE_CLASS ;
            //
            typedef typename
                TYPE_BASE_CLASS::TYPE_DELTA_PARAMETER
                    TYPE_DELTA_PARAMETER ;
            //
            typedef typename
                TYPE_BASE_CLASS::TYPE_PARAMETER
                TYPE_PARAMETER ;
            //
            typedef typename
                TYPE_BASE_CLASS::TYPE_MATRIX_INPUT
                TYPE_MATRIX_INPUT ;
            //
            typedef typename
                TYPE_BASE_CLASS::TYPE_MATRIX_OUTPUT
                TYPE_MATRIX_OUTPUT ;
            //
            typedef typename
                TYPE_BASE_CLASS::TYPE_DATA
                TYPE_DATA ;
            //
            inline TYPE_MATRIX_OUTPUT const &
            MAIN_FORWARD
            ( TYPE_MATRIX_INPUT const & in ) {
                FUNCTIONS::NeuralMultiply (
                    this->GET_OUTPUT () ,
                    PARAMETER->WEIGHT   ,
                    in                  ,
                    PARAMETER->BIAS
                ) ;
                return this->GET_OUTPUT () ;
            }
            //
            inline void ATTACH_PARAMETER
            ( TYPE_PARAMETER & in )
            { PARAMETER = & in ; }
            //
            inline TYPE_MATRIX_INPUT const &
            MAIN_BACKWARD
            ( TYPE_MATRIX_OUTPUT const & in ) {
                //
                in2.GET_SQUARED(in);
                //
                INPUT2.GET_SQUARED
                    (this->INPUT.GET_OUTPUT());
                //
                FUNCTIONS::BackProp (
                    this->GET_DELTA_PRIME() ,
                    in , PARAMETER->WEIGHT
                ) ;
                //
                FUNCTIONS::EvalW (
                    DP[0].WEIGHT , in ,
                    this->INPUT.GET_OUTPUT()
                ) ;
                //
                FUNCTIONS::EvalW (
                    DP[1].WEIGHT ,
                    in2 , INPUT2
                ) ;
                //
                for(
                    size_t b=0;
                    b<TYPE_MATRIX_OUTPUT::SIZE_Y();
                    b++
                ) { DP[0].BIAS+=in[b]; }
                //
                for(
                    size_t b=0;
                    b<TYPE_MATRIX_OUTPUT::SIZE_Y();
                    b++
                ) { DP[1].BIAS+=in2[b]; }
                //
                return this->
                    GET_DELTA_PRIME() ;
                //
            }
            //
            inline void MAIN_CONSTRUCT ()
            { DP[0]=0.0; DP[1]=0.0; }
            //
            inline void
            MAIN_UPDATE (
                TYPE_DATA const Eta=0.01
            ) {
                //auto norm = DP[0].WEIGHT.L2_NORM () ;
                //DP[0] /= norm ;
                //DP[1] /= (norm*norm) ;
                PARAMETER->UPDATE (
                    /* _M  = */ DP[0] ,
                    /* _V  = */ DP[1] ,
                    /* Eta = */ Eta
                ) ;
                DP[0]=0; DP[1]=0;
            }
            //
            MainNNLayerTrainable()
            { MAIN_CONSTRUCT () ; }
            //
            TYPE_PARAMETER * PARAMETER ;
            //
        private:
            //
            TYPE_MATRIX_INPUT INPUT2 ;
            TYPE_MATRIX_OUTPUT in2 ;
            TYPE_DELTA_PARAMETER DP[2] ;
            //
        } ;
    }
    namespace NN /* Activation layer: SoftLRUTrainable */ {
        template <typename inputtype>
        class ActivateSoftLRUTrainable :
        public BaseNNTypeTrainable <
            inputtype::SIZE_X() , inputtype ,
            ActivateSoftLRUTrainable
                < inputtype >
        > {
        public:
            typedef BaseNNTypeTrainable <
                inputtype::SIZE_X() , inputtype ,
                ActivateSoftLRUTrainable
                    < inputtype >
            > TYPE_BASE_CLASS ;
            //
            typedef typename
                TYPE_BASE_CLASS::TYPE_DATA
                TYPE_DATA ;
            //
            static inline TYPE_DATA
            REAL_ACTIVATE ( TYPE_DATA const x ) {
                if ( x < 0 ) {
                    return x / ( 1.0 - x ) ;
                } else {
                    return x ;
                }
            }
            //
            static inline TYPE_DATA
            REAL_ACTIVATE_D ( TYPE_DATA const x ) {
                if ( x < 0 ) {
                    TYPE_DATA tmp = 1.0 - x ;
                    return 1.0 / ( tmp * tmp ) ;
                } else {
                    return 1.0 ;
                }
            }
            //
            typedef typename
                TYPE_BASE_CLASS::TYPE_MATRIX_INPUT
                TYPE_MATRIX_INPUT ;
            //
            typedef typename
                TYPE_BASE_CLASS::TYPE_MATRIX_OUTPUT
                TYPE_MATRIX_OUTPUT ;
            //
            inline TYPE_MATRIX_OUTPUT const &
            MAIN_FORWARD
            ( TYPE_MATRIX_INPUT const & in ) {
                //
                auto & tmp_in =
                    in.FLATTEN () ;
                //
                auto & tmp_out =
                    this->GET_OUTPUT()
                        .FLATTEN() ;
                //
                for (
                    size_t i=0 ;
                    i<tmp_in.SIZE() ;
                    i++
                ) {
                    tmp_out[i] =
                        REAL_ACTIVATE (tmp_in[i]) ;
                }
                //
                return this->GET_OUTPUT () ;
            }
            //
            inline TYPE_MATRIX_INPUT const &
            MAIN_BACKWARD
            ( TYPE_MATRIX_OUTPUT const & delta ) {
                //
                auto & tmp_in =
                    this->INPUT
                        .GET_OUTPUT()
                        .FLATTEN() ;
                //
                auto & tmp_delta =
                    delta.FLATTEN () ;
                //
                auto & tmp_delta_prime =
                    this->GET_DELTA_PRIME()
                        .FLATTEN() ;
                //
                for (
                    size_t i=0 ;
                    i<tmp_delta_prime.SIZE() ;
                    i++
                ) {
                    tmp_delta_prime[i] =
                        REAL_ACTIVATE_D (tmp_in[i]) *
                        tmp_delta[i] ;
                }
                //
                return this->
                    GET_DELTA_PRIME () ;
                //
            }
            //
        } ;
    }
    namespace NN /* Activation layer: ActivateSoftLRUPTrainable */ {
        template <typename inputtype>
        class ActivateSoftLRUPTrainable :
        public BaseNNTypeTrainable <
            inputtype::SIZE_X() , inputtype ,
            ActivateSoftLRUPTrainable
                < inputtype >
        > {
        public:
            typedef BaseNNTypeTrainable <
                inputtype::SIZE_X() , inputtype ,
                ActivateSoftLRUPTrainable
                    < inputtype >
            > TYPE_BASE_CLASS ;
            //
            typedef typename
                TYPE_BASE_CLASS::TYPE_DATA
                TYPE_DATA ;
            //
            static inline TYPE_DATA
            REAL_ACTIVATE ( TYPE_DATA const x ) {
                if ( x < 0 ) {
                    return 1.0  / ( 1.0 - x ) ;
                } else {
                    return 1.0 + x ;
                }
            }
            //
            static inline TYPE_DATA
            REAL_ACTIVATE_D ( TYPE_DATA const x ) {
                if ( x < 0 ) {
                    TYPE_DATA tmp = 1.0 - x ;
                    return 1.0 / ( tmp * tmp ) ;
                } else {
                    return 1.0 ;
                }
            }
            //
            typedef typename
                TYPE_BASE_CLASS::TYPE_MATRIX_INPUT
                TYPE_MATRIX_INPUT ;
            //
            typedef typename
                TYPE_BASE_CLASS::TYPE_MATRIX_OUTPUT
                TYPE_MATRIX_OUTPUT ;
            //
            inline TYPE_MATRIX_OUTPUT const &
            MAIN_FORWARD
            ( TYPE_MATRIX_INPUT const & in ) {
                //
                auto & tmp_in =
                    in.FLATTEN () ;
                //
                auto & tmp_out =
                    this->GET_OUTPUT()
                        .FLATTEN() ;
                //
                for (
                    size_t i=0 ;
                    i<tmp_in.SIZE() ;
                    i++
                ) {
                    tmp_out[i] =
                        REAL_ACTIVATE (tmp_in[i]) ;
                }
                //
                return this->GET_OUTPUT () ;
            }
            //
            inline TYPE_MATRIX_INPUT const &
            MAIN_BACKWARD
            ( TYPE_MATRIX_OUTPUT const & delta ) {
                //
                auto & tmp_in =
                    this->INPUT
                        .GET_OUTPUT()
                        .FLATTEN() ;
                //
                auto & tmp_delta =
                    delta.FLATTEN () ;
                //
                auto & tmp_delta_prime =
                    this->GET_DELTA_PRIME()
                        .FLATTEN() ;
                //
                for (
                    size_t i=0 ;
                    i<tmp_delta_prime.SIZE() ;
                    i++
                ) {
                    tmp_delta_prime[i] =
                        REAL_ACTIVATE_D (tmp_in[i]) *
                        tmp_delta[i] ;
                    //
                }
                //
                return this->
                    GET_DELTA_PRIME () ;
                //
            }
            //
        } ;
    }
    namespace NN /* Activation layer: ActivateSoftSignTrainable */ {
        template <typename inputtype>
        class ActivateSoftSignTrainable :
        public BaseNNTypeTrainable <
            inputtype::SIZE_X() , inputtype ,
            ActivateSoftSignTrainable
                < inputtype >
        > {
        public:
            typedef BaseNNTypeTrainable <
                inputtype::SIZE_X() , inputtype ,
                ActivateSoftSignTrainable
                    < inputtype >
            > TYPE_BASE_CLASS ;
            //
            typedef typename
                TYPE_BASE_CLASS::TYPE_DATA
                TYPE_DATA ;
            //
            static inline TYPE_DATA
            REAL_ACTIVATE ( TYPE_DATA const x ) {
                if ( x < 0 ) {
                    return x / ( 1.0 - x ) ;
                } else {
                    return x / ( 1.0 + x ) ;
                }
            }
            //
            static inline TYPE_DATA
            REAL_ACTIVATE_D ( TYPE_DATA const x ) {
                if ( x < 0 ) {
                    TYPE_DATA tmp = 1.0 - x ;
                    return 1.0 / ( tmp * tmp ) ;
                } else {
                    TYPE_DATA tmp = 1.0 + x ;
                    return 1.0 / ( tmp * tmp ) ;
                }
            }
            //
            typedef typename
                TYPE_BASE_CLASS::TYPE_MATRIX_INPUT
                TYPE_MATRIX_INPUT ;
            //
            typedef typename
                TYPE_BASE_CLASS::TYPE_MATRIX_OUTPUT
                TYPE_MATRIX_OUTPUT ;
            //
            inline TYPE_MATRIX_OUTPUT const &
            MAIN_FORWARD
            ( TYPE_MATRIX_INPUT const & in ) {
                //
                auto & tmp_in =
                    in.FLATTEN () ;
                //
                auto & tmp_out =
                    this->GET_OUTPUT()
                        .FLATTEN() ;
                //
                for (
                    size_t i=0 ;
                    i<tmp_in.SIZE() ;
                    i++
                ) {
                    tmp_out[i] =
                        REAL_ACTIVATE (tmp_in[i]) ;
                }
                //
                return this->GET_OUTPUT () ;
            }
            //
            inline TYPE_MATRIX_INPUT const &
            MAIN_BACKWARD
            ( TYPE_MATRIX_OUTPUT const & delta ) {
                //
                auto & tmp_in =
                    this->INPUT
                        .GET_OUTPUT()
                        .FLATTEN() ;
                //
                auto & tmp_delta =
                    delta.FLATTEN () ;
                //
                auto & tmp_delta_prime =
                    this->GET_DELTA_PRIME()
                        .FLATTEN() ;
                //
                for (
                    size_t i=0 ;
                    i<tmp_delta_prime.SIZE() ;
                    i++
                ) {
                    tmp_delta_prime[i] =
                        REAL_ACTIVATE_D (tmp_in[i]) *
                        tmp_delta[i] ;
                }
                //
                return this->
                    GET_DELTA_PRIME () ;
                //
            }
            //
        } ;
    }
    namespace NN /* The Last Layer: */ {
        template <typename input>
        class Teacher :
        public BaseNNType <
            input::SIZE_X() ,
            input ,
            Teacher <input>
        > {
            //
        public:
            //
            typedef BaseNNType <
                input::SIZE_X() ,
                input ,
                Teacher <input>
            > TYPE_BASE_CLASS ;
            //
            typedef typename
                TYPE_BASE_CLASS::TYPE_DATA
                TYPE_DATA ;
            //
            typedef typename
                TYPE_BASE_CLASS::TYPE_MATRIX_INPUT
                TYPE_MATRIX_INPUT ;
            //
            typedef typename
                TYPE_BASE_CLASS::TYPE_MATRIX_OUTPUT
                TYPE_MATRIX_OUTPUT ;
            //
            inline TYPE_MATRIX_OUTPUT const &
            MAIN_FORWARD
            ( TYPE_MATRIX_INPUT const & in )
            { return in ; }
            //
            inline TYPE_MATRIX_INPUT const &
            MAIN_BACKWARD
            ( TYPE_MATRIX_OUTPUT const & in ) {
                //
                auto & delta =
                    this->GET_OUTPUT()
                    .FLATTEN() ;
                //
                auto & INP =
                    this->INPUT
                        .GET_OUTPUT()
                        .FLATTEN() ;
                //
                auto & flat_in =
                    in.FLATTEN();
                //
                for(size_t i=0;i<delta.SIZE();i++) {
                    delta[i]=INP[i]-flat_in[i];
                }
                //
                return this->
                    GET_OUTPUT() ;
                //
            }
            //
            inline TYPE_MATRIX_INPUT const &
            BACKWARD (
                TYPE_MATRIX_OUTPUT const & delta
            ) {
                //
                TYPE_MATRIX_INPUT const &
                    delta_prime =
                        MAIN_BACKWARD(delta) ;
                //
                this->INPUT.BACKWARD
                    ( delta_prime ) ;
                //
                return delta_prime ;
                //
            }
            //
            inline void UPDATE
            ( TYPE_DATA const Eta=0.01 )
            { this->INPUT.UPDATE (Eta) ; }
            //
        } ;
    }
    namespace NN /* Activation layer: ActivateL2NormalizerTrainable */ {
        template <typename inputtype>
        class ActivateL2NormalizerTrainable :
        public BaseNNTypeTrainable <
            inputtype::SIZE_X() ,
            inputtype ,
            ActivateL2NormalizerTrainable
                < inputtype >
        > {
            //
        public:
            //
            typedef BaseNNTypeTrainable <
                inputtype::SIZE_X() ,
                inputtype ,
                ActivateL2NormalizerTrainable
                    < inputtype >
            > TYPE_BASE_CLASS ;
            //
            typedef typename
                TYPE_BASE_CLASS::TYPE_DATA
                TYPE_DATA
            ; //
            typedef typename
                TYPE_BASE_CLASS::TYPE_MATRIX_INPUT
                TYPE_MATRIX_INPUT
            ; //
            typedef typename
                TYPE_BASE_CLASS::TYPE_MATRIX_OUTPUT
                TYPE_MATRIX_OUTPUT
            ; //
            typedef ND_ARRAY <
                TYPE_MATRIX_INPUT::SIZE_X(),
                TYPE_DATA
            > TYPE_ACTIVATOR_ARRAY ;
            //
            typedef ND_ARRAY <
                TYPE_MATRIX_INPUT::SIZE_Y(),
                TYPE_DATA
            > TYPE_DENOMINATOR_ARRAY ;
            //
            inline TYPE_MATRIX_OUTPUT const &
            MAIN_FORWARD (
                TYPE_MATRIX_INPUT const & in
            ) {
                for(
                    size_t i=0;
                    i<DENOMINATOR.SIZE();
                    i++
                ) {
                    DENOMINATOR[i] =
                        in[i].L2_NORM ()
                    ; //
                }
                //
                auto & out =
                    this->GET_OUTPUT ()
                ; //
                for(
                    size_t y=0;
                    y<out.SIZE_Y();
                    y++
                ){
                    for(
                        size_t x=0;
                        x<out.SIZE_X();
                        x++
                    ){
                        out[y][x] =
                            (in[y][x]*in[y][x]) /
                            DENOMINATOR[y]
                        ; //
                    }
                }
                return out ;
            }
            //
            inline TYPE_MATRIX_INPUT const &
            MAIN_BACKWARD (
                TYPE_MATRIX_OUTPUT const & delta
            ) {
                auto & delta_prime =
                    this->GET_DELTA_PRIME () ;
                //
                auto const & in =
                    this->INPUT.GET_OUTPUT();
                //
                for(
                    size_t b=0;
                    b<SUM.SIZE();
                    b++
                ) {
                    SUM[b]=0.0;
                    for(
                        size_t i=0;
                        i<in.SIZE_X();
                        i++
                    ){
                        SUM[b]+=
                            delta[b][i] *
                            in[b][i]    *
                            in[b][i]
                        ; //
                    }
                }
                for(
                    size_t b=0;
                    b<SUM.SIZE();
                    b++
                ) {
                    SUM[b]/=(
                        DENOMINATOR[b]*
                        DENOMINATOR[b]
                    );
                }
                //
                for(
                    size_t b=0;
                    b<TYPE_MATRIX_INPUT::SIZE_Y();
                    b++
                ) {
                    for(
                        size_t k=0;
                        k<TYPE_MATRIX_INPUT::SIZE_X();
                        k++
                    ) {
                        delta_prime[b][k] =
                            2.0 * in[b][k] * (
                                +(delta[b][k]/DENOMINATOR[b])
                                -SUM[b]
                            )
                        ; //
                    }
                    //
                }
                //
                return this->
                    GET_DELTA_PRIME ()
                ; //
            }
            //
            TYPE_DENOMINATOR_ARRAY
                DENOMINATOR
            ; //
            TYPE_DENOMINATOR_ARRAY
                SUM
            ; //
        } ;
    }
    ////////////////////////////////////////////////////////////////
    namespace NN /* Main trainable layer with gradient */ {
        template <size_t Y, typename inputtype>
        class MainNNLayerTrainableGrad : public
        BaseNNTypeTrainableGrad <
            Y , inputtype ,
            MainNNLayerTrainableGrad
                < Y , inputtype >
        > {
            //
        public:
            //
            typedef BaseNNTypeTrainableGrad <
                Y , inputtype ,
                MainNNLayerTrainableGrad
                    < Y , inputtype >
            > TYPE_BASE_CLASS ;
            //
            typedef typename
                TYPE_BASE_CLASS::TYPE_DELTA_PARAMETER
                    TYPE_DELTA_PARAMETER ;
            //
            typedef typename
                TYPE_BASE_CLASS::TYPE_PARAMETER
                TYPE_PARAMETER ;
            //
            typedef typename
                TYPE_BASE_CLASS::TYPE_MATRIX_INPUT
                TYPE_MATRIX_INPUT ;
            //
            typedef typename
                TYPE_BASE_CLASS::TYPE_MATRIX_OUTPUT
                TYPE_MATRIX_OUTPUT ;
            //
            typedef typename
                TYPE_BASE_CLASS::TYPE_DATA
                TYPE_DATA ;
            //
            typedef typename
                TYPE_BASE_CLASS::TYPE_GRAD_OUTPUT
                    TYPE_GRAD_OUTPUT ;
            //
            typedef typename
                TYPE_BASE_CLASS::TYPE_GRAD_INPUT
                    TYPE_GRAD_INPUT ;
            //
            inline TYPE_MATRIX_OUTPUT const &
            MAIN_FORWARD (
                TYPE_MATRIX_INPUT const & in
            ) {
                FUNCTIONS::NeuralMultiply (
                    this->GET_OUTPUT () ,
                    PARAMETER->WEIGHT   ,
                    in                  ,
                    PARAMETER->BIAS
                ) ;
                return this->GET_OUTPUT () ;
            }
            //
            inline void
            ATTACH_PARAMETER (
                TYPE_PARAMETER & in
            ) {
                PARAMETER = & in ;
            }
            //
            inline TYPE_MATRIX_INPUT const &
            MAIN_BACKWARD (
                TYPE_MATRIX_OUTPUT const & in
            ) {
                //
                in2.GET_SQUARED(in);
                //
                INPUT2.GET_SQUARED (
                    this->INPUT.GET_OUTPUT()
                );
                //
                FUNCTIONS::BackProp (
                    this->GET_DELTA_PRIME() ,
                    in , PARAMETER->WEIGHT
                ) ;
                //
                FUNCTIONS::EvalW (
                    DP[0].WEIGHT , in ,
                    this->INPUT.GET_OUTPUT()
                ) ;
                //
                FUNCTIONS::EvalW (
                    DP[1].WEIGHT ,
                    in2 , INPUT2
                ) ;
                //
                for(
                    size_t b=0;
                    b<TYPE_MATRIX_OUTPUT::SIZE_Y();
                    b++
                ) { DP[0].BIAS+=in[b]; }
                //
                for(
                    size_t b=0;
                    b<TYPE_MATRIX_OUTPUT::SIZE_Y();
                    b++
                ) { DP[1].BIAS+=in2[b]; }
                //
                return this->
                    GET_DELTA_PRIME() ;
                //
            }
            //
            inline void
            MAIN_CONSTRUCT () {
                DP[0]=0.0;
                DP[1]=0.0;
            }
            //
            inline void
            MAIN_UPDATE (
                TYPE_DATA const Eta=0.01
            ) {
                //auto norm = DP[0].WEIGHT.L2_NORM () ;
                //DP[0] /= norm ;
                //DP[1] /= (norm*norm) ;
                PARAMETER->UPDATE (
                    /* _M  = */ DP[0] ,
                    /* _V  = */ DP[1] ,
                    /* Eta = */ Eta
                ) ;
                DP[0]=0;
                DP[1]=0;
            }
            //
            MainNNLayerTrainableGrad()
            { MAIN_CONSTRUCT () ; }
            //
            TYPE_PARAMETER * PARAMETER ;
            //
            inline TYPE_GRAD_OUTPUT const &
            MAIN_FORWARD_GRAD (
                TYPE_GRAD_INPUT const &
                    in
            ) {
                FUNCTIONS::GRAD_PROPAGATE(
                    this->GET_GRAD()  ,
                    PARAMETER->WEIGHT ,
                    in
                );
                return this->GET_GRAD();
            }
            //
            inline TYPE_GRAD_OUTPUT const &
            MAIN_FORWARD_GRAD (
                bool const in
            ) {
                FUNCTIONS::GRAD_PROPAGATE(
                    this->GET_GRAD()  ,
                    PARAMETER->WEIGHT ,
                    in
                );
                return this->GET_GRAD();
            }
            //
        private:
            //
            TYPE_MATRIX_INPUT    INPUT2 ;
            TYPE_MATRIX_OUTPUT   in2    ;
            TYPE_DELTA_PARAMETER DP[2]  ;
            //
        } ;
    }
    namespace NN /* Activation layer: SoftLRUTrainableGrad */ {
        template <typename inputtype>
        class ActivateSoftLRUTrainableGrad :
        public BaseNNTypeTrainableGrad <
            inputtype::SIZE_X() , inputtype ,
            ActivateSoftLRUTrainableGrad
                < inputtype >
        > {
        public:
            typedef BaseNNTypeTrainableGrad <
                inputtype::SIZE_X() , inputtype ,
                ActivateSoftLRUTrainableGrad
                    < inputtype >
            > TYPE_BASE_CLASS ;
            //
            typedef typename
                TYPE_BASE_CLASS::TYPE_DATA
                TYPE_DATA ;
            //
            static inline TYPE_DATA
            REAL_ACTIVATE (
                TYPE_DATA const x
            ) {
                if ( x < 0 ) {
                    return x / ( 1.0 - x ) ;
                } else {
                    return x ;
                }
            }
            //
            static inline TYPE_DATA
            REAL_ACTIVATE_D (
                TYPE_DATA const x
            ) {
                if ( x < 0 ) {
                    TYPE_DATA tmp = 1.0 - x ;
                    return 1.0 / ( tmp * tmp ) ;
                } else {
                    return 1.0 ;
                }
            }
            //
            typedef typename
                TYPE_BASE_CLASS::TYPE_MATRIX_INPUT
                TYPE_MATRIX_INPUT ;
            //
            typedef typename
                TYPE_BASE_CLASS::TYPE_GRAD_OUTPUT
                TYPE_GRAD_OUTPUT ;
            //
            typedef typename
                TYPE_BASE_CLASS::TYPE_GRAD_INPUT
                TYPE_GRAD_INPUT ;
            //
            typedef typename
                TYPE_BASE_CLASS::TYPE_MATRIX_OUTPUT
                TYPE_MATRIX_OUTPUT ;
            //
            inline TYPE_MATRIX_OUTPUT const &
            MAIN_FORWARD (
                TYPE_MATRIX_INPUT const & in
            ) {
                //
                auto & tmp_in =
                    in.FLATTEN () ;
                //
                auto & tmp_out =
                    this->GET_OUTPUT()
                        .FLATTEN() ;
                //
                for (
                    size_t i=0 ;
                    i<tmp_in.SIZE() ;
                    i++
                ) {
                    tmp_out[i] =
                        REAL_ACTIVATE (tmp_in[i]) ;
                }
                //
                return this->GET_OUTPUT () ;
            }
            //
            inline TYPE_MATRIX_INPUT const &
            MAIN_BACKWARD (
                TYPE_MATRIX_OUTPUT const & delta
            ) {
                //
                auto & tmp_in =
                    this->INPUT
                        .GET_OUTPUT()
                        .FLATTEN() ;
                //
                auto & tmp_delta =
                    delta.FLATTEN () ;
                //
                auto & tmp_delta_prime =
                    this->GET_DELTA_PRIME()
                        .FLATTEN() ;
                //
                for (
                    size_t i=0 ;
                    i<tmp_delta_prime.SIZE() ;
                    i++
                ) {
                    tmp_delta_prime[i] =
                        REAL_ACTIVATE_D (tmp_in[i]) *
                        tmp_delta[i] ;
                }
                //
                return this->
                    GET_DELTA_PRIME () ;
                //
            }
            //
            inline TYPE_GRAD_OUTPUT const &
            MAIN_FORWARD_GRAD (
                TYPE_GRAD_INPUT const & in
            ) {
                auto & Input =
                    this->INPUT
                        .GET_OUTPUT() ;
                //
                auto & Output =
                    this->GET_GRAD() ;
                //
                for(size_t b=0;b<in.SIZE_Z();b++){
                    for(size_t i=0;i<in.SIZE_Y();i++){
                        for(size_t m=0;m<in.SIZE_X();m++){
                            Output[b][i][m] =
                                REAL_ACTIVATE_D (Input[b][i])
                                * in[b][i][m] ;
                        }
                    }
                }
                //
                return Output;
                //
            }
        } ;
    }
    namespace NN /* Activation layer: SoftLRUPTrainableGrad */ {
        template <typename inputtype>
        class ActivateSoftLRUPTrainableGrad :
        public BaseNNTypeTrainableGrad <
            inputtype::SIZE_X() , inputtype ,
            ActivateSoftLRUPTrainableGrad
                < inputtype >
        > {
        public:
            typedef BaseNNTypeTrainableGrad <
                inputtype::SIZE_X() , inputtype ,
                ActivateSoftLRUPTrainableGrad
                    < inputtype >
            > TYPE_BASE_CLASS ;
            //
            typedef typename
                TYPE_BASE_CLASS::TYPE_DATA
                TYPE_DATA ;
            //
            static inline TYPE_DATA
            REAL_ACTIVATE ( TYPE_DATA const x ) {
                if ( x < 0 ) {
                    return 1.0  / ( 1.0 - x ) ;
                } else {
                    return 1.0 + x ;
                }
            }
            //
            static inline TYPE_DATA
            REAL_ACTIVATE_D ( TYPE_DATA const x ) {
                if ( x < 0 ) {
                    TYPE_DATA tmp = 1.0 - x ;
                    return 1.0 / ( tmp * tmp ) ;
                } else {
                    return 1.0 ;
                }
            }
            //
            typedef typename
                TYPE_BASE_CLASS::TYPE_MATRIX_INPUT
                TYPE_MATRIX_INPUT ;
            //
            typedef typename
                TYPE_BASE_CLASS::TYPE_GRAD_OUTPUT
                TYPE_GRAD_OUTPUT ;
            //
            typedef typename
                TYPE_BASE_CLASS::TYPE_GRAD_INPUT
                TYPE_GRAD_INPUT ;
            //
            typedef typename
                TYPE_BASE_CLASS::TYPE_MATRIX_OUTPUT
                TYPE_MATRIX_OUTPUT ;
            //
            inline TYPE_MATRIX_OUTPUT const &
            MAIN_FORWARD (
                TYPE_MATRIX_INPUT const & in
            ) {
                //
                auto & tmp_in =
                    in.FLATTEN () ;
                //
                auto & tmp_out =
                    this->GET_OUTPUT()
                        .FLATTEN() ;
                //
                for (
                    size_t i=0 ;
                    i<tmp_in.SIZE() ;
                    i++
                ) {
                    tmp_out[i] =
                        REAL_ACTIVATE (tmp_in[i]) ;
                }
                //
                return this->GET_OUTPUT () ;
            }
            //
            inline TYPE_MATRIX_INPUT const &
            MAIN_BACKWARD (
                TYPE_MATRIX_OUTPUT const & delta
            ) {
                //
                auto & tmp_in =
                    this->INPUT
                        .GET_OUTPUT()
                        .FLATTEN() ;
                //
                auto & tmp_delta =
                    delta.FLATTEN () ;
                //
                auto & tmp_delta_prime =
                    this->GET_DELTA_PRIME()
                        .FLATTEN() ;
                //
                for (
                    size_t i=0 ;
                    i<tmp_delta_prime.SIZE() ;
                    i++
                ) {
                    tmp_delta_prime[i] =
                        REAL_ACTIVATE_D (tmp_in[i]) *
                        tmp_delta[i] ;
                }
                //
                return this->
                    GET_DELTA_PRIME () ;
                //
            }
            //
            inline TYPE_GRAD_OUTPUT const &
            MAIN_FORWARD_GRAD (
                TYPE_GRAD_INPUT const & in
            ) {
                auto & Input =
                    this->INPUT
                        .GET_OUTPUT() ;
                //
                auto & Output =
                    this->GET_GRAD() ;
                //
                for(size_t b=0;b<in.SIZE_Z();b++){
                    for(size_t i=0;i<in.SIZE_Y();i++){
                        for(size_t m=0;m<in.SIZE_X();m++){
                            Output[b][i][m] =
                                REAL_ACTIVATE_D (Input[b][i])
                                * in[b][i][m] ;
                        }
                    }
                }
                //
                return Output;
                //
            }
        } ;
    }
    namespace NN /* The Last Layer grad: */ {
        template <typename input>
        class TeacherGrad :
        public BaseNNType <
            input::SIZE_X() ,
            input ,
            TeacherGrad <input>
        > {
            //
        public:
////////////////////////////////////////////////////////////////
            typedef BaseNNType <
                input::SIZE_X() ,
                input ,
                TeacherGrad <input>
            > TYPE_BASE_CLASS
            ; //
            typedef
                TeacherGrad <input>
                TYPE_SELF
            ; //
            typedef typename
                TYPE_SELF::TYPE_FIRST_INPUT
                TYPE_FIRST_INPUT
            ; //
            typedef typename
                TYPE_BASE_CLASS::TYPE_DATA
                TYPE_DATA
            ; //
            typedef typename
                TYPE_BASE_CLASS::TYPE_MATRIX_INPUT
                TYPE_MATRIX_INPUT
            ; //
            typedef typename
                TYPE_BASE_CLASS::TYPE_MATRIX_OUTPUT
                TYPE_MATRIX_OUTPUT
            ; //
            typedef typename
                TYPE_BASE_CLASS::TYPE_INPUT
                    ::TYPE_GRAD_OUTPUT
                TYPE_GRAD_OUTPUT
            ; //
////////////////////////////////////////////////////////////////
            inline TYPE_MATRIX_OUTPUT const &
            MAIN_FORWARD (
                TYPE_MATRIX_INPUT const & in
            ) { return in ; }
            //
            inline TYPE_MATRIX_INPUT const &
            MAIN_BACKWARD (
                TYPE_MATRIX_OUTPUT const & in
            ) {
                //
                auto & delta =
                    this->GET_OUTPUT()
                    .FLATTEN() ;
                //
                auto & INP =
                    this->INPUT
                        .GET_OUTPUT()
                        .FLATTEN() ;
                //
                auto & flat_in =
                    in.FLATTEN();
                //
                for(size_t i=0;i<delta.SIZE();i++) {
                    delta[i]=INP[i]-flat_in[i];
                }
                //
                return this->
                    GET_OUTPUT() ;
                //
            }
            //
            inline TYPE_MATRIX_INPUT const &
            BACKWARD (
                TYPE_MATRIX_OUTPUT const & delta
            ) {
                //
                TYPE_MATRIX_INPUT const &
                    delta_prime =
                        MAIN_BACKWARD(delta) ;
                //
                this->INPUT.BACKWARD
                    ( delta_prime ) ;
                //
                return delta_prime ;
                //
            }
            //
            inline void UPDATE
            ( TYPE_DATA const Eta=0.01 )
            { this->INPUT.UPDATE (Eta) ; }
            //
            inline TYPE_GRAD_OUTPUT const &
            FORWARD_GRAD () {
                return
                    this->INPUT
                        .FORWARD_GRAD()
                ; //
            }
            //
            inline TYPE_GRAD_OUTPUT const &
            FORWARD_GRAD (
                TYPE_FIRST_INPUT const & in
            ) {
                this->FORWARD(in);
                return
                    this->INPUT
                        .FORWARD_GRAD()
                ; //
            }
            //

        } ;
    }
    ////////////////////////////////////////////////////////////////
}
#endif


#ifdef USE_PYTHIA
#include <Pythia8/Pythia.h>
#endif

#ifdef USE_FASTJET
#include <fastjet/Selector.hh>
#include <fastjet/tools/JHTopTagger.hh>
#endif

namespace NewHEPHeaders /* The preliminary standards: */ {
    constexpr double SMALL_EPSILON = 0.000001 ;
    constexpr bool DEBUG = false;
    inline size_t shifter  (size_t const in) {return (1<<in);}
    inline bool   checkbit (size_t const inbits, size_t const checkbits) {return ((inbits&checkbits)==checkbits);}
    namespace CONSTANTS   {
        constexpr double PI = 3.141592653589793238462643383279502884197169399375105820974944592307816406286;
        constexpr double PI2 = PI * 2.0;
    }
    namespace PID         {
        constexpr long DOWN = 1;
        constexpr long UP = 2;
        constexpr long STRANGE = 3;
        constexpr long CHARM = 4;
        constexpr long BOTTOM = 5;
        constexpr long TOP = 6;
        constexpr long GAMMA = 22;
        constexpr long Z = 23;
        constexpr long W = 24;
        constexpr long H0 = 25;
        constexpr long H1 = 35;
        constexpr long A0 = 36;
        constexpr long CHARGED_HIGGS = 37;
        constexpr long GLUON = 21;
        constexpr long ELECTRON_NU = 12;
        constexpr long MUON_NU = 14;
        constexpr long TAU_NU = 16;
        constexpr long ELECTRON = 11;
        constexpr long MUON = 13;
        constexpr long TAU = 15;
        constexpr long CHI10 = 1000022;
        constexpr long CHI20 = 1000023;
    }
    namespace MASS        {
        constexpr double TOP = 173.340;
        constexpr double W = 80.385;
        constexpr double Z = 91.190;
        constexpr double H0 = 125.000;
    }
    namespace DECAY_WIDTH {
        constexpr double W = 2.085 ;
    }
    inline bool detectable (long pid) {
        pid = CPPFileIO::mymod (pid);
        if (pid == PID::ELECTRON_NU) {return false;}
        if (pid == PID::MUON_NU) {return false;}
        if (pid == PID::TAU_NU) {return false;}
        if (pid == PID::CHI10) {return false;}
        if (pid == PID::CHI20) {return false;}
        return true;
    }
    inline bool islepton (long pid) {
        pid = CPPFileIO::mymod (pid);
        if (pid == PID::ELECTRON) {return true;}
        if (pid == PID::MUON) {return true;}
        if (pid == PID::TAU) {return true;}
        return false;
    }
    inline bool isblike (long pid) {
        pid=CPPFileIO::mymod(pid);
        if(pid<100) {
            if(pid==PID::BOTTOM) {return true;}
            else {return false;}
        } else {
            while(pid>0) {
                long tmp = pid%10;
                if(tmp==PID::BOTTOM) {return true;}
                pid=pid/10;
            }
            return false ;
        }
    }
}

namespace NewHEPHeaders /* The main lorentz vectors part: */ {
    namespace VECTORS {
        const size_t NOTHING = 0;
        const size_t BTAG = shifter(0);
        const size_t TAUTAG = shifter(1);
        const size_t BMESONTAG = shifter(2);
        double VECTOR_EQUALITY_LIMIT = 50.0;
        template < typename TR=double > class plane2vector   {
        public:
            typedef TR TYPE_Data ;
            typedef plane2vector <TYPE_Data> TYPE_Self ;
        private:
            void construct (TR _x = 0, TR _y = 0) {x[0] = _x;x[1] = _y;}
        public:
            TYPE_Data x[2];
            inline void SetPtPhi (const TYPE_Data _pt=0,const TYPE_Data _phi=0) {x[0]=_pt*cos(_phi);x[1]=_pt*sin(_phi);}
            inline TYPE_Data pt2 () const { return (x[0] * x[0]) + (x[1] * x[1]); }
            inline TYPE_Data pt  () const { return (sqrt(pt2())) ; }
            inline TYPE_Data R   () const { return pt()          ; }
            inline TYPE_Data safenorm2 () const {
                TYPE_Data mag = pt2 ();
                if (CPPFileIO::mymod (mag) < 0.0000000001) {mag = CPPFileIO::mysign (mag) * 0.0000000001;}
                return mag;
            }
            inline TYPE_Data phi () const {
                TYPE_Data ret = acos (x[0] / sqrt (safenorm2 ()));
                if (x[1] < 0) {ret = CONSTANTS::PI2 - ret;}
                return ret;
            }
            inline TYPE_Data dphi (const TYPE_Self b) const {
                TYPE_Data ret = CPPFileIO::mymod (b.phi () - phi ());
                if (ret > CONSTANTS::PI) { ret = CONSTANTS::PI2 - ret; }
                return ret;
            }
            inline TYPE_Self operator + (const TYPE_Self b) const
            { return TYPE_Self (x[0] + b.x[0], x[1] + b.x[1]); }

            inline TYPE_Self operator - (const TYPE_Self b) const
            { return TYPE_Self (x[0] - b.x[0], x[1] - b.x[1]); }

            inline TYPE_Data operator * (const TYPE_Self b) const
            { return (x[0] * b.x[0]) + (x[1] * b.x[1]); }

            inline TYPE_Self operator + (const TYPE_Data b) const
            { return TYPE_Self (x[0] + b, x[1] + b); }

            inline TYPE_Self operator - (const TYPE_Data b) const
            { return TYPE_Self (x[0] - b, x[1] - b); }

            inline TYPE_Self operator * (const TYPE_Data b) const
            { return TYPE_Self (x[0] * b, x[1] * b); }

            inline TYPE_Self operator / (const TYPE_Data b) const
            { return TYPE_Self (x[0] / b, x[1] / b); }

            inline TYPE_Data operator  () (const TYPE_Self b) const { return dphi (b); }

            inline TYPE_Self flip () const
            { return TYPE_Self (-x[0], -x[1]); }

            inline TYPE_Self dir () const {
                TYPE_Self ret (x[0], x[1]);
                TYPE_Data mag = sqrt (ret.safenorm2 ());
                ret = ret / mag;
                return ret;
            }

            inline bool operator > (const plane2vector < TR > b) const { return pt2 () > b.pt2 (); }
            inline bool operator < (const plane2vector < TR > b) const { return pt2 () < b.pt2 (); }
            inline ssize_t operator >> (CPPFileIO::FileFD & f) const { return f.multiwrite2file (*this); }
            inline ssize_t operator << (CPPFileIO::FileFD & f) const { return f.multiread2file (*this); }

            inline void operator += ( const plane2vector < TR > b ) { x[0] += b.x[0] ; x[1] += b.x[1] ; }
            inline void operator -= ( const plane2vector < TR > b ) { x[0] -= b.x[0] ; x[1] -= b.x[1] ; }
            inline void operator *= ( const plane2vector < TR > b ) { x[0] *= b.x[0] ; x[1] *= b.x[1] ; }
            inline void operator /= ( const plane2vector < TR > b ) { x[0] /= b.x[0] ; x[1] /= b.x[1] ; }

            inline void operator += ( TYPE_Data const b ) { x[0] += b ; x[1] += b ; }
            inline void operator -= ( TYPE_Data const b ) { x[0] -= b ; x[1] -= b ; }
            inline void operator *= ( TYPE_Data const b ) { x[0] *= b ; x[1] *= b ; }
            inline void operator /= ( TYPE_Data const b ) { x[0] /= b ; x[1] /= b ; }

            inline TR & operator [] (size_t i)       { return x[i]; }
            inline TR   operator [] (size_t i) const { return x[i]; }

            inline void clearthis () { x[0] = 0; x[1] = 0; }
            inline bool operator == (const plane2vector < TR > b) const {
                plane2vector < TR > tmp (x[0], x[1]);
                tmp = tmp - b;
                TR diff = tmp.pt2 ();
                diff = CPPFileIO::mymod (diff);
                return diff < VECTOR_EQUALITY_LIMIT;
            }

            plane2vector (const TR _x = 0, const TR _y = 0) {construct (_x, _y);}
            plane2vector (const plane2vector < TR > &c) {construct(c.x[0], c.x[1]);}
            ~plane2vector () {}
        };
        template < typename TR=double > class euclid3vector  {
        public:
            typedef TR TYPE_Data ;
            typedef euclid3vector <TYPE_Data> TYPE_Self ;
            typedef plane2vector <TYPE_Data> TYPE_Vector2 ;
        public:
            TYPE_Vector2 xy; TYPE_Data z;
            inline void SetPtEtaPhi(const TR _pt=0, const TR _eta=0, const TR _phi=0){
                xy.SetPtPhi (_pt,_phi) ;
                TR K = 2.0 * _eta ;
                K = exp (K) ;
                K = (K-1.0) / (K+1.0) ;
                K = K * K ;
                K = K / ( 1.0 - K ) ;
                z = sqrt(_pt*_pt*K) * CPPFileIO::mysign(_eta) ;
            }
            inline TR phi () const {return xy.phi ();}
            inline TR pt2 () const {return xy.pt2 ();}
            inline TR pt () const {return xy.pt ();}
            inline euclid3vector < TR > operator + (const euclid3vector < TR > a) const
            { return euclid3vector < TR > (xy + a.xy, z + a.z); }

            inline euclid3vector < TR > operator - (const euclid3vector < TR > a) const
            { return euclid3vector < TR > (xy - a.xy, z - a.z); }

            inline TR operator * (const euclid3vector <TR> a) const
            { return (xy * a.xy) + (z * a.z); }

            inline euclid3vector <TR> operator * (const TR a) const
            { return euclid3vector < TR > (xy * a, z * a); }

            inline euclid3vector <TR> operator / (const TR a) const
            { return euclid3vector < TR > (xy / a, z / a); }

            inline TR p2 () const { return xy.pt2 () + (z * z); }
            inline TR p () const { return sqrt (p2 ()); }

            inline TR & operator [] (size_t ret) {
                if (ret > 1) { return z; }
                else { return xy[ret]; }
            }
            inline TR operator [] (size_t ret) const {
                if (ret > 1) { return z; }
                else { return xy[ret]; }
            }

            inline TR eta () const
            { TR tmp_p = p (); return 0.5 * log ((tmp_p + z) / (tmp_p - z)); }

            inline TR meta () const { return CPPFileIO::mymod (eta ()); }

            inline TR cone2 (const euclid3vector < TR > b) const {
                TR tphi = xy.dphi (b.xy);
                tphi = tphi * tphi;
                TR teta = eta () - b.eta ();
                teta = teta * teta;
                TR ret = teta + tphi;
                return ret;
            }
            inline TR cone (const euclid3vector < TR > b) const
            { return sqrt (cone2 (b)); }

            inline TR dphi (const euclid3vector < TR > b) const
            { TR tphi = xy.dphi (b.xy); return tphi; }

            inline TR operator  () (const euclid3vector <TR> b) const { return cone (b); }
            inline TR safenorm2 () const {
                TR mag = xy.pt2 () + (z * z);
                if (CPPFileIO::mymod (mag) < 0.0000000001)
                { mag = CPPFileIO::mysign (mag) * 0.0000000001; }
                return mag;
            }
            inline euclid3vector < TR > flip () const { return euclid3vector < TR > (xy.flip (), -z); }
            inline euclid3vector < TR > trans () const { return euclid3vector < TR > (xy, 0); }
            inline euclid3vector < TR > dir () const {
                euclid3vector < TR > ret (*this);
                TR mag = sqrt (ret.safenorm2 ());
                ret = ret / mag;
                return ret;
            }

            inline void operator += (const euclid3vector<TR>b) {xy+=b.xy;z+=b.z;}
            inline void operator -= (const euclid3vector<TR>b) {xy-=b.xy;z-=b.z;}
            inline void operator *= (const euclid3vector<TR>b) {xy*=b.xy;z*=b.z;}
            inline void operator /= (const euclid3vector<TR>b) {xy/=b.xy;z/=b.z;}

            inline bool operator > (const euclid3vector < TR > b) const { return pt2 () > b.pt2 (); }
            inline bool operator < (const euclid3vector < TR > b) const { return pt2 () < b.pt2 (); }
            inline ssize_t operator >> (CPPFileIO::FileFD & f) const { return f.multiwrite2file (*this); }
            inline ssize_t operator << (CPPFileIO::FileFD & f) const { return f.multiread2file (*this); }
            inline void clearthis () { xy = plane2vector < TR > (0, 0); z = 0; }
            inline bool operator == (const euclid3vector < TR > b) const {
                euclid3vector < TR > tmp = (*this) - b;
                TR diff = tmp.p2 ();
                diff = CPPFileIO::mymod (diff);
                return diff < VECTOR_EQUALITY_LIMIT;
            }
            euclid3vector (const TR _x = 0, const TR _y = 0, const TR _z = 0):xy (_x, _y) {z = _z;}
            euclid3vector (const plane2vector < TR > a, const TR _z = 0):xy (a) {z = _z;}
            euclid3vector (const euclid3vector < TR > &a):xy (a.xy) {z = a.z;}
        };
        template < typename TR=double > class lorentz4vector {
        public:
            typedef TR TYPE_Data ;
            typedef lorentz4vector <TYPE_Data> TYPE_Self    ;
            typedef euclid3vector  <TYPE_Data> TYPE_Vector3 ;
        public:
            TYPE_Vector3 xyz; TYPE_Data t;
            inline void SetPtEtaPhiM(const TR _pt, const TR _eta, const TR _phi, const TR _m){
                xyz.xy.SetPtPhi(_pt,_phi);
                TR K = exp(2.0*_eta) ;
                K=(K+1.0)/(K-1.0);
                TR _pt2 = _pt * _pt ;
                TR _m2 = _m*_m ;
                TR _z2 = (_pt2+_m2)/((K*K)-1.0) ;
                TR _E2 = _pt2 + _z2 + _m2 ;
                t = sqrt(_E2);
                xyz[2]=sqrt(_z2)*CPPFileIO::mysign(_eta);
            }

            inline TR & operator [] (const size_t ref)
            { if (ref > 2) { return t; } else { return xyz[ref]; } }

            inline TR operator [] (const size_t ref) const
            { if (ref > 2) { return t; } else { return xyz[ref]; } }

            inline TR pt2 () const { return xyz.pt2 (); }
            inline TR pt () const { return xyz.pt (); }
            inline TR p2 () const { return xyz.p2 (); }
            inline TR p () const { return xyz.p (); }
            inline TR phi () const { return xyz.phi (); }
            inline TR m2 () const { return CPPFileIO::mymod ((t * t) - p2 ()); }
            inline TR n2 () const { return CPPFileIO::mymod ((t * t) + p2 ()); }
            inline TR eta () const { return (0.5 * log ((t + xyz.z) / (t - xyz.z))); }
            inline TR meta () const { return CPPFileIO::mymod (eta ()); }
            inline TR peta () const { return xyz.eta (); }
            inline TR pmeta () const { return xyz.meta (); }
            inline TR m () const { return sqrt (m2 ()); }
            inline TR n () const { return sqrt (n2 ()); }
            inline TR dphi (const lorentz4vector < TR > b) const { return xyz.dphi (b.xyz); }
            inline lorentz4vector <TR> operator + (const lorentz4vector < TR > b) const
            { return lorentz4vector <TR> (xyz + b.xyz, t + b.t); }

            inline lorentz4vector <TR> operator - (const lorentz4vector < TR > b) const
            { return lorentz4vector <TR> (xyz - b.xyz, t - b.t); }

            inline TR operator * (const lorentz4vector <TR> b) const
            { return (t * b.t) - (xyz * b.xyz); }

            inline lorentz4vector < TR > operator * (const TR b) const
            { return lorentz4vector < TR > (xyz * b, t * b); }

            inline lorentz4vector < TR > operator / (const TR b) const
            { return lorentz4vector < TR > (xyz / b, t / b); }

            inline void operator = ( const euclid3vector < TR > other ) {
                xyz = other     ;
                t   = other.p() ;
            }
            inline void operator = ( const lorentz4vector < TR > other ) {
                xyz = other.xyz ;
                t   = other.t ;
            }
            inline TR pcone2 (const lorentz4vector < TR > b) const {
                TR tphi = xyz.dphi (b.xyz);
                tphi = tphi * tphi;
                TR teta = peta () - b.peta ();
                teta = teta * teta;
                TR ret = teta + tphi;
                return ret;
            }
            inline TR pcone (const lorentz4vector < TR > b) const { return sqrt (pcone2 (b)); }
            inline TR cone2 (const lorentz4vector < TR > b) const {
                TR tphi = xyz.dphi (b.xyz);
                tphi = tphi * tphi;
                TR teta = eta () - b.eta ();
                teta = teta * teta;
                TR ret = teta + tphi;
                return ret;
            }
            inline TR cone (const lorentz4vector < TR > b) const { return sqrt (cone2 (b)); }
            inline TR operator  () (const lorentz4vector < TR > b) const { return cone (b); }
            inline lorentz4vector < TR > flip () const
            { return lorentz4vector < TR > (xyz.flip (), t); }

            inline lorentz4vector < TR > trans () const
            { return lorentz4vector < TR > (xyz.trans (), t); }

            inline lorentz4vector < TR > dir () const
            { return lorentz4vector < TR > (xyz.dir (), t); }

            inline void operator += (const lorentz4vector<TR>b) {xyz+=b.xyz;t+=b.t;}
            inline void operator -= (const lorentz4vector<TR>b) {xyz-=b.xyz;t-=b.t;}
            inline void operator *= (const lorentz4vector<TR>b) {xyz*=b.xyz;t*=b.t;}
            inline void operator /= (const lorentz4vector<TR>b) {xyz/=b.xyz;t/=b.t;}
            inline bool operator > (const lorentz4vector < TR > b) const { return t < b.t ; }
            inline bool operator < (const lorentz4vector < TR > b) const { return t > b.t ; }
            inline ssize_t operator >> (CPPFileIO::FileFD & f) const { return f.multiwrite2file (*this); }
            inline ssize_t operator << (CPPFileIO::FileFD & f) const { return f.multiread2file (*this); }
            inline bool cleared () const { return (t < 0); }
            inline bool pass () const { return (t > 0); }
            inline void clearthis () { t = -1; xyz = euclid3vector < TR > (0, 0, 0); }
            inline bool operator == (const lorentz4vector < TR > b) const {
                lorentz4vector < TR > tmp = (*this) - b;
                TR diff = tmp.n2 ();
                diff = CPPFileIO::mymod (diff);
                return diff < VECTOR_EQUALITY_LIMIT;
            }
            inline TR gamma () const { return (TR) t / m (); }
            inline TR gamma2 () const { return t * t / m2 (); }
            inline TR beta () const {
                TR g = (TR) gamma2 ();
                g = 1.0 / g;
                g = 1.0 - g;
                return sqrt (g);
            }
            inline euclid3vector <TR> Velocity () const { return xyz.dir () * beta (); }
            inline lorentz4vector <TR> LorentzBoost (const euclid3vector < TR > booster) const {
                euclid3vector < TR > parallel = booster * ((xyz * booster) / booster.p2 ());
                euclid3vector < TR > perpendicular = xyz - parallel;
                TR gm = booster.p2 ();
                gm = 1.0 - gm;
                gm = (1.0 / gm);
                gm = sqrt (gm);
                lorentz4vector < TR > ret;
                ret.t = gm * (t - (parallel * booster));
                parallel = (parallel - (booster * t)) * (TR) gm;
                ret.xyz = parallel + perpendicular;
                return ret;
            }
            inline lorentz4vector < TR > LorentzBoostGamma (const euclid3vector <TR> booster) const {
                TR gm2  = (TR) booster.p2 ()        ;
                if (gm2<1.0+SMALL_EPSILON) { return *this ; }
                else {
                    TR gm    = (TR) sqrt       (gm2)     ;
                    TR beta2 = (TR) 1.0    -   (1.0/gm2) ;
                    TR beta  = (TR) sqrt       (beta2)   ;
                    euclid3vector < TR > dir = booster / (TR)gm   ;
                    euclid3vector < TR > vel = dir     * (TR)beta ;
                    euclid3vector < TR > parallel      = dir * (dir*xyz) ;
                    euclid3vector < TR > perpendicular = xyz - parallel  ;
                    lorentz4vector < TR > ret ; /* Evaluate the vector: */ {
                        ret.t = ( t - (parallel*vel) ) * (TR)gm ;
                        parallel = ( parallel - (vel*t) ) * (TR)gm;
                        ret.xyz = parallel + perpendicular;
                    }
                    return ret;
                }
            }
            inline lorentz4vector < TR > BoostToRestFrame (const lorentz4vector < TR > booster) const
            { return LorentzBoostGamma(booster.xyz.dir()*booster[3]/booster.m()); }

            #ifdef __FASTJET_PSEUDOJET_HH__
            inline fastjet::PseudoJet getpseudojet () const { return fastjet::PseudoJet (xyz[0], xyz[1], xyz[2], t); }
            inline void operator = (const fastjet::PseudoJet & injet) {this[0]=lorentz4vector<TR>(injet);}
            lorentz4vector (const fastjet::PseudoJet & injet) {
                t      = injet.e  () ;
                xyz[2] = injet.pz () ;
                xyz[1] = injet.py () ;
                xyz[0] = injet.px () ;
            }
            #endif

            lorentz4vector (const TR _x = 0, const TR _y = 0, const TR _z = 0, const TR _t = 0):xyz (_x, _y, _z) { t = _t; }
            lorentz4vector (const euclid3vector < TR > a, const TR _t = -1) :xyz (a) { if(_t<0) {t=a.p();} else {t=_t;} }
            lorentz4vector (const plane2vector  < TR > a, const TR _z = 0 , const TR _t = -1) :xyz (a)
            { if (_t<0) {t=a.pt();} else {t=_t;} xyz.z = _z ; }
            lorentz4vector (const lorentz4vector < TR > &a):xyz (a.xyz) { t = a.t; }
            ~lorentz4vector(){}
        };
        template < typename TR=double, typename TI=int > class DelphesVectors {
        public:
            lorentz4vector <TR> momentum      ;
            TI                  Charge        ;
            TR                  Eem, Ehad, Emu;
            inline bool IsElectron () {
                bool ret = (CPPFileIO::mymod(Charge)==1) && (Eem/momentum[3]>0.9) ;
                return ret ;
            }
            inline bool IsMuon () {
                bool ret = (CPPFileIO::mymod(Charge)==1) && (Emu/momentum[3]>0.9) ;
                return ret ;
            }
            inline bool IsLepton () { return IsMuon() || IsElectron () ; }
            inline void Set_Ehad_Fraction (const TR InFrac) { Ehad = momentum[3] * InFrac ; }
            inline void Set_Eem_Fraction  (const TR InFrac) { Eem  = momentum[3] * InFrac ; }
            inline void Set_Emu_Fraction  (const TR InFrac) { Emu  = momentum[3] * InFrac ; }
            inline void SetPtEtaPhiM      (const TR _pt, const TR _eta, const TR _phi, const TR _m)
            { momentum.SetPtEtaPhiM (_pt,_eta,_phi,_m) ; }
            inline TR & operator [] (const size_t ref) {
                if      ( ref <= 3 ) { return momentum[ref] ; }
                else if ( ref == 4 ) { return Eem           ; }
                else if ( ref == 5 ) { return Ehad          ; }
                else if ( ref == 6 ) { return Emu           ; }
            }
            inline TR operator [] (const size_t ref) const {
                if      ( ref <= 3 ) { return momentum[ref] ; }
                else if ( ref == 4 ) { return Eem           ; }
                else if ( ref == 5 ) { return Ehad          ; }
                else if ( ref == 6 ) { return Emu           ; }
            }
            inline TR pt2   () const { return momentum.pt2  () ; }
            inline TR pt    () const { return momentum.pt   () ; }
            inline TR p2    () const { return momentum.p2   () ; }
            inline TR p     () const { return momentum.p    () ; }
            inline TR phi   () const { return momentum.phi  () ; }
            inline TR m2    () const { return momentum.m2   () ; }
            inline TR n2    () const { return momentum.n2   () ; }
            inline TR eta   () const { return momentum.eta  () ; }
            inline TR meta  () const { return momentum.meta () ; }
            inline TR peta  () const { return momentum.peta () ; }
            inline TR pmeta () const { return momentum.meta () ; }
            inline TR m     () const { return momentum.m    () ; }
            inline TR n     () const { return momentum.n    () ; }
            inline TR dphi       (const DelphesVectors <TR,TI> b) const { return momentum.dphi (b.momentum) ; }
            inline TR operator * (const DelphesVectors <TR,TI> b) const { return momentum * b.momentum      ; }
            inline DelphesVectors <TR,TI> operator * (const TR b) const
            { return DelphesVectors <TR,TI> (momentum*b,Eem*b,Ehad*b,Emu*b,Charge); }
            inline DelphesVectors < TR > operator / (const TR b) const
            { return DelphesVectors <TR,TI> (momentum/b,Eem/b,Ehad/b,Emu/b,Charge); }
            inline void operator = ( const DelphesVectors <TR,TI> other )
            { momentum=other.momentum; Eem=other.Eem; Ehad=other.Ehad; Emu=other.Emu; Charge=other.Charge;}
            inline DelphesVectors <TR,TI> operator + (const DelphesVectors <TR,TI> b) const {
                return DelphesVectors <TR,TI> (
                    momentum+b.momentum,
                    Eem+b.Eem,
                    Ehad+b.Ehad,
                    Emu+b.Emu,
                    Charge+b.Charge
                );
            }
            inline DelphesVectors <TR,TI> operator - (const DelphesVectors <TR,TI> b) const {
                return DelphesVectors <TR,TI> (
                    momentum-b.momentum,
                    Eem-b.Eem,
                    Ehad-b.Ehad,
                    Emu-b.Emu,
                    Charge-b.Charge
                );
            }
            inline TR cone (const DelphesVectors <TR,TI> b) const { return momentum.cone(b.momentum); }
            inline TR operator () (const DelphesVectors <TR,TI> b) const { return momentum(b.momentum); }
            inline bool operator > (const DelphesVectors <TR,TI> b) const { return momentum.pt2 () > b.momentum.pt2 (); }
            inline bool operator < (const DelphesVectors <TR,TI> b) const { return momentum.pt2 () < b.momentum.pt2 (); }
            inline ssize_t operator >> (CPPFileIO::FileFD & f) const { return f.multiwrite2file (*this); }
            inline ssize_t operator << (CPPFileIO::FileFD & f) const { return f.multiread2file (*this); }
            inline bool cleared () const { return (momentum[3] < 0); }
            inline bool pass () const { return (momentum[3] > 0); }
            inline void clearthis () { momentum.clearthis(); Eem=-10000; Ehad=-10000; Emu=-10000; Charge=0; }
            inline TR gamma () const { return (TR) momentum[3] / momentum.m(); }
            inline TR gamma2 () const { return (TR) momentum[3] * momentum[3] / momentum.m2(); }
            inline TR beta () const {return momentum.beta();}
            inline euclid3vector < TR > Velocity () const { return momentum.Velocity(); }
            inline DelphesVectors <TR,TI> LorentzBoost (const euclid3vector < TR > booster) const {
                lorentz4vector<TR>ret=momentum.LorentzBoost(booster);
                TR ratio = ret[3] / momentum[3] ;
                TR _Eem=Eem*ratio, _Ehad=Ehad*ratio, _Emu=Emu*ratio;
                return DelphesVectors <TR,TI> (ret,_Eem,_Ehad,_Emu,Charge) ;
            }
            inline DelphesVectors <TR,TI> LorentzBoostGamma (const euclid3vector < TR > booster) const {
                lorentz4vector<TR>ret=momentum.LorentzBoostGamma(booster);
                TR ratio=ret[3]/momentum[3];
                TR _Eem=Eem*ratio, _Ehad=Ehad*ratio, _Emu=Emu*ratio;
                return DelphesVectors <TR,TI> (ret,_Eem,_Ehad,_Emu,Charge) ;
            }
            #ifdef __FASTJET_PSEUDOJET_HH__
            inline fastjet::PseudoJet getpseudojet () const
            { return fastjet::PseudoJet (momentum[0],momentum[1],momentum[2],momentum[3]) ; }
            #endif
            DelphesVectors
            (const lorentz4vector<TR>_momentum, const TR _Eem=0, const TR _Ehad=0, const TR _Emu=0, const TI _Charge=0)
            { momentum=_momentum; Eem=_Eem; Ehad=_Ehad; Emu=_Emu; Charge=_Charge; }
            DelphesVectors
            (const TR _x=0, const TR _y=0, const TR _z=0, const TR _t=0, const TR _Eem=0, const TR _Ehad=0, const TR _Emu=0, const TI _Charge=0)
            { momentum=lorentz4vector<TR>(_x,_y,_z,_t); Eem=_Eem; Ehad=_Ehad; Emu=_Emu; Charge=_Charge; }
            ~DelphesVectors () {}
        } ;
        template < typename TRF=double, typename TRI=long > class ParticleNode   {
        private:
            lorentz4vector <TRF> momentum;
            TRI d1, d2, pid;
        public:
            inline TRI const id () const { return pid; }
            inline bool isFinal () const { return (d1 == 0) && (d2 == 0); }
            inline TRI daughter1 () const { return d1; }
            inline TRI daughter2 () const { return d2; }
            inline TRF px () const { return momentum[0]; }
            inline TRF py () const { return momentum[1]; }
            inline TRF pz () const { return momentum[2]; }
            inline TRF e () const { return momentum[3]; }
            inline TRF pt () const { return momentum.pt (); }
            inline TRF eta () const { return momentum.eta (); }
            inline TRF modeta () const { return CPPFileIO::mymod (eta()); }
            inline bool isDetectable () const {
                bool ret = (pt () > 0.5) && (modeta () < 6.0);
                ret = ret && detectable (pid);
                return ret;
            }
            inline bool IsGood () const { return isFinal () && isDetectable (); }
            inline bool IsLepton () const { return islepton (pid); }
            inline bool IsBLike () const { return isblike(pid); }
            inline bool IsBMeson () const {
                TRI tmppid = CPPFileIO::mymod(pid) ;
                return ((tmppid>100)&&isblike(tmppid));
            }
            inline bool IsBQuakr () const {
                TRI tmppid = CPPFileIO::mymod(pid) ;
                return (tmppid==PID::BOTTOM);
            }
            inline TRF operator [] (size_t i) { return momentum[i] ; }
            inline lorentz4vector <TRF> & getvec () { return momentum; }
            inline lorentz4vector <TRF> const getvec () const { return momentum; }
            inline lorentz4vector <TRF> & operator () () { return momentum; }
            inline lorentz4vector <TRF> const operator () () const { return momentum; }
            inline TRF operator  () (ParticleNode b) { return momentum (b.momentum); }
            inline TRF operator  () (lorentz4vector <TRF> b) { return momentum (b); }
            inline TRF pcone (ParticleNode b) { return momentum.pcone (b.momentum); }
            inline TRF pcone (lorentz4vector <TRF> b) { return momentum.pcone (b); }
            ParticleNode () {d1=-1;d2= -1;pid = 0;momentum.clearthis ();}
            ParticleNode (TRF _x, TRF _y, TRF _z, TRF _t, TRI _d1, TRI _d2, TRI _pid) :
            momentum (_x, _y, _z, _t) { d1 = _d1;d2 = _d2;pid = _pid; }
            #ifdef Pythia8_Pythia_H
            inline fastjet::PseudoJet getpseudojet () { return momentum.getpseudojet (); }
            ParticleNode (const Pythia8::Particle & part) {
                momentum = lorentz4vector <TRF> (part.px (), part.py (), part.pz (), part.e ());
                pid = part.id ();
                if (part.isFinal ()) { d1 = -1; d2 = -1; }
                else { d1 = part.daughter1 (); d2 = part.daughter2 (); }
            }
            #endif
            ~ParticleNode () {}
        };
        #ifdef __FASTJET_PSEUDOJET_HH__
        template < typename TR=double > class JetContainer : public lorentz4vector <TR> {
        private:
            inline lorentz4vector <TR> & CstGet (size_t i) {return vectors[0][constituents[i]];}
            std::vector <int> constituents;
            std::vector <lorentz4vector <TR>> *vectors;
        public:
            size_t TAG;
            fastjet::PseudoJet * injet;
            bool tau_tag () {
                if (checkbit(TAG,TAUTAG)) {return true;}
                else {return false;}
            }
            bool bot_tag () {
                if (checkbit(TAG,BTAG)) {return true;}
                else {return false;}
            }
            bool bms_tag () {
                if (checkbit(TAG,BMESONTAG)) {return true;}
                else {return false;}
            }
            JetContainer (std::vector <lorentz4vector<TR>> & _vectors, fastjet::PseudoJet & _injet) {
                TAG = NOTHING;
                /* Get some values: */  {
                    injet = &_injet;
                    vectors = &_vectors;
                    this[0][0] = _injet.px ();
                    this[0][1] = _injet.py ();
                    this[0][2] = _injet.pz ();
                    this[0][3] = _injet.e ();
                }
                /* Get the constituents: */  {
                    constituents.clear ();
                    std::vector < fastjet::PseudoJet > _constituents = _injet.constituents ();
                    for (size_t j = 0; j < _constituents.size (); j++)
                    { constituents.push_back (_constituents[j].user_index ()); }
                }
            }
            ~JetContainer () {}
            inline lorentz4vector <TR> & operator  () (size_t i) {return CstGet (i);}
            inline size_t operator  () () {return constituents.size ();}
        };
        #endif
        class sortorder {
        public:
            bool ret;
            sortorder (bool _ret = true) {ret = _ret;}
            ~sortorder () {}
            template <typename T> inline bool operator  () (VECTORS::lorentz4vector <T> & a, VECTORS::lorentz4vector <T> & b) {
                if (a>b) {return ret;}
                else {return !ret;}
            }
            template <typename T> inline bool operator  () (VECTORS::lorentz4vector <T> * a, VECTORS::lorentz4vector <T> * b) {
                if ((*a)>(*b)) {return ret;}
                else {return !ret;}
            }
        };
        template <typename T> void cleanup_vectors ( std::vector <lorentz4vector <T>> & thevectors) {
            std::vector <VECTORS::lorentz4vector <T>> tmp_thevectors;
            for (size_t i = 0; i < thevectors.size (); i++)
                if (!thevectors[i].cleared ()) {
                    tmp_thevectors.push_back (thevectors[i]);
                }
                if (tmp_thevectors.size () > 0) {
                    thevectors.resize (tmp_thevectors.size ());
                    size_t n = thevectors.size () * sizeof (VECTORS::lorentz4vector <T>);
                    memcpy ((void *) &(thevectors[0]), (const void *) &(tmp_thevectors[0]), (size_t) n);
                } else { thevectors.clear (); }
        }
        template <typename TR> class RestTopDecays {
        private:
            TR          ST2 , CT2 , SP2 , CP2 ;
            TR          ST3 , CT3 , SP3 , CP3 ;
            euclid3vector  <TR> Velocity      ;
            lorentz4vector <TR> Daughters [3] ;
            lorentz4vector <TR> InVectors [3] ;
            inline bool ClearAll        () {
                Angle            = -10000.0 ;
                SpinAngle        = -10000.0 ;
                Matrix           =      0.0 ;
                MatrixSpin       =      0.0 ;
                Weight           =      0.0 ;
                WeightSpin       =      0.0 ;
                PhaseSpaceWeight =      0.0 ;
                passed           =    false ;
                return               passed ;
            }
            inline void SetPreliminary  () {
                MT  = MASS::TOP                      ;
                TOP = lorentz4vector <TR> (0,0,0,MT) ;
            }
            inline void SetDirections   () {
                ST2 = sin (T2) ; CT2 = cos (T2) ;
                ST3 = sin (T3) ; CT3 = cos (T3) ;
                SP2 = sin (P2) ; CP2 = cos (P2) ;
                SP3 = sin (P3) ; CP3 = cos (P3) ;
                dir[0] = euclid3vector <TR> (ST2*CP2,ST2*SP2,CT2) ;
                dir[1] = euclid3vector <TR> (ST3*CP3,ST3*SP3,CT3) ;
                Angle  = dir[0] * dir[1]  ;
            }
            inline bool EvalVectorSlave () {
                E3     = ((2.0*E2)-MT) / ( 2.0 * (((E2/MT)*(1.0-Angle))-1.0) ) ;
                passed = ( E3 >= 0 ) ;
                if (!passed) { return ClearAll () ; }
                Daughters [0] = dir[0] * E2                       ;
                Daughters [1] = dir[1] * E3                       ;
                Daughters [2] = TOP - Daughters[0] - Daughters[1] ;
                return passed ;
            }
            inline bool EvalVectors     () {
                SetPreliminary () ;
                passed = ( E2 <= (MT/2.0) ) && ( E2 >= 0 ) ;
                if (!passed) { return ClearAll () ; }
                SetDirections () ;
                return EvalVectorSlave () ;
            }
            inline bool PhaseSpace      () {
                if (!passed) { return ClearAll () ; }
                PhaseSpaceWeight = ( ((1.0-Angle)*E2) - MT ) ;
                PhaseSpaceWeight = 8 * PhaseSpaceWeight * PhaseSpaceWeight ;
                PhaseSpaceWeight = PhaseSpaceWeight / E2*MT*((2*E2)-MT)*ST2*ST3 ;
                return passed ;
            }
            inline bool EvalMatrix      () {
                if (!passed) { return ClearAll () ; }
                double tmp     = MASS::W              / MT ;
                double complex = DECAY_WIDTH::W * tmp / MT ;
                double real    = 1 - (tmp*tmp) - (2*E2/MT) ;
                Matrix         = (E3*MT*MT) * (MT-(2*E3)) / ( (real*real) + (complex*complex) ) ;
                return passed;
            }
            inline bool FinalWeight     () {
                if (!passed) { return ClearAll () ; }
                Weight = Matrix * PhaseSpaceWeight ;
                return passed ;
            }
            inline bool EvalChain       () {
                if (PhaseSpace()) if (EvalMatrix()) if (FinalWeight()) {return true;}
                return ClearAll () ;
            }
            inline bool EvalSpinMatrix ( euclid3vector  <TR> SpinDir ) {
                if (!passed) { return ClearAll () ; }
                MatrixSpin = ( (dir[1]*SpinDir) + 1 ) * Matrix ;
                WeightSpin = MatrixSpin * PhaseSpaceWeight ;
                return passed ;
            }
            inline bool permute        (size_t i, size_t j) {
                size_t k     = 3 - i - j    ;
                Daughters[0] = InVectors[i] ;
                Daughters[1] = InVectors[j] ;
                Daughters[2] = InVectors[k] ;
                dir[0] = Daughters[0].xyz.dir() ;
                dir[1] = Daughters[1].xyz.dir() ;
                Angle  = dir[0] * dir[1] ;
                ST2 = dir[0].pt() ;
                ST3 = dir[1].pt() ;
                E2  = Daughters[0][3] ;
                E3  = Daughters[1][3] ;
                passed = true  ;
                return EvalChain () ;
            }
            inline bool ChangeE2       (double _E2) {
                E2 = _E2 ;
                passed = ( E2 <= (MT/2.0) ) && ( E2 >= 0 ) ;
                if (!passed) { return ClearAll () ; }
                if (EvalVectorSlave()) {return EvalChain ();}
                return ClearAll () ;
            }

            inline bool Init (lorentz4vector <TR> a, lorentz4vector <TR> b, lorentz4vector <TR> c) {
                InVectors[0] = a     ;
                InVectors[1] = b     ;
                InVectors[2] = c     ;
                TOP          = InVectors[2] + InVectors[1] + InVectors[0] ;
                Velocity     = TOP.xyz.dir() ;
                Velocity     = Velocity*(TOP[3]/TOP.m()) ;
                TOP          = TOP.LorentzBoostGamma          (Velocity) ;
                InVectors[0] = InVectors[0].LorentzBoostGamma (Velocity) ;
                InVectors[1] = InVectors[1].LorentzBoostGamma (Velocity) ;
                InVectors[2] = InVectors[2].LorentzBoostGamma (Velocity) ;
                return         permute (0,1)                             ;
            }
            inline void Init (lorentz4vector <TR> *_Daughters) { Init (_Daughters[0],_Daughters[1],_Daughters[2]) ; }
            inline bool Init (TR _E2, TR _T2, TR _P2, TR _T3, TR _P3 ) {
                E2=_E2; T2=_T2; P2=_P2; T3=_T3; P3=_P3;
                if (EvalVectors()) if (PhaseSpace()) if (EvalMatrix()) if (FinalWeight()) {return true;}
                return false ;
            }
        public:

            euclid3vector  <TR> dir        [3]  ;
            euclid3vector  <TR> SpinVector      ;
            lorentz4vector <TR> TOP             ;

            TR E2 , T2 , P2 , T3 , P3 , E3 , MT ;
            TR Angle  , SpinAngle  ;
            TR Matrix , MatrixSpin ;
            TR Weight , WeightSpin ;
            TR PhaseSpaceWeight    ;
            bool passed            ;

            inline TR                  operator () ( TR _E2                                 ) {
                if (!passed) {return 0;}
                ChangeE2(_E2); return Weight;
            }
            inline TR                  operator () ( size_t i , size_t j                    ) {
                if (permute(i,j)) {return Weight ;}
                else {return 0;}
            }
            inline bool                operator () ( lorentz4vector <TR> *_Daughters        ) { return Init ( _Daughters          ) ; }
            inline bool                operator () ( TR _E2, TR _T2, TR _P2, TR _T3, TR _P3 ) { return Init ( _E2,_T2,_P2,_T3,_P3 ) ; }
            inline TR                  operator () ( euclid3vector  <TR> SpinDir            ) {
                if (!passed) { return 0 ; }
                return EvalSpinMatrix (SpinDir) ;
            }
            inline TR                  operator () ( TR TS , TR PS                          ) {
                if (!passed) { return 0 ; }
                TR STS = sin (TS) ; TR CTS = cos (TS) ;
                TR SPS = sin (PS) ; TR CPS = cos (PS) ;
                euclid3vector <TR>     SpinDir  (STS*CPS,STS*SPS,CTS) ;
                return EvalSpinMatrix (SpinDir)                       ;
            }
            inline lorentz4vector <TR> operator [] ( size_t i                               ) { return Daughters [i] ; }

            RestTopDecays(){}
            RestTopDecays ( lorentz4vector <TR> *_Daughters        ) { Init ( _Daughters          ) ; }
            RestTopDecays ( TR _E2, TR _T2, TR _P2, TR _T3, TR _P3 ) { Init ( _E2,_T2,_P2,_T3,_P3 ) ; }
            ~RestTopDecays(){}
        };
        template < typename TR=double, typename TI=long >
        class GenParticles : public std::vector <ParticleNode<TR,TI>> {
        public:
            typedef ParticleNode <TR,TI> TYPE_Element ;
            typedef GenParticles <TR,TI> TYPE_Self    ;
        public:
            inline TR CalcISO (size_t IDX, double DeltaR) {
                TR ret = 0 ;
                for (size_t i=0;i<this->size();i++)
                if (
                   (i!=IDX) &&
                   (this[0][i].IsGood()) &&
                   (this[0][i].getvec()(this[0][IDX].getvec())<DeltaR)
                ) { ret += this[0][i].pt() ; }
                return ret / this[0][IDX].pt() ;
            }
            inline size_t FindPID
            ( long   const PID) const {
                TYPE_Self const & SELF = this[0] ;
                size_t ret = 0 ;
                for(size_t i=0;(i<SELF.size())&&(ret==0);i++)if(SELF[i].id()==PID){ret=i;}
                return ret;
            }
            inline size_t FindPIDMod
            ( long const PID) const {
                TYPE_Self const & SELF = this[0] ;
                size_t ret = 0 ;
                for(size_t i=0;(i<SELF.size())&&(ret==0);i++){
                    if (
                        ( SELF[i].id() ==  PID ) ||
                        ( SELF[i].id() == -PID )
                    ) {ret=i;}
                }
                return ret;
            }
            inline size_t Recurse
            ( size_t const idx) const {
                if (idx > 0) {
                    TYPE_Self const & SELF = this[0] ;
                    int PID = SELF[idx].id ();
                    size_t d1 = SELF[idx].daughter1 ();
                    size_t d2 = SELF[idx].daughter2 ();
                    if ((d1 > idx) && (SELF[d1].id () == PID)) {
                        return Recurse(d1);
                    } else if ((d2 > idx) && (SELF[d2].id () == PID)) {
                        return Recurse(d2);
                    }
                }
                return idx;
            }
            inline TI FindDaughter (
                long ParentID,
                long DPID
            ) {
                ParentID =
                    Recurse (ParentID) ;
                //
                long dt [2] = {
                    this[0][ParentID]
                        .daughter1 () ,
                    this[0][ParentID]
                        .daughter2 ()
                } ;
                long dpid [2] = {
                    this[0][dt[0]].id () ,
                    this[0][dt[1]].id ()
                } ;
                //
                if (dpid[0]==DPID)
                    { return dt[0] ; }
                //
                else if (dpid[1]==DPID)
                    { return dt[1] ; }
                //
                else { return 0 ; }
                //
            }
            template <typename T1>
            inline void ReadFromDelphes
            (T1 & inref) {
                TYPE_Self & SELF = this[0] ;
                size_t limit = inref.Particle_ ;
                SELF.resize(limit);
                for(size_t i=0;i<limit;i++){
                    TR x   = inref.Particle_Px  [i] ;
                    TR y   = inref.Particle_Py  [i] ;
                    TR z   = inref.Particle_Pz  [i] ;
                    TR t   = inref.Particle_E   [i] ;
                    TI D1  = inref.Particle_D1  [i] ;
                    TI D2  = inref.Particle_D2  [i] ;
                    TI PID = inref.Particle_PID [i] ;
                    if(inref.Particle_Status[i]==1)
                        {D1=0;D2=0;}
                    //
                    SELF[i]=TYPE_Element(x,y,z,t,D1,D2,PID);
                }
            }
            #ifdef Pythia8_Pythia_H
            inline void ReadFromPythia
            (Pythia8::Pythia const & pythia) {
                for(size_t i=0;i<pythia.event.size();i++){
                    TYPE_Element tmp
                        (pythia.event[i]) ;
                    //
                    this->push_back(tmp);
                }
            }
            #endif
        };
    }
    typedef VECTORS::plane2vector   < float       > vector2         ;
    typedef VECTORS::euclid3vector  < float       > vector3         ;
    typedef VECTORS::lorentz4vector < float       > vector4         ;
    typedef VECTORS::RestTopDecays  < float       > topdecayelement ;
    typedef VECTORS::ParticleNode   < float , int > pythia_node     ;
    typedef std::vector < vector2 > vector2s ;
    typedef std::vector < vector3 > vector3s ;
    typedef std::vector < vector4 > vector4s ;
    typedef std::vector < pythia_node  > pythia_nodes  ;
    #ifdef __FASTJET_PSEUDOJET_HH__
    typedef VECTORS::JetContainer <              float > JetContainer  ;
    typedef std::vector           <       JetContainer > JetContainers ;
    typedef std::vector           < fastjet::PseudoJet > pseudojets    ;
    #endif
}

namespace NewHEPHeaders /* The top reconstruction parts: */ {
    namespace TopReconstruction {
        class reco_top_had  {
        private:
            vector4 *njet[2];
            vector4 *bjet;
        public:
            vector4 top, w;
            bool pass;
            inline void clearthis () {
                top.clearthis ();
                w.clearthis ();
                pass = false;
            }
            inline bool cleared () {
                bool ret = top.cleared () || w.cleared () || (!pass);
                return ret;
            }
            inline double error_w () {
                if (cleared ()) {
                    return 1000000000;
                } else {
                    const double sigma_w = 10;
                    double ret = (w.m () - MASS::W) / sigma_w;
                    ret = ret * ret;
                    return ret;
                }
            }
            inline double error_top () {
                if (cleared ()) {
                    return 1000000000;
                } else {
                    const double sigma_top = 25;
                    double ret = (top.m () - MASS::TOP) / sigma_top;
                    ret = ret * ret;
                    return ret;
                }
            }
            inline double error () {
                if (cleared ()) { return 1000000000; }
                else { return sqrt (error_top () + error_w ()); }
            }
            inline bool operator > (reco_top_had other) { return error () > other.error () ; }
            inline bool operator < (reco_top_had other) { return error () < other.error () ; }
            inline bool operator > (double other)       { return error () > other          ; }
            inline bool operator < (double other)       { return error () < other          ; }
            inline void clear_parts () {
                njet[0]->clearthis () ;
                njet[1]->clearthis () ;
                bjet->clearthis    () ;
            }
            reco_top_had () {clearthis ();}
            reco_top_had (vector4 & _bjet, vector4 & _njet1, vector4 & _njet0) {
                pass = false;
                top.clearthis ();
                w.clearthis ();
                njet[0] = &_njet0;
                njet[1] = &_njet1;
                bjet = &_bjet;
                if (
                    (!njet[0]->cleared ()) &&
                    (!njet[1]->cleared ()) &&
                    (!bjet->cleared ())
                ) {
                    w = (*njet[0]) + (*njet[1]);
                    top = w + (*bjet);
                    pass = true;
                }
            }
        };
        class reco_top_lept {
        private:
            vector4 * bjet, *lept;
            vector2 * met ;
            void construct ( vector4 & _bjet , vector4 & _lept , vector2 & _met ) {
                clearthis ();
                lept = &_lept;
                met = & _met ;
                bjet = &_bjet;
                const double WMASS2 = MASS::W * MASS::W;
                pnu[0] = NewHEPHeaders::vector4(*met) ;
                pnu[1] = pnu[0];
                double k = (WMASS2 / 2.0) + ((*lept)[0] * (*met)[0]) + ((*lept)[1] * (*met)[1]);
                k = k / (*lept)[3];
                double a = (*lept)[2] / (*lept)[3];
                a = a * a;
                a = a - 1.0;
                double b = 2.0 * k * (*lept)[2] / (*lept)[3];
                double c = (k * k) - ((*met)[0] * (*met)[0]) - ((*met)[1] * (*met)[1]);
                double dis = (b * b) - (4.0 * a * c);
                if (dis > 0) {
                    pnu[0][2] = (-b + sqrt (dis)) / (2.0 * a);
                    pnu[0][3] = pnu[0].p ();
                    pnu[1][2] = (-b - sqrt (dis)) / (2.0 * a);
                    pnu[1][3] = pnu[1].p ();
                    double diff0 = (((*bjet) + pnu[0] + (*lept)).m ()) - MASS::TOP;
                    diff0 = CPPFileIO::mymod (diff0);
                    double diff1 = (((*bjet) + pnu[1] + (*lept)).m ()) - MASS::TOP;
                    diff1 = CPPFileIO::mymod (diff1);
                    if (diff0 > diff1) {
                        CPPFileIO::myswap (pnu[0], pnu[1]);
                    }
                    w = (pnu[0]) + (*lept);
                    top = w + (*bjet);
                    pass = true;
                    if (CPPFileIO::mymod (w.m () - MASS::W) > 1.0) {
                        printf ("ERROR: Something has gone blatently wrong... W Mass error \n");
                    }
                } else {clearthis ();}

            }
        public:
            vector4 top, pnu[2], w;
            bool pass;

            inline void clearthis () {
                top.clearthis ();
                pnu[0].clearthis ();
                pnu[1].clearthis ();
                w.clearthis ();
                pass = false;
            }
            inline bool cleared () {
                bool ret = top.cleared () || w.cleared () || pnu[0].cleared () || (!pass);
                return ret;
            }
            inline double error () {
                if (cleared ()) {
                    return 1000000000;
                } else {
                    const double sigma_top = 15;
                    double ret = (top.m () - MASS::TOP) / sigma_top;
                    return CPPFileIO::mymod (ret);
                }
            }
            inline void clear_parts () {
                bjet->clearthis ();
                met->clearthis  ();
                lept->clearthis ();
            }
            inline bool operator > (reco_top_had other) { return error () > other.error (); }
            inline bool operator < (reco_top_had other) { return error () < other.error (); }
            inline bool operator > (reco_top_lept other) { return error () > other.error (); }
            inline bool operator < (reco_top_lept other) { return error () < other.error (); }
            inline bool operator > (double other) { return error () > other; }
            inline bool operator < (double other) { return error () < other; }
            reco_top_lept () { clearthis (); }
            reco_top_lept ( vector4 & _bjet , vector4 & _lept , vector2 & _met )
            { construct (_bjet,_lept,_met) ; }

            reco_top_lept ( vector4 & _bjet , vector4 & _lept , vector4 & _met )
            { construct (_bjet,_lept,_met.xyz.xy) ; }
        };
    }
    typedef TopReconstruction::reco_top_had  reco_top_had  ;
    typedef TopReconstruction::reco_top_lept reco_top_lept ;
}

#ifdef __FASTJET_JETDEFINITION_HH__
namespace NewHEPHeaders /* Fastjet easy jet cluster: */ {
    namespace JET_ALGO {
        long KT  =  1 ;
        long CA  =  0 ;
        long AKT = -1 ;
    }
    class JetClusterInclusive : public pseudojets {
    public:
        typedef JetClusterInclusive TYPE_Self   ;
        typedef pseudojets          TYPE_Parent ;
    private:
        fastjet::JetAlgorithm      algo      ;
        pseudojets               & invectors ;
        fastjet::JetDefinition   * jet_def   ;
        fastjet::ClusterSequence * clust_seq ;
    public:
        JetClusterInclusive
        (pseudojets & _invectors, long _algo=-1, double const _Pt=20, double const _R=0.4) :
        invectors(_invectors) {
            TYPE_Parent & SELF = this[0] ;
            if      ( _algo == -1 ) { algo = fastjet::antikt_algorithm    ; }
            else if ( _algo ==  0 ) { algo = fastjet::cambridge_algorithm ; }
            else if ( _algo ==  1 ) { algo = fastjet::kt_algorithm        ; }
            jet_def   = new fastjet::JetDefinition   (      algo ,         _R ) ;
            clust_seq = new fastjet::ClusterSequence ( invectors , jet_def[0] ) ;
            SELF      = sorted_by_pt ( clust_seq->inclusive_jets (_Pt) ) ;
        }
        ~JetClusterInclusive () { delete jet_def ; delete clust_seq ; }
    } ;
    class JetClusterExclusive : public pseudojets {
    public:
        typedef JetClusterInclusive TYPE_Self   ;
        typedef pseudojets          TYPE_Parent ;
    private:
        fastjet::JetAlgorithm      algo      ;
        pseudojets const         & invectors ;
        fastjet::JetDefinition   * jet_def   ;
        fastjet::ClusterSequence * clust_seq ;
    public:
        JetClusterExclusive
        (pseudojets const & _invectors, long _algo=-1, double _Pt=20, int const _N=1) :
        invectors(_invectors) {
            TYPE_Parent & SELF = this[0] ;
            if      ( _algo == -1 ) { algo = fastjet::antikt_algorithm    ; }
            else if ( _algo ==  0 ) { algo = fastjet::cambridge_algorithm ; }
            else if ( _algo ==  1 ) { algo = fastjet::kt_algorithm        ; }
            jet_def   = new fastjet::JetDefinition   (      algo ,      100.0 ) ;
            clust_seq = new fastjet::ClusterSequence ( invectors , jet_def[0] ) ;
            SELF      = fastjet::sorted_by_pt ( clust_seq->exclusive_jets (_N) ) ;
        }
        ~JetClusterExclusive () { delete jet_def ; delete clust_seq ; }
    } ;

    template <size_t N, typename T> // N => dimensions of the image, T => data element type, either float or double (depending on the required accuracy)
    class MyJetImageGen { // The main class responsible for jet image formation.
    public:

        using TYPE_DATA = T ; // Defining some conventions...

        using vector4 =
            VECTORS::lorentz4vector // Using a custom implementation of lorentz 4 vector class
                <TYPE_DATA>
        ; //

        using vector3 =
            VECTORS::euclid3vector // using a custom implementation of 3 vector class
                <TYPE_DATA>
        ; //

        using vector4s =
            std::vector  // Collection of 4 momentum vectors.
                <vector4>
        ; //

        using InputArrayType =
            Tensors::NN::N2D_ARRAY // 2D array which holds the actual final image.
                <N,N,TYPE_DATA>
        ; //

        using FlatArrayType =
            Tensors::NN::ND_ARRAY <
                InputArrayType::SIZE(), // The same image array but interpreted as 1 D array (flattening).
                TYPE_DATA
            >
        ; //

        InputArrayType MainStore  ; // An instantiation of the image 2D array class
        vector4        FullJet    ; // A vector to hold the full jet before boosting
        vector4        BoostedJet ; // A vector to hold the jet after boosting
        bool           eventpass  ; // To decide whether the event is good or not

    private:
        inline InputArrayType
        Process (
            fastjet::PseudoJet const &
                injet
        ) {

            MainStore = 0.0   ; // Zero the image
            FullJet   = injet ; // store the full jet
            eventpass = false ; // no guarentee that jet is good yet

            TYPE_DATA constexpr E_0 = 1.0 ; // Our set of parameters for E_0 and M_0
            TYPE_DATA constexpr M_0 = 0.5 * E_0 ;

            TYPE_DATA constexpr P_0 =
                sqrt((E_0*E_0)-(M_0*M_0)) // Derived quantity using the two expressions above
            ; //

            TYPE_DATA const
                E_J = injet.e() // Energy of the input jet
            ; //
            TYPE_DATA const
                M_J = injet.m() // Mass of the input jet
            ; //
            TYPE_DATA const
                P_J = FullJet.p () // momentum of the input jet
            ; //

            TYPE_DATA const // Now calculate the gamma factor.
                GAMMA =
                    ((E_J*E_0)-(P_J*P_0)) /
                    (M_J*M_0)
            ; //

            vector3 dir = // To decide the direction of the boost
                FullJet.xyz.dir() * GAMMA
            ; //
            if(E_J<E_0){ // incorporating the decision
                dir = dir.flip () ;
            }

            pseudojets jetvectors = // Get the individual jet constituents
                injet.constituents ()
            ; //

            vector4s JetVectors ; // list of our 4 momentum vector implementation
            JetVectors.resize
                (jetvectors.size()) // Prepare the required memory to hold the boosted rescaled constituents
            ; //

            for(size_t i=0;i<jetvectors.size();i++){
                vector4 tmp =
                    jetvectors[i] // pseudojet -> vector4 conversion
                ; //
                tmp = tmp * (M_0/M_J) ; // Rescale so that mass of the jet is M_0
                JetVectors[i] = // record the boosted rescaled constituent vector
                    tmp
                    .LorentzBoostGamma(dir) // The actual lorentz boost step
                ; //
            }

            eventpass =
                (JetVectors.size()>2) // need atleast 3 vectors for gram-schmidt
            ; //

            if(eventpass){
                JetClusterExclusive // Take 3 hardest subjets by exclusive k_t clustering
                    jets (
                        jetvectors,
                        1,20,3
                    )
                ; //
                vector4 base [3] ; // classes to hold the basis 4 vectors
                vector3 e    [3] ; // classes to hold the basis 3 vectors
                base[0] = injet   ; // record the leading vector
                base[1] = jets[0] ; // record the other 2 vectors before gram-schmidt
                base[2] = jets[1] ; // We now need to do the same boosting and rescaling procedure on these basis vectors.
                for(size_t i=0;i<3;i++){
                    base[i] =
                        base[i] * (M_0/M_J) // rescaling the basis vectors
                    ; //
                    base[i] =
                        base[i]
                        .LorentzBoostGamma(dir) // boosting the basis vectors
                    ; //
                    e[i] =
                        base[i].xyz.dir() // finally record the normalized 3-vector components of the above basis 4-vectors.
                    ; //
                }
                e[1] = ( e[1] - (e[0]*(e[1]*e[0])) ).dir() ; // Gram-Schmidt on the second basis (first basis was the jet momenta itself)
                e[2] = ( e[2] - (e[0]*(e[2]*e[0])) ).dir() ; // Gram-Schmidt on the third basis.
                e[2] = ( e[2] - (e[1]*(e[2]*e[1])) ).dir() ; // Again, the second step of gram schmidt on the third basis vector
                for(size_t i=0;i<JetVectors.size();i++){
                    TYPE_DATA X = // Recording the x coordinate of the constituent which will be used for filling the image
                        JetVectors[i].xyz * e[1] /
                        JetVectors[i][3]
                    ; //
                    if ( X < -1.0 ) { X = -1.0 ; } // To avoid segmentation faults due to simple numerical errors.
                    if ( X >  1.0 ) { X =  1.0 ; }
                    long IX =
                        (long) N * ((X+1.0)/2.0) // evaluate the bin number to which toe energy needs to be filled.
                    ; //
                    if ( IX <     0 ) { IX =     0 ; } // Again avoid segmentation faults due to truncation errors.
                    if ( IX > N - 1 ) { IX = N - 1 ; }

                    TYPE_DATA Y = // Same procedure as X coordinate
                        JetVectors[i].xyz * e[2] /
                        JetVectors[i][3]
                    ; //
                    if ( Y < -1.0 ) { Y = -1.0 ; }
                    if ( Y >  1.0 ) { Y =  1.0 ; }
                    long IY =
                        (long) N * ((Y+1.0)/2.0)
                    ; //
                    if ( IY <     0 ) { IY =     0 ; }
                    if ( IY > N - 1 ) { IY = N - 1 ; }

                    MainStore[IY][IX] += // Finally add up the energy in the appropriate bin.
                        JetVectors[i][3] / E_0
                    ; //

                }
            }
            //printf("%e\n",MainStore.L1_NORM());
            return MainStore ; // Return the final 2D array, the array can also be accessed through the MainStore public member
        }
    public:

        inline InputArrayType operator () // provide a convinent call operator to make the syntax beautiful
        (fastjet::PseudoJet const & injet) {
            return Process(injet); // This is just a wrapper
        }

        MyJetImageGen(){} // Nothing to construct or destroy since no dynamic memory was used.
        ~MyJetImageGen(){}

    } ;


}
#endif




#ifdef USE_ROOT
#include <TH1F.h>
#include <TColor.h>
#include <TCanvas.h>
namespace NewHEPHeaders /*Nice Root Histogramming: */ {
    namespace Histograms {
        template <size_t Num, bool compare=false> class MyHistN {
        private:
            std::string   histname         ;
            std::string   histNnames [Num] ;
            TH1F        * Hists      [Num] ;
            bool logscale ;
        public:
            template <size_t Ii> inline void Fill (double a) { if (a>-90.0) {Hists[Ii]->Fill(a);} }
            inline void NormalizeHist (TH1F * inhist) { inhist->Scale(1.0/inhist->Integral()); inhist->SetLineWidth(3); }
            inline void DeleteAll () { for (size_t ii=0;ii<Num;ii++) { delete Hists[ii] ; } }
            inline void Write () {
                //printf("DEBUG: Called Write();");
                TCanvas C ; if(logscale){C.SetLogy();}
                Style_t styles[Num] ; /* Set the line style. */ {for(size_t i=0;i<Num;i++){styles[i]=kSolid;}}
                std::vector <int> Colors ; /* Decide Colors: */ {
                    if ((Num==6)&&compare) {
                        styles[0] = kSolid  ;
                        styles[1] = kSolid  ;
                        styles[2] = kSolid  ;
                        styles[3] = kDashed ;
                        styles[4] = kDashed ;
                        styles[5] = kDashed ;
                        Colors.push_back(TColor::GetColor("#990000"));
                        Colors.push_back(TColor::GetColor("#009900"));
                        Colors.push_back(TColor::GetColor("#000099"));
                        Colors.push_back(TColor::GetColor("#990000"));
                        Colors.push_back(TColor::GetColor("#009900"));
                        Colors.push_back(TColor::GetColor("#000099"));
                    } else if (Num==3) {
                        styles[0] = kSolid  ;
                        styles[1] = kSolid  ;
                        styles[2] = kSolid  ;
                        Colors.push_back(TColor::GetColor("#990000"));
                        Colors.push_back(TColor::GetColor("#009900"));
                        Colors.push_back(TColor::GetColor("#000099"));
                    } else if ((Num==4)&&compare) {
                        styles[0] = kSolid  ;
                        styles[1] = kSolid  ;
                        styles[2] = kDashed ;
                        styles[3] = kDashed ;
                        Colors.push_back(TColor::GetColor("#990000"));
                        Colors.push_back(TColor::GetColor("#000099"));
                        Colors.push_back(TColor::GetColor("#990000"));
                        Colors.push_back(TColor::GetColor("#000099"));
                    } else if (Num==2) {
                        Colors.push_back(TColor::GetColor("#990000"));
                        Colors.push_back(TColor::GetColor("#000099"));
                    } else {
                        Colors.push_back(TColor::GetColor("#990000"));
                        Colors.push_back(TColor::GetColor("#009900"));
                        Colors.push_back(TColor::GetColor("#000099"));
                        Colors.push_back(TColor::GetColor("#999900"));
                        Colors.push_back(TColor::GetColor("#990099"));
                        Colors.push_back(TColor::GetColor("#009999"));
                        Colors.push_back(TColor::GetColor("#000000"));
                    }
                }
                double YMax = 0 ;
                for(size_t i=0;i<Num;i++){
                    NormalizeHist(Hists[i]);
                    int    binmax = Hists[i]->GetMaximumBin ()            ;
                    double TmpMax = Hists[i]->GetBinContent (binmax)      ;
                    YMax          = CPPFileIO::mymax        (YMax,TmpMax) ;
                }
                for(size_t i=0;i<Num;i++){
                    Hists[i]->SetMaximum   ( YMax        ) ;
                    Hists[i]->SetLineColor ( Colors[i]   ) ;
                    Hists[i]->SetLineStyle ( styles[i]   ) ;
                    Hists[i]->Draw         ( "hist same" ) ;
                }
                mkdir((const char*)"./GRAPHS",(mode_t)0755);
                std::string outname  = "./GRAPHS/" + histname + ".pdf" ;
                std::string outnameC = "./GRAPHS/" + histname + ".C"   ;
                C.SaveAs(&(outname[0])); C.SaveAs(&(outnameC[0]));
                DeleteAll () ;
            }
            inline void AllocateAll (size_t nbins, double min, double max) {
                for(size_t ii=0;ii<Num;ii++){
                    char tmp[1024]; sprintf(tmp,"%s_%ld",&(histname[0]),ii);
                    histNnames[ii] = std::string(tmp);
                    Hists[ii] = new TH1F ( & ( histNnames[ii][0] ) , & ( histname [0] ) , nbins , min , max ) ;
                }
            }
            inline void SetLogScale (bool _logscale) {logscale=_logscale;}
            MyHistN  (std::string _histname, size_t nbins, double min, double max) : histname(_histname)
            { AllocateAll (nbins,min,max) ; logscale=false; }
            ~MyHistN () { Write () ; }
        };
    }
}
#endif

#ifdef USE_DELPHES
#include <TFile.h>
#include <TChain.h>
#include <TTree.h>
#include <TH2.h>
#include <TStyle.h>
#include <TCanvas.h>
#include <TROOT.h>
#include "TClonesArray.h"
#include "TObject.h"
#include "classes/DelphesClasses.h"
namespace NewHEPHeaders /* The Delphes part: */ {
    template <typename T> class DelphesReader : public T {
    public:
        typedef DelphesReader<T> TYPE_Self ;
        template <typename T2> inline void operator () (T2&analyzer) {
            if (this->fChain != 0) {
                long nentries = this->fChain->GetEntriesFast();
                long nbytes = 0, nb = 0;
                for (long jentry=0; jentry<nentries;jentry++) {
                    long ientry = this->LoadTree(jentry);
                    if((jentry%1000)==0){printf("Analyzed %ld events\n",jentry);}
                    if (ientry >= 0) {
                        nb = this->fChain->GetEntry(jentry);
                        nbytes += nb;
                        analyzer(this[0]);
                    }
                }
            }
        }
    } ;
    template < typename TR=double, typename TI=int >
    class DelphesVectorsList : public std::vector <VECTORS::DelphesVectors<TR,TI>> {
    public:
        typedef VECTORS::DelphesVectors <TR,TI> TYPE_Element ;
        typedef DelphesVectorsList      <TR,TI> TYPE_Self    ;
        VECTORS::GenParticles <TR,TI> GenParts ;
        inline double CalcPtSum (size_t index, double cone) const {
            double ret = 0;
            for(size_t i=0;i<this->size();i++) if(i!=index) if(this[0][i](this[0][index])<cone)
            {ret+=this[0][i].pt();}
            return ret ;
        }
        inline size_t Count_Tracks ( fastjet::PseudoJet & injet ) {
            TYPE_Self & self = this[0] ;
            size_t ret = 0 ;
            pseudojets cons = injet.constituents();
            for(size_t i=0;i<cons.size();i++)
            { int j = cons[i].user_index() ; ret += CPPFileIO::mymod (self[j].Charge) ; }
            return ret ;
        }
        inline double HCal_Fraction ( fastjet::PseudoJet & injet ) {
            TYPE_Self & self = this[0] ;
            double ret = 0 ;
            pseudojets cons = injet.constituents();
            for(size_t i=0;i<cons.size();i++)
            { int j=cons[i].user_index() ; ret += self[j].Ehad ; }
            return ret ;
        }
        inline double ECal_Fraction ( fastjet::PseudoJet & injet ) {
            TYPE_Self & self = this[0] ;
            double ret = 0 ;
            pseudojets cons = injet.constituents();
            for(size_t i=0;i<cons.size();i++)
            { int j=cons[i].user_index() ; ret += self[j].Eem ; }
            return ret ;
        }
        template <typename T1> inline void ReadFromDelphes (T1 & inref) {
            GenParts.ReadFromDelphes(inref);
            size_t limit_EFlowNeutralHadron = inref.EFlowNeutralHadron_ ;
            size_t limit_EFlowPhoton        = inref.EFlowPhoton_        ;
            size_t limit_EFlowTrack         = inref.EFlowTrack_         ;
            /* Prepare the vectors: */ {
                this->clear();
                this->reserve(limit_EFlowNeutralHadron+limit_EFlowPhoton+limit_EFlowTrack);
            }
            /* Read Neutral Hadrons : */ {
                for(size_t i=0;i<limit_EFlowNeutralHadron;i++){
                    TYPE_Element tmp2 ; /* Read in the track vectors: */ {
                        tmp2.SetPtEtaPhiM (
                            inref.EFlowNeutralHadron_ET  [i] ,
                            inref.EFlowNeutralHadron_Eta [i] ,
                            inref.EFlowNeutralHadron_Phi [i] ,
                            0
                        );
                        /* Set the energy fractions: */ {
                            tmp2.Eem    = inref.EFlowNeutralHadron_Eem  [i] ;
                            tmp2.Ehad   = inref.EFlowNeutralHadron_Ehad [i] ;
                            tmp2.Emu    = 0                                 ;
                            tmp2.Charge = 0                                 ;
                        }
                    }
                    this->push_back(tmp2);
                }
            }
            /* Read Photons         : */ {
                for(size_t i=0;i<limit_EFlowPhoton;i++){
                    TYPE_Element tmp2 ; /* Read in the track vectors: */ {
                        tmp2.SetPtEtaPhiM (
                            inref.EFlowPhoton_ET  [i] ,
                            inref.EFlowPhoton_Eta [i] ,
                            inref.EFlowPhoton_Phi [i] ,
                            0
                        );
                        /* Set the energy fractions: */ {
                            tmp2.Eem    = inref.EFlowPhoton_Eem  [i] ;
                            tmp2.Ehad   = inref.EFlowPhoton_Ehad [i] ;
                            tmp2.Emu    = 0                          ;
                            tmp2.Charge = 0                          ;
                        }
                    }
                    this->push_back (tmp2) ;
                }
            }
            /* Read tracks          : */ {
                for(size_t i=0;i<limit_EFlowTrack;i++){
                    TYPE_Element tmp2 ; /* Read in the track vectors: */ {
                        tmp2.SetPtEtaPhiM (
                            inref.EFlowTrack_PT  [i] ,
                            inref.EFlowTrack_Eta [i] ,
                            inref.EFlowTrack_Phi [i] ,
                            0
                        ); /* Set the energy fractions: */ {
                            if ( CPPFileIO::mymod (inref.EFlowTrack_PID[i]) == PID::MUON ) {
                                tmp2.Eem  = tmp2[3] * 0.0 ;
                                tmp2.Ehad = tmp2[3] * 0.0 ;
                                tmp2.Emu  = tmp2[3] * 1.0 ;
                            } else if ( CPPFileIO::mymod (inref.EFlowTrack_PID[i]) == PID::ELECTRON ) {
                                tmp2.Eem  = tmp2[3] * 1.0 ;
                                tmp2.Ehad = tmp2[3] * 0.0 ;
                                tmp2.Emu  = tmp2[3] * 0.0 ;
                            } else {
                                tmp2.Eem  = tmp2[3] * 0.01 ;
                                tmp2.Ehad = tmp2[3] * 0.99 ;
                                tmp2.Emu  = tmp2[3] * 0.00 ;
                            }
                        }
                    }
                    tmp2.Charge = inref.EFlowTrack_Charge [i] ;
                    this->push_back ( tmp2 ) ;
                }
            }
        }
    } ;
    template < typename TR=double, typename TI=int >
    class FullDelphesReader : public DelphesVectorsList <TR,TI> {
    public:
        pseudojets tofastjet ;
        inline void Prepare (double const isocone=0.3, double const isoratio=0.15) {
            tofastjet.clear();
            for (size_t i=0;i<this->size();i++) {
                bool isolepton = (this[0][i].IsLepton())&&(this[0][i].pt()>20)&&(this[0][i].meta()<2.5) ;
                if (isolepton) {
                    double ptratio = this->CalcPtSum(i,isocone) / this[0][i].pt();
                    isolepton = (ptratio<isoratio) ;
                }
                if (!isolepton){
                    fastjet::PseudoJet tmpjet = this[0][i].getpseudojet () ;
                    tmpjet.set_user_index ((int)i) ;
                    tofastjet.push_back (tmpjet) ;
                }
            }
        }
    } ;
}
#endif
#endif
